*An OMG^®^ Decision Model and Notation^TM^ Publication*

image:extracted-media/media/image1.png[image,width=269,height=121]

[#_Toc49930093 .anchor]####Decision Model and Notation

Version 1.4

OMG Document Number: dtc/21-11-14

Release Date: December 2021

Standard Document URL: https://www.omg.org/spec/acronym/x.x[https://www.omg.org/spec/DMN]

Machine Consumable Files:

Normative:

https://www.omg.org/spec/DMN/20211108/DMN14.xsd +
https://www.omg.org/spec/DMN/20211108/DMN14.xmi +
https://www.omg.org/spec/DMN/20191111/DMNDI13.xsd +
https://www.omg.org/spec/DMN/20191111/DMNDI13.xmi +
https://www.omg.org/spec/DMN/20180521/DI.xsd +
https://www.omg.org/spec/DMN/20180521/DC.xsd

Informative:

https://www.omg.org/spec/DMN/20211108/examples.zip +
https://www.omg.org/spec/DMN/20211108/DMN14_MagicDraw.xml

https://www.omg.org/spec/DMN/20211108/DMN14.mdzip

https://www.omg.org/spec/DMN/20191010/DMNDI13_MagicDraw.xml +
https://www.omg.org/spec/DMN/20191012/DMNDI13.mdzip

____
Copyright © 2019-2021, 88solutions

Copyright © 2019-2021, BOC Products & Services AG

Copyright © 2015-2021, Camunda Services GmbH Copyright © 2013-2021, Decision Management Solutions

Copyright © 2019-2021, Department of Veterans Affairs

Copyright © 2013-2019, Escape Velocity LLC

Copyright © 2013-2021, Fair Isaac Corporation

Copyright © 2019-2021, GfSE e.V.

Copyright © 2013-2019, International Business Machines Corporation

Copyright © 2013-2021, KU Leuven

Copyright © 2013-2019, Model Systems Limited Copyright © 2015-2019, Oracle Incorporated

Copyright © 2019-2021, PNA Group

Copyright © 2020-2021, processCentric Gmbh

Copyright © 2013-2021, Red Hat Inc

Copyright © 2013-2020, Sapiens Decision NA

Copyright © 2019-2021, Signavio Gmbh

Copyright © 2019-2021, Sparx Systems Pty Ltd

Copyright © 2019-2021, Thematix Partners LLC

Copyright © 2014-2019, TIBCO Software Inc.

Copyright © 2015-2021, Trisotech

Copyright © 2015-2021, Object Management Group, Inc.
____

USE OF SPECIFICATION – TERMS, CONDITIONS & NOTICES

The material in this document details an Object Management Group specification in accordance with the terms, conditions and notices set forth below. This document does not represent a commitment to implement any portion of this specification in any company's products. The information contained in this document is subject to change without notice.

LICENSES

The companies listed above have granted to the Object Management Group, Inc. (OMG) a nonexclusive, royalty-free, paid up, worldwide license to copy and distribute this document and to modify this document and distribute copies of the modified version. Each of the copyright holders listed above has agreed that no person shall be deemed to have infringed the copyright in the included material of any such copyright holder by reason of having used the specification set forth herein or having conformed any computer software to the specification.

Subject to all of the terms and conditions below, the owners of the copyright in this specification hereby grant you a fully-paid up, non-exclusive, nontransferable, perpetual, worldwide license (without the right to sublicense), to use this specification to create and distribute software and special purpose specifications that are based upon this specification, and to use, copy, and distribute this specification as provided under the Copyright Act; provided that: (1) both the copyright notice identified above and this permission notice appear on any copies of this specification; (2) the use of the specifications is for informational purposes and will not be copied or posted on any network computer or broadcast in any media and will not be otherwise resold or transferred for commercial purposes; and (3) no modifications are made to this specification. This limited permission automatically terminates without notice if you breach any of these terms or conditions. Upon termination, you will destroy immediately any copies of the specifications in your possession or control.

PATENTS

The attention of adopters is directed to the possibility that compliance with or adoption of OMG specifications may require use of an invention covered by patent rights. OMG shall not be responsible for identifying patents for which a license may be required by any OMG specification, or for conducting legal inquiries into the legal validity or scope of those patents that are brought to its attention. OMG specifications are prospective and advisory only. Prospective users are responsible for protecting themselves against liability for infringement of patents.

GENERAL USE RESTRICTIONS

Any unauthorized use of this specification may violate copyright laws, trademark laws, and communications regulations and statutes. This document contains information which is protected by copyright. All Rights Reserved. No part of this work covered by copyright herein may be reproduced or used in any form or by any means--graphic, electronic, or mechanical, including photocopying, recording, taping, or information storage and retrieval systems--without permission of the copyright owner.

DISCLAIMER OF WARRANTY

WHILE THIS PUBLICATION IS BELIEVED TO BE ACCURATE, IT IS PROVIDED "AS IS" AND MAY CONTAIN ERRORS OR MISPRINTS. THE OBJECT MANAGEMENT GROUP AND THE COMPANIES LISTED ABOVE MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS PUBLICATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF TITLE OR OWNERSHIP, IMPLIED WARRANTY OF MERCHANTABILITY OR WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE. IN NO EVENT SHALL THE OBJECT MANAGEMENT GROUP OR ANY OF THE COMPANIES LISTED ABOVE BE LIABLE FOR ERRORS CONTAINED HEREIN OR FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, RELIANCE OR COVER DAMAGES, INCLUDING LOSS OF PROFITS, REVENUE, DATA OR USE, INCURRED BY ANY USER OR ANY THIRD PARTY IN CONNECTION WITH THE FURNISHING, PERFORMANCE, OR USE OF THIS MATERIAL, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

The entire risk as to the quality and performance of software developed using this specification is borne by you. This disclaimer of warranty constitutes an essential part of the license granted to you to use this specification.

RESTRICTED RIGHTS LEGEND

Use, duplication or disclosure by the U.S. Government is subject to the restrictions set forth in subparagraph (c) (1) (ii) of The Rights in Technical Data and Computer Software Clause at DFARS 252.227-7013 or in subparagraph (c)(1) and (2) of the Commercial Computer Software - Restricted Rights clauses at 48 C.F.R. 52.227-19 or as specified in 48 C.F.R. 227-7202-2 of the DoD F.A.R. Supplement and its successors, or as specified in 48 C.F.R. 12.212 of the Federal Acquisition Regulations and its successors, as applicable. The specification copyright owners are as indicated above and may be contacted through the Object Management Group, 9C Medway Road, PMB 274, Milford, MA 01757, U.S.A.

TRADEMARKS

CORBA^®^, CORBA logos^®^, FIBO^®^, Financial Industry Business Ontology^®^, FINANCIAL INSTRUMENT GLOBAL IDENTIFIER^®^, IIOP^®^, IMM^®^, Model Driven Architecture^®^, MDA^®^, Object Management Group^®^, OMG^®^, OMG Logo^®^, SoaML^®^, SOAML^®^, SysML^®^, UAF^®^, Unified Modeling Language^®^, UML^®^, UML Cube Logo^®^, VSIPL^®^, and XMI^®^ are registered trademarks of the Object Management Group, Inc.

For a complete list of trademarks, see: https://www.omg.org/legal/tm_list.htm. All other products or company names mentioned are used for identification purposes only, and may be trademarks of their respective owners.

COMPLIANCE

The copyright holders listed above acknowledge that the Object Management Group (acting itself or through its designees) is and shall at all times be the sole entity that may authorize developers, suppliers and sellers of computer software to use certification marks, trademarks or other special designations to indicate compliance with these materials.

Software developed under the terms of this license may claim compliance or conformance with this specification if and only if the software compliance is of a nature fully matching the applicable compliance points as stated in the specification. Software developed only partially matching the applicable compliance points may claim only that the software was based on this specification, but may not claim compliance or conformance with this specification. In the event that testing suites are implemented or approved by Object Management Group, Inc., software developed using this specification may claim compliance or conformance with the specification only if the software satisfactorily completes the testing suites.

*OMG's Issue Reporting Procedure*

All OMG specifications are subject to continuous review and improvement. As part of this process we encourage readers to report any ambiguities, inconsistencies, or inaccuracies they may find by completing the Issue Reporting Form listed on the main web page https://www.omg.org, under Specifications, Report a Bug/Issue.

Table of Contents

== 

link:#_Toc49930093[Decision Model and Notation link:#_Toc49930093[i]]

link:#scope[1 Scope link:#scope[1]]

link:#conformance[2 Conformance link:#conformance[2]]

link:#conformance-levels[2.1 Conformance levels link:#conformance-levels[2]]

link:#general-conformance-requirement[2.2 General conformance requirement link:#general-conformance-requirement[2]]

link:#visual-appearance[2.2.1 Visual appearance link:#visual-appearance[2]]

link:#new-markers-or-indicators-may-be-added-to-the-specified-graphical-elements.-these-markers-or-indicators-could-be-used-to-highlight-a-specific-attribute-of-a-dmn-element-or-to-represent-a-new-subtype-of-the-corresponding-concept.-a-new-shape-representing-a-new-kind-of-artifact-may-be-added-to-a-diagram-but-the-new-shape-shall-not-conflict-with-the-shape-specified-for-any-other-dmn-element-or-marker.graphical-elements-may-be-colored-and-the-coloring-may-have-specified-semantics-that-extend-the-information-conveyed-by-the-element-as-specified-in-this-standard.the-line-style-of-a-graphical-element-may-be-changed-but-that-change-shall-not-conflict-with-any-other-line-style-required-by-this-specification.decision-semantics[2.2.2 Decision semantics link:#new-markers-or-indicators-may-be-added-to-the-specified-graphical-elements.-these-markers-or-indicators-could-be-used-to-highlight-a-specific-attribute-of-a-dmn-element-or-to-represent-a-new-subtype-of-the-corresponding-concept.-a-new-shape-representing-a-new-kind-of-artifact-may-be-added-to-a-diagram-but-the-new-shape-shall-not-conflict-with-the-shape-specified-for-any-other-dmn-element-or-marker.graphical-elements-may-be-colored-and-the-coloring-may-have-specified-semantics-that-extend-the-information-conveyed-by-the-element-as-specified-in-this-standard.the-line-style-of-a-graphical-element-may-be-changed-but-that-change-shall-not-conflict-with-any-other-line-style-required-by-this-specification.decision-semantics[3]]

link:#attributes-and-model-associations[2.2.3 Attributes and model associations link:#attributes-and-model-associations[3]]

link:#references[3 References link:#references[4]]

link:#normative[3.1 Normative link:#normative[4]]

link:#xquery-1.0-and-xpath-2.0-functions-and-operators-second-edition-w3c-recommendation-14-december-2010-httpwww.w3.orgtrxpath-functionsxquerynon-normative[3.2 Non-normative link:#xquery-1.0-and-xpath-2.0-functions-and-operators-second-edition-w3c-recommendation-14-december-2010-httpwww.w3.orgtrxpath-functionsxquerynon-normative[5]]

link:#additional-information[4 Additional Information link:#additional-information[7]]

link:#acknowledgements[4.1 Acknowledgements link:#acknowledgements[7]]

link:#ipr-and-patents[4.2 IPR and Patents link:#ipr-and-patents[7]]

link:#guide-to-the-specification[4.3 Guide to the Specification link:#guide-to-the-specification[7]]

link:#introduction-to-dmn[5 Introduction to DMN link:#introduction-to-dmn[9]]

link:#context[5.1 Context link:#context[9]]

link:#scope-and-uses-of-dmn[5.2 Scope and uses of DMN link:#scope-and-uses-of-dmn[11]]

link:#for-modeling-human-decision-making.for-modeling-the-requirements-for-automated-decision-making.for-implementing-automated-decision-making.modeling-human-decision-making[5.2.1 Modeling human decision-making link:#for-modeling-human-decision-making.for-modeling-the-requirements-for-automated-decision-making.for-implementing-automated-decision-making.modeling-human-decision-making[11]]

link:#modeling-requirements-for-automated-decision-making[5.2.2 Modeling requirements for automated decision-making link:#modeling-requirements-for-automated-decision-making[12]]

link:#implementing-automated-decision-making[5.2.3 Implementing automated decision-making link:#implementing-automated-decision-making[13]]

link:#combining-applications-of-modeling[5.2.4 Combining applications of modeling link:#combining-applications-of-modeling[13]]

link:#basic-concepts[5.3 Basic concepts link:#basic-concepts[13]]

link:#decision-requirements-level[5.3.1 Decision requirements level link:#decision-requirements-level[13]]

link:#decision-logic-level[5.3.2 Decision logic level link:#decision-logic-level[15]]

link:#decision-services[5.3.3 Decision services link:#decision-services[17]]

link:#requirements-drg-and-drdintroduction[6 Requirements (DRG and DRD) link:#requirements-drg-and-drdintroduction[20]]

link:#requirements-drg-and-drdintroduction[6.1 Introduction link:#requirements-drg-and-drdintroduction[20]]

link:#notation[6.2 Notation link:#notation[20]]

link:#drd-elements[6.2.1 DRD Elements link:#drd-elements[22]]

link:#drd-requirements[6.2.2 DRD Requirements link:#drd-requirements[23]]

link:#connection-rules[6.2.3 Connection rules link:#connection-rules[25]]

link:#partial-views-and-hidden-information[6.2.4 Partial views and hidden information link:#partial-views-and-hidden-information[26]]

link:#decision-service[6.2.5 Decision service link:#decision-service[27]]

link:#identifying-collections[6.2.6 Identifying Collections link:#identifying-collections[29]]

link:#metamodel[6.3 Metamodel link:#metamodel[30]]

link:#dmn-element-metamodel[6.3.1 DMN Element metamodel link:#dmn-element-metamodel[30]]

link:#definitions-metamodel[6.3.2 Definitions metamodel link:#definitions-metamodel[32]]

link:#import-metamodel[6.3.3 Import metamodel link:#import-metamodel[34]]

link:#element-collection-metamodel[6.3.4 Element Collection metamodel link:#element-collection-metamodel[34]]

link:#drg-element-metamodel[6.3.5 DRG Element metamodel link:#drg-element-metamodel[35]]

link:#artifact-metamodel[6.3.6 Artifact metamodel link:#artifact-metamodel[35]]

link:#decision-metamodel[6.3.7 Decision metamodel link:#decision-metamodel[37]]

link:#business-context-element-metamodel[6.3.8 Business Context Element metamodel link:#business-context-element-metamodel[39]]

link:#business-knowledge-model-metamodel[6.3.9 Business Knowledge Model metamodel link:#business-knowledge-model-metamodel[40]]

link:#decision-service-metamodel[6.3.10 Decision service metamodel link:#decision-service-metamodel[42]]

link:#input-data-metamodel[6.3.11 Input Data metamodel link:#input-data-metamodel[43]]

link:#knowledge-source-metamodel[6.3.12 Knowledge Source metamodel link:#knowledge-source-metamodel[44]]

link:#information-requirement-metamodel[6.3.13 Information Requirement metamodel link:#information-requirement-metamodel[45]]

link:#knowledge-requirement-metamodel[6.3.14 Knowledge Requirement metamodel link:#knowledge-requirement-metamodel[45]]

link:#authority-requirement-metamodel[6.3.15 Authority Requirement metamodel link:#authority-requirement-metamodel[46]]

link:#extensibility[6.3.16 Extensibility link:#extensibility[47]]

link:#examples[6.4 Examples link:#examples[48]]

link:#relating-decision-logic-to-decision-requirements[7 Relating Decision Logic to Decision Requirements link:#relating-decision-logic-to-decision-requirements[49]]

link:#introduction[7.1 Introduction link:#introduction[49]]

link:#notation-1[7.2 Notation link:#notation-1[51]]

link:#expressions[7.2.1 Expressions link:#expressions[51]]

link:#boxed-literal-expression[7.2.2 Boxed literal expression link:#boxed-literal-expression[52]]

link:#boxed-invocation[7.2.3 Boxed invocation link:#boxed-invocation[52]]

link:#metamodel-1[7.3 Metamodel link:#metamodel-1[53]]

link:#expression-metamodel[7.3.1 Expression metamodel link:#expression-metamodel[54]]

link:#unarytests-metamodel[7.3.2 UnaryTests Metamodel link:#unarytests-metamodel[55]]

link:#itemdefinition-metamodel[7.3.3 ItemDefinition metamodel link:#itemdefinition-metamodel[55]]

link:#informationitem-metamodel[7.3.4 InformationItem metamodel link:#informationitem-metamodel[58]]

link:#literal-expression-metamodel[7.3.5 Literal expression metamodel link:#literal-expression-metamodel[58]]

link:#invocation-metamodel[7.3.6 Invocation metamodel link:#invocation-metamodel[59]]

link:#binding-metamodel[7.3.7 Binding metamodel link:#binding-metamodel[60]]

link:#decision-tableintroduction[8 Decision Table link:#decision-tableintroduction[61]]

link:#decision-tableintroduction[8.1 Introduction link:#decision-tableintroduction[61]]

link:#notation-2[8.2 Notation link:#notation-2[64]]

link:#line-style-and-color[8.2.1 Line style and color link:#line-style-and-color[65]]

link:#table-orientation[8.2.2 Table orientation link:#table-orientation[65]]

link:#input-expressions[8.2.3 Input expressions link:#input-expressions[67]]

link:#input-values[8.2.4 Input values link:#input-values[67]]

link:#information-item-names-output-labels-and-output-component-names[8.2.5 Information Item names&#44; output labels&#44; and output component names link:#information-item-names-output-labels-and-output-component-names[67]]

link:#multiple-outputs[8.2.6 Multiple outputs link:#multiple-outputs[68]]

link:#input-entries[8.2.7 Input entries link:#input-entries[69]]

link:#merged-input-entry-cells[8.2.8 Merged input entry cells link:#merged-input-entry-cells[69]]

link:#output-entry[8.2.9 Output entry link:#output-entry[69]]

link:#hit-policy[8.2.10 Hit policy link:#hit-policy[70]]

link:#default-output-values[8.2.11 Default output values link:#default-output-values[72]]

link:#metamodel-2[8.3 Metamodel link:#metamodel-2[73]]

link:#decision-table-metamodel[8.3.1 Decision Table metamodel link:#decision-table-metamodel[73]]

link:#decision-table-input-and-output-metamodel[8.3.2 Decision Table Input and Output metamodel link:#decision-table-input-and-output-metamodel[74]]

link:#decision-rule-metamodel[8.3.3 Decision Rule metamodel link:#decision-rule-metamodel[75]]

link:#examples-1[8.4 Examples link:#examples-1[77]]

link:#simple-expression-language-s-feelintroduction[9 Simple Expression Language (S-FEEL) link:#simple-expression-language-s-feelintroduction[81]]

link:#simple-expression-language-s-feelintroduction[9.1 Introduction link:#simple-expression-language-s-feelintroduction[81]]

link:#s-feel-syntax[9.2 S-FEEL syntax link:#s-feel-syntax[81]]

link:#s-feel-data-types[9.3 S-FEEL data types link:#s-feel-data-types[83]]

link:#s-feel-semantics[9.4 S-FEEL semantics link:#s-feel-semantics[83]]

link:#use-of-s-feel-expressions[9.5 Use of S-FEEL expressions link:#use-of-s-feel-expressions[84]]

link:#item-definitions[9.5.1 Item definitions link:#item-definitions[84]]

link:#invocations[9.5.2 Invocations link:#invocations[84]]

link:#decision-tables[9.5.3 Decision tables link:#decision-tables[84]]

link:#expression-language-feel[10 Expression Language (FEEL) link:#expression-language-feel[86]]

link:#introduction-1[10.1 Introduction link:#introduction-1[86]]

link:#as-a-textual-notation-in-the-boxes-of-boxed-expressions-such-as-decision-tables.as-a-slightly-larger-language-to-represent-the-logic-of-expressions-and-drgs-for-the-main-purpose-of-composing-the-semantics-in-a-simple-and-uniform-way.-notation[10.2 Notation link:#as-a-textual-notation-in-the-boxes-of-boxed-expressions-such-as-decision-tables.as-a-slightly-larger-language-to-represent-the-logic-of-expressions-and-drgs-for-the-main-purpose-of-composing-the-semantics-in-a-simple-and-uniform-way.-notation[86]]

link:#boxed-expressions[10.2.1 Boxed Expressions link:#boxed-expressions[86]]

link:#feel[10.2.2 FEEL link:#feel[98]]

link:#full-feel-syntax-and-semantics[10.3 Full FEEL Syntax and Semantics link:#full-feel-syntax-and-semantics[99]]

link:#syntax[10.3.1 Syntax link:#syntax[100]]

link:#semantics[10.3.2 Semantics link:#semantics[106]]

link:#xml-data[10.3.3 XML Data link:#xml-data[134]]

link:#built-in-functions[10.3.4 Built-in functions link:#built-in-functions[137]]

link:#execution-semantics-of-decision-services[10.4 Execution Semantics of Decision Services link:#execution-semantics-of-decision-services[156]]

link:#metamodel-3[10.5 Metamodel link:#metamodel-3[157]]

link:#context-metamodel[10.5.1 Context metamodel link:#context-metamodel[157]]

link:#contextentry-metamodel[10.5.2 ContextEntry metamodel link:#contextentry-metamodel[158]]

link:#functiondefinition-metamodel[10.5.3 FunctionDefinition metamodel link:#functiondefinition-metamodel[158]]

link:#list-metamodel[10.5.4 List metamodel link:#list-metamodel[159]]

link:#relation-metamodel[10.5.5 Relation metamodel link:#relation-metamodel[159]]

link:#conditional-metamodel[10.5.6 Conditional metamodel link:#conditional-metamodel[159]]

link:#childexpression-metamodel[10.5.7 ChildExpression metamodel link:#childexpression-metamodel[159]]

link:#filter-metamodel[10.5.8 Filter metamodel link:#filter-metamodel[160]]

link:#iterator-metamodel[10.5.9 Iterator metamodel link:#iterator-metamodel[160]]

link:#for-metamodel[10.5.10 For metamodel link:#for-metamodel[160]]

link:#quantified-metamodel[10.5.11 Quantified metamodel link:#quantified-metamodel[161]]

link:#every-metamodel[10.5.12 Every metamodel link:#every-metamodel[161]]

link:#some-metamodel[10.5.13 Some metamodel link:#some-metamodel[161]]

link:#examples-4[10.6 Examples link:#examples-4[161]]

link:#context-2[10.6.1 Context link:#context-2[161]]

link:#calculation[10.6.2 Calculation link:#calculation[162]]

link:#if-in[10.6.3 If&#44; In link:#if-in[162]]

link:#sum-entries-of-a-list[10.6.4 Sum entries of a list link:#sum-entries-of-a-list[163]]

link:#invocation-of-user-defined-pmt-function[10.6.5 Invocation of user-defined PMT function link:#invocation-of-user-defined-pmt-function[163]]

link:#sum-weights-of-a-recent-credit-history[10.6.6 Sum weights of a recent credit history link:#sum-weights-of-a-recent-credit-history[163]]

link:#determine-if-credit-history-contain-a-bankruptcy-event[10.6.7 Determine if credit history contain a bankruptcy event link:#determine-if-credit-history-contain-a-bankruptcy-event[163]]

link:#dmn-examples-example-1-originations[11 DMN Examples link:#dmn-examples-example-1-originations[164]]

link:#dmn-examples-example-1-originations[11.1 Example 1: Originations link:#dmn-examples-example-1-originations[164]]

link:#introduction-2[11.1.1 Introduction link:#introduction-2[164]]

link:#the-business-process-model[11.1.2 The business process model link:#the-business-process-model[164]]

link:#the-decision-requirements-level[11.1.3 The decision requirements level link:#the-decision-requirements-level[165]]

link:#the-decision-logic-level[11.1.4 The decision logic level link:#the-decision-logic-level[176]]

link:#executing-the-decision-model[11.1.5 Executing the Decision Model link:#executing-the-decision-model[188]]

link:#example-2-ranked-loan-products[11.2 Example 2: Ranked Loan Products link:#example-2-ranked-loan-products[190]]

link:#exchange-formats-interchanging-incomplete-models[12 Exchange formats link:#exchange-formats-interchanging-incomplete-models[209]]

link:#exchange-formats-interchanging-incomplete-models[12.1 Interchanging Incomplete Models link:#exchange-formats-interchanging-incomplete-models[209]]

link:#disregarding-missing-attributes-that-are-marked-as-required-in-the-dmn-xml-schema.reducing-the-lower-bound-of-elements-with-minoccurs-greater-than-0.-machine-readable-files[12.2 Machine Readable Files link:#disregarding-missing-attributes-that-are-marked-as-required-in-the-dmn-xml-schema.reducing-the-lower-bound-of-elements-with-minoccurs-greater-than-0.-machine-readable-files[209]]

link:#for-the-dmn-xmi-model-the-main-file-is-dmn.xmi.for-the-dmn-xsd-interchange-supporting-conformance-levels-1-2-and-3-the-main-file-is-dmn.xsd.a-serialization-of-the-example-in-clause-11-is-provided-in-ch11example.-xsd[12.3 XSD link:#for-the-dmn-xmi-model-the-main-file-is-dmn.xmi.for-the-dmn-xsd-interchange-supporting-conformance-levels-1-2-and-3-the-main-file-is-dmn.xsd.a-serialization-of-the-example-in-clause-11-is-provided-in-ch11example.-xsd[209]]

link:#document-structure[12.3.1 Document Structure link:#document-structure[209]]

link:#references-within-the-dmn-xsd[12.3.2 References within the DMN XSD link:#references-within-the-dmn-xsd[209]]

link:#dmn-diagram-interchange-dmn-discope[13 DMN Diagram Interchange (DMN DI) link:#dmn-diagram-interchange-dmn-discope[211]]

link:#dmn-diagram-interchange-dmn-discope[13.1 Scope link:#dmn-diagram-interchange-dmn-discope[211]]

link:#diagram-definition-and-interchange[13.2 Diagram Definition and Interchange link:#diagram-definition-and-interchange[211]]

link:#how-to-read-this-chapter[13.3 How to read this chapter link:#how-to-read-this-chapter[211]]

link:#dmn-diagram-interchange-meta-model[13.4 DMN Diagram Interchange Meta-Model link:#dmn-diagram-interchange-meta-model[211]]

link:#overview[13.4.1 Overview link:#overview[211]]

link:#dmndi-class[13.4.2 DMNDI [Class] link:#dmndi-class[212]]

link:#dmndiagram-class[13.4.3 DMNDiagram [Class] link:#dmndiagram-class[213]]

link:#dmndiagramelement-class[13.4.4 DMNDiagramElement [Class] link:#dmndiagramelement-class[214]]

link:#dmnshape-class[13.4.5 DMNShape [Class] link:#dmnshape-class[215]]

link:#dmnedge-class[13.4.6 DMNEdge [Class] link:#dmnedge-class[216]]

link:#dmnlabel-class[13.4.7 DMNLabel [Class] link:#dmnlabel-class[217]]

link:#dmnstyle-class[13.4.8 DMNStyle [Class] link:#dmnstyle-class[218]]

link:#notation-depiction-library-and-abstract-element-resolutions[13.5 Notation Depiction Library and Abstract Element Resolutions link:#notation-depiction-library-and-abstract-element-resolutions[219]]

link:#labels[13.5.1 Labels link:#labels[220]]

link:#dmnshape-resolution[13.5.2 DMNShape Resolution link:#dmnshape-resolution[220]]

link:#dmnedge-resolution[13.5.3 DMNEdge Resolution link:#dmnedge-resolution[222]]

link:#_Toc87278776[Annex A Relation to BPMN link:#_Toc87278776[227]]

link:#_Toc87278777[A.1 Goals of BPMN and DMN link:#_Toc87278777[227]]

link:#_Toc87278778[A.2 BPMN Tasks and DMN Decisions link:#_Toc87278778[227]]

link:#_Toc87278779[A.3 Types of BPMN Tasks relevant to DMN link:#_Toc87278779[228]]

link:#_Toc87278780[A.4 Process gateways and Decisions link:#_Toc87278780[229]]

link:#_Toc87278781[A.5 Linking BPMN and DMN Models link:#_Toc87278781[229]]

link:#_Toc87278782[Annex B : Glossary link:#_Toc87278782[231]]

Table of Figures

link:#_Toc87278783[*Figure 5‑1: Aspects of modeling* link:#_Toc87278783[10]]

link:#_Toc87278784[*Figure 5‑2: DMN Constructs* link:#_Toc87278784[11]]

link:#_Toc87278785[*Figure 5‑3: Basic elements of a decision model* link:#_Toc87278785[14]]

link:#_Toc87278786[*Figure 5‑4: Knowledge sources* link:#_Toc87278786[14]]

link:#_Toc87278787[*Figure 5‑5: A simple Decision Requirements Diagram (DRD)* link:#_Toc87278787[14]]

link:#_Toc87278788[*Figure 5‑6: Combining business knowledge models* link:#_Toc87278788[15]]

link:#_Toc87278789[*Figure 5‑7: Decision and corresponding value expression* link:#_Toc87278789[15]]

link:#_Toc87278790[*Figure 5‑8: Business knowledge model and corresponding value expression* link:#_Toc87278790[16]]

link:#_Toc87278791[*Figure 5‑9: Business knowledge model and corresponding decision table* link:#_Toc87278791[16]]

link:#_Toc87278792[*Figure 5‑10: A decision service* link:#_Toc87278792[18]]

link:#_Toc87278793[*Figure 5‑11: A decision service taking a decision as input* link:#_Toc87278793[18]]

link:#_Toc87278794[*Figure 6‑1: Decision with Listed Input Data option* link:#_Toc87278794[22]]

link:#_Toc87278795[*Figure 6‑2: The Listed Input Data option* link:#_Toc87278795[23]]

link:#_Toc87278796[*Figure 6‑3: Knowledge Sources representing authorities* link:#_Toc87278796[24]]

link:#_Toc87278797[*Figure 6‑4: Knowledge source representing predictive analytics* link:#_Toc87278797[24]]

link:#_Toc87278798[*Figure 6‑5: DRDs as partial views of a DRG* link:#_Toc87278798[27]]

link:#_Toc87278799[*Figure 6‑6: Decision Service notation* link:#_Toc87278799[28]]

link:#_Toc87278800[*Figure 6‑7: A decision service in expanded and collapsed form* link:#_Toc87278800[28]]

link:#_Toc87278801[*Figure 6‑8: A decision service invoked in an expanded form* link:#_Toc87278801[29]]

link:#_Toc87278802[*Figure 6‑9: A decision service defined as an overlay* link:#_Toc87278802[29]]

link:#_Toc87278803[*Figure 6‑10: Decision and Input Data showing collection marker* link:#_Toc87278803[30]]

link:#_Toc87278804[*Figure 6‑11:* DMNElement *Class Diagram* link:#_Toc87278804[30]]

link:#_Toc87278805[*Figure 6‑12: Definitions Class Diagram* link:#_Toc87278805[32]]

link:#_Toc87278806[*Figure 6‑13: Decision Class Diagram* link:#_Toc87278806[37]]

link:#_Toc87278807[*Figure 6‑14: BusinessContextElement class diagram* link:#_Toc87278807[39]]

link:#_Toc87278808[*Figure 6‑15: BusinessKnowledgeModel class diagram* link:#_Toc87278808[40]]

link:#_Toc87278809[*Figure 6‑16: DecisionService class diagram* link:#_Toc87278809[42]]

link:#_Toc87278810[*Figure 6‑17: InputData class diagram* link:#_Toc87278810[43]]

link:#_Toc87278811[*Figure 6‑18: KnowledgeSource class diagram* link:#_Toc87278811[44]]

link:#_Toc87278812[*Figure 6‑19: Extensibility class diagram* link:#_Toc87278812[47]]

link:#_Toc87278813[*Figure 7‑1: Boxed Expression* link:#_Toc87278813[51]]

link:#_Toc87278814[*Figure 7‑2: Boxed expression with separated name and expression boxes* link:#_Toc87278814[51]]

link:#_Toc87278815[*Figure 7‑3: Decision table with italicized literals* link:#_Toc87278815[52]]

link:#_Toc87278816[*Figure 7‑4: Decision table with string literals* link:#_Toc87278816[52]]

link:#_Toc87278817[*Figure 7‑5: Boxed invocation* link:#_Toc87278817[53]]

link:#_Toc87278818[*Figure 7‑6: Expression class diagram* link:#_Toc87278818[54]]

link:#_Toc87278819[*Figure 7‑7: ItemDefinition class diagram* link:#_Toc87278819[57]]

link:#_Toc87278820[*Figure 8‑1: Decision table example (vertical orientation: rules as columns)* link:#_Toc87278820[62]]

link:#_Toc87278821[*Figure 8‑2: Decision table example (horizontal orientation: rules as rows)* link:#_Toc87278821[62]]

link:#_Toc87278822[*Figure 8‑3: Decision table example (vertical orientation&#44; multiple output components)* link:#_Toc87278822[63]]

link:#_Toc87278823[*Figure 8‑4: Decision table example (horizontal orientation&#44; multiple output components)* link:#_Toc87278823[63]]

link:#_Toc87278824[*Figure 8‑5: Rules as rows – schematic layout* link:#_Toc87278824[65]]

link:#_Toc87278825[*Figure 8‑6: Rules as rows – example* link:#_Toc87278825[66]]

link:#_Toc87278826[*Figure 8‑7: Rules as columns – schematic layout* link:#_Toc87278826[66]]

link:#_Toc87278827[*Figure 8‑8: Rules as columns – example* link:#_Toc87278827[66]]

link:#_Toc87278828[*Figure 8‑9: Rules as crosstab - schematic layout (optional input and output values not shown)* link:#_Toc87278828[66]]

link:#_Toc87278829[*Figure 8‑10: Rules as crosstab - simplified example with only two inputs* link:#_Toc87278829[67]]

link:#_Toc87278830[*Figure 8‑11: Rules as crosstab - example with three inputs* link:#_Toc87278830[67]]

link:#_Toc87278831[*Figure 8‑12: Horizontal table with multiple output components* link:#_Toc87278831[68]]

link:#_Toc87278832[*Figure 8‑13: Vertical table with multiple output components* link:#_Toc87278832[68]]

link:#_Toc87278833[*Figure 8‑14: Crosstab with multiple output components* link:#_Toc87278833[68]]

link:#_Toc87278834[*Figure 8‑15: Merged rule input cells allowed* link:#_Toc87278834[69]]

link:#_Toc87278835[*Figure 8‑16: Merged rule input cells not allowed* link:#_Toc87278835[69]]

link:#_Toc87278836[*Figure 8‑17: Shorthand notation for vertical tables (rules as columns)* link:#_Toc87278836[70]]

link:#_Toc87278837[*Figure 8‑18: Full notation for vertical tables (rules as columns)* link:#_Toc87278837[70]]

link:#_Toc87278838[*Figure 8‑19: Output order with compound output* link:#_Toc87278838[72]]

link:#_Toc87278839[*Figure 8‑20: DecisionTable class diagram* link:#_Toc87278839[73]]

link:#_Toc87278840[*Figure 10‑1: Boxed expression* link:#_Toc87278840[87]]

link:#_Toc87278841[*Figure 10‑2: Boxed expression with separated name and expression boxes* link:#_Toc87278841[87]]

link:#_Toc87278842[*Figure 10‑3: Boxed FEEL expression* link:#_Toc87278842[87]]

link:#_Toc87278843[*Figure 10‑4: Boxed invocation* link:#_Toc87278843[88]]

link:#_Toc87278844[*Figure 10‑5: Parameterless function* link:#_Toc87278844[88]]

link:#_Toc87278845[*Figure 10‑6: Vertical context* link:#_Toc87278845[88]]

link:#_Toc87278846[*Figure 10‑7: Horizontal context* link:#_Toc87278846[89]]

link:#_Toc87278847[*Figure 10‑8: Use of context entries* link:#_Toc87278847[89]]

link:#_Toc87278848[*Figure 10‑9: Use of final result box* link:#_Toc87278848[89]]

link:#_Toc87278849[*Figure 10‑10: Vertical context with decision table entry* link:#_Toc87278849[90]]

link:#_Toc87278850[*Figure 10‑11: Use of boxed expressions with a decision table* link:#_Toc87278850[91]]

link:#_Toc87278851[*Figure 10‑12: Vertical list* link:#_Toc87278851[92]]

link:#_Toc87278852[*Figure 10‑13: Horizontal list* link:#_Toc87278852[92]]

link:#_Toc87278853[*Figure 10‑14: Relation* link:#_Toc87278853[92]]

link:#_Toc87278854[*Figure 10‑15: Boxed function definition* link:#_Toc87278854[93]]

link:#_Toc87278855[*Figure 10‑16: Boxed conditional* link:#_Toc87278855[93]]

link:#_Toc87278856[*Figure 10‑17: Use of conditional expression with decision table and invocation* link:#_Toc87278856[94]]

link:#_Toc87278857[*Figure 10‑18: Filter expression* link:#_Toc87278857[94]]

link:#_Toc87278858[*Figure 10‑19: Use of filter expression with a list expression* link:#_Toc87278858[95]]

link:#_Toc87278859[*Figure 10‑20: For expression* link:#_Toc87278859[95]]

link:#_Toc87278860[*Figure 10‑21: Use of for expression that returns a context* link:#_Toc87278860[96]]

link:#_Toc87278861[*Figure 10‑22: Every expression* link:#_Toc87278861[96]]

link:#_Toc87278862[*Figure 10‑23: Use of every with a list expression* link:#_Toc87278862[97]]

link:#_Toc87278863[*Figure 10‑24: Some expression* link:#_Toc87278863[97]]

link:#_Toc87278864[*Figure 10‑25: Use of some with a relation and a decision table* link:#_Toc87278864[98]]

link:#_Toc87278865[*Figure 10‑26: FEEL lattice type* link:#_Toc87278865[112]]

link:#_Toc87278866[*Figure 10‑27: Expression class diagram* link:#_Toc87278866[157]]

link:#_Toc87278867[*Figure 10‑28: Example context* link:#_Toc87278867[162]]

link:#_Toc87278868[*Figure 11‑1: Example business process* link:#_Toc87278868[165]]

link:#_Toc87278869[*Figure 11‑2: DRD of all automated decision-making* link:#_Toc87278869[166]]

link:#_Toc87278870[*Figure 11‑3: DRD for Decide bureau strategy decision point* link:#_Toc87278870[167]]

link:#_Toc87278871[*Figure 11‑4: DRD for Decide routing decision point* link:#_Toc87278871[168]]

link:#_Toc87278872[*Figure 11‑5: DRD for Review application decision point* link:#_Toc87278872[168]]

link:#_Toc87278873[*Figure 11‑6: DRD for Credit Risk Analytics Knowledge Source* link:#_Toc87278873[169]]

link:#_Toc87278874[*Figure 11‑7: Bureau Strategy Decision Service* link:#_Toc87278874[175]]

link:#_Toc87278875[*Figure 11‑8: Routing Decision Service* link:#_Toc87278875[176]]

link:#_Toc87278876[*Figure 11‑9: Strategy decision logic* link:#_Toc87278876[178]]

link:#_Toc87278877[*Figure 11‑10: Bureau call type decision logic* link:#_Toc87278877[178]]

link:#_Toc87278878[*Figure 11‑11: Bureau call type table decision logic* link:#_Toc87278878[178]]

link:#_Toc87278879[*Figure 11‑12: Eligibility decision logic* link:#_Toc87278879[179]]

link:#_Toc87278880[*Figure 11‑13: Eligibility rules decision logic* link:#_Toc87278880[179]]

link:#_Toc87278881[*Figure 11‑14: Pre-bureau risk category decision logic* link:#_Toc87278881[179]]

link:#_Toc87278882[*Figure 11‑15: Pre-bureau risk category table decision logic* link:#_Toc87278882[180]]

link:#_Toc87278883[*Figure 11‑16: Application risk score decision logic* link:#_Toc87278883[180]]

link:#_Toc87278884[*Figure 11‑17: Application risk score model decision logic* link:#_Toc87278884[181]]

link:#_Toc87278885[*Figure 11‑18: Routing decision logic* link:#_Toc87278885[182]]

link:#_Toc87278886[*Figure 11‑19: Routing rules decision logic* link:#_Toc87278886[182]]

link:#_Toc87278887[*Figure 11‑20: Post-bureau risk category decision logic* link:#_Toc87278887[183]]

link:#_Toc87278888[*Figure 11‑21: Post-bureau risk category table decision logic* link:#_Toc87278888[184]]

link:#_Toc87278889[*Figure 11‑22: Pre-bureau affordability decision logic* link:#_Toc87278889[185]]

link:#_Toc87278890[*Figure 11‑23: Post-bureau affordability decision logic* link:#_Toc87278890[185]]

link:#_Toc87278891[*Figure 11‑24: Affordability calculation decision logic* link:#_Toc87278891[186]]

link:#_Toc87278892[*Figure 11‑25: Credit contingency factor table decision logic* link:#_Toc87278892[186]]

link:#_Toc87278893[*Figure 11‑26: Required monthly installment decision logic* link:#_Toc87278893[187]]

link:#_Toc87278894[*Figure 11‑27: Installment calculation decision logic* link:#_Toc87278894[187]]

link:#_Toc87278895[*Figure 11‑28: Financial.PMT decision logic* link:#_Toc87278895[188]]

link:#_Toc87278896[*Figure 11‑29: Applicant data input data sample* link:#_Toc87278896[188]]

link:#_Toc87278897[*Figure 11‑30: Requested Product input data sample* link:#_Toc87278897[189]]

link:#_Toc87278898[*Figure 11‑31: Bureau Data input data sample* link:#_Toc87278898[189]]

link:#_Toc87278899[*Figure 11‑32: Output of the Bureau Strategy Decision Service* link:#_Toc87278899[189]]

link:#_Toc87278900[*Figure 11‑33: Output of the Routing decision Service* link:#_Toc87278900[189]]

link:#_Toc87278901[*Figure 11‑34: DRD for Recommended Loan Products* link:#_Toc87278901[190]]

link:#_Toc87278902[*Figure 11‑35: Type tProperty (non-normative representation)* link:#_Toc87278902[191]]

link:#_Toc87278903[*Figure 11‑36: Type tProperty (XML representation)* link:#_Toc87278903[191]]

link:#_Toc87278904[*Figure 11‑37: Type tBorrower* link:#_Toc87278904[192]]

link:#_Toc87278905[*Figure 11‑38: Type tLenderRatings&#44; a collection of tLenderRating* link:#_Toc87278905[192]]

link:#_Toc87278906[*Figure 11‑39: Loan Products* link:#_Toc87278906[193]]

link:#_Toc87278907[*Figure 11‑40: Type tLoanProducts&#44; a collection of tLoanProduct* link:#_Toc87278907[193]]

link:#_Toc87278908[*Figure 11‑41: DRD of imported Loan Info Service* link:#_Toc87278908[194]]

link:#_Toc87278909[*Figure 11‑42: Type tLoanInfoTable&#44; a collection of tLoanInfoRow* link:#_Toc87278909[194]]

link:#_Toc87278910[*Figure 11‑43: Loan Data* link:#_Toc87278910[195]]

link:#_Toc87278911[*Figure 11‑44: BKM Rate Adjustment* link:#_Toc87278911[197]]

link:#_Toc87278912[*Figure 11‑45: BKM payment* link:#_Toc87278912[198]]

link:#_Toc87278913[*Figure 11‑46: Loan Info* link:#_Toc87278913[199]]

link:#_Toc87278914[*Figure 11‑47: Loan Info Table* link:#_Toc87278914[200]]

link:#_Toc87278915[*Figure 11‑48: Min Credit Score* link:#_Toc87278915[201]]

link:#_Toc87278916[*Figure 11‑49: Eligibility Parameters* link:#_Toc87278916[202]]

link:#_Toc87278917[*Figure 11‑50: Eligibility (top)* link:#_Toc87278917[203]]

link:#_Toc87278918[*Figure 11‑51: Eligibility (bottom)* link:#_Toc87278918[204]]

link:#_Toc87278919[*Figure 11‑52: Eligibility Table* link:#_Toc87278919[204]]

link:#_Toc87278920[*Figure 11‑53: Recommended Loan Products* link:#_Toc87278920[205]]

link:#_Toc87278921[*Figure 11‑54: Format Row* link:#_Toc87278921[206]]

link:#_Toc87278922[*Figure 11‑55: Test Case output of Recommended Loan Products* link:#_Toc87278922[207]]

link:#_Toc87278923[*Figure 11‑56: Test Case Input Data (partial)* link:#_Toc87278923[208]]

link:#_Toc87278924[*Figure 13‑1: DMNDI* link:#_Toc87278924[212]]

link:#_Toc87278925[*Figure 13‑2: DMNDiagram* link:#_Toc87278925[213]]

link:#_Toc87278926[*Figure 13‑3: DMNDiagramElement* link:#_Toc87278926[214]]

link:#_Toc87278927[*Figure 13‑4: DMNShape* link:#_Toc87278927[215]]

link:#_Toc87278928[*Figure 13‑5: DMNEdge* link:#_Toc87278928[216]]

link:#_Toc87278929[*Figure 13‑6: DMNLabel* link:#_Toc87278929[217]]

link:#_Toc87278930[*Figure 13‑7: DMNStyle* link:#_Toc87278930[218]]

Table of Tables

link:#_Toc87278931[*Table 1: DRD components* link:#_Toc87278931[21]]

link:#_Toc87278932[*Table 2: Requirements connection rules* link:#_Toc87278932[25]]

link:#_Toc87278933[*Table 3:* DMNElement *attributes and model associations* link:#_Toc87278933[30]]

link:#_Toc87278934[*Table 4:* NamedElement *attributes and model associations* link:#_Toc87278934[31]]

link:#_Toc87278935[*Table 5: Definitions attributes and model associations* link:#_Toc87278935[33]]

link:#_Toc87278936[*Table 6: Import attributes and model associations* link:#_Toc87278936[34]]

link:#_Toc87278937[*Table 7: ElementCollection attributes and model associations* link:#_Toc87278937[35]]

link:#_Toc87278938[*Table 8: Association attributes and model associations* link:#_Toc87278938[36]]

link:#_Toc87278939[*Table 9: Group model associations* link:#_Toc87278939[36]]

link:#_Toc87278940[*Table 10: TextAnnotation attributes* link:#_Toc87278940[36]]

link:#_Toc87278941[*Table 11: Decision attributes and model associations* link:#_Toc87278941[38]]

link:#_Toc87278942[*Table 12: BusinessContextElement attributes and model associations* link:#_Toc87278942[40]]

link:#_Toc87278943[*Table 13: PerformanceIndicator attributes and model associations* link:#_Toc87278943[40]]

link:#_Toc87278944[*Table 14: OrganisationalUnit attributes and model associations* link:#_Toc87278944[40]]

link:#_Toc87278945[*Table 15: Invocable attributes and model associations* link:#_Toc87278945[41]]

link:#_Toc87278946[*Table 16: BusinessKnowledgeModel attributes and model associations* link:#_Toc87278946[41]]

link:#_Toc87278947[*Table 17: DecisionService attributes and model associations* link:#_Toc87278947[43]]

link:#_Toc87278948[*Table 18: InputData attributes and model associations* link:#_Toc87278948[43]]

link:#_Toc87278949[*Table 19: KnowledgeSource attributes and model associations* link:#_Toc87278949[44]]

link:#_Toc87278950[*Table 20: InformationRequirement attributes and model associations* link:#_Toc87278950[45]]

link:#_Toc87278951[*Table 21: KnowledgeRequirement attributes and model associations* link:#_Toc87278951[46]]

link:#_Toc87278952[*Table 22: AuthorityRequirement attributes and model associations* link:#_Toc87278952[46]]

link:#_Toc87278953[*Table 23: ExtensionElements attributes and model associations* link:#_Toc87278953[47]]

link:#_Toc87278954[*Table 24: ExtensionAttribute attributes and model associations* link:#_Toc87278954[48]]

link:#_Toc87278955[*Table 25: UnaryTests attributes and model associations* link:#_Toc87278955[55]]

link:#_Toc87278956[*Table 26: ItemDefinition attributes and model associations* link:#_Toc87278956[57]]

link:#_Toc87278957[*Table 27: FunctionItem attributes and model associations* link:#_Toc87278957[57]]

link:#_Toc87278958[*Table 28: InformationItem attributes and model associations* link:#_Toc87278958[58]]

link:#_Toc87278959[*Table 29: LiteralExpression attributes and model associations* link:#_Toc87278959[59]]

link:#_Toc87278960[*Table 30: Invocation attributes and model associations* link:#_Toc87278960[60]]

link:#_Toc87278961[*Table 31: Binding attributes and model associations* link:#_Toc87278961[60]]

link:#_Toc87278962[*Table 32: DecisionTable attributes and model associations* link:#_Toc87278962[74]]

link:#_Toc87278963[*Table 33: InputClause attributes and model associations* link:#_Toc87278963[75]]

link:#_Toc87278964[*Table 34: OutputClause attributes and model associations* link:#_Toc87278964[75]]

link:#_Toc87278965[*Table 35: RuleAnnotationClause attributes and model associations* link:#_Toc87278965[75]]

link:#_Toc87278966[*Table 36: DecisionRule attributes and model associations* link:#_Toc87278966[76]]

link:#_Toc87278967[*Table 37: RuleAnnotation attributes and model associations* link:#_Toc87278967[76]]

link:#_Toc87278968[*Table 38: Examples of decision tables* link:#_Toc87278968[77]]

link:#_Toc87278969[*Table 39: FEEL range comparisons* link:#_Toc87278969[98]]

link:#_Toc87278970[*Table 40: FEEL numbers and calculations* link:#_Toc87278970[99]]

link:#_Toc87278971[*Table 41: EBNF notation* link:#_Toc87278971[100]]

link:#_Toc87278972[*Table 42: Examples of range properties values* link:#_Toc87278972[110]]

link:#_Toc87278973[*Table 43: Examples of types of domain elements* link:#_Toc87278973[110]]

link:#_Toc87278974[*Table 44: Examples of equivalence and conformance relations* link:#_Toc87278974[114]]

link:#_Toc87278975[*Table 45: Examples of singleton list conversions* link:#_Toc87278975[116]]

link:#_Toc87278976[*Table 46: Semantics of decision table* link:#_Toc87278976[117]]

link:#_Toc87278977[*Table 47: Mapping between FEEL and other domains* link:#_Toc87278977[119]]

link:#_Toc87278978[*Table 48: Semantics of FEEL functions* link:#_Toc87278978[123]]

link:#_Toc87278979[*Table 49: Semantics of other FEEL expressions* link:#_Toc87278979[123]]

link:#_Toc87278980[*Table 50: Semantics of conjunction and disjunction* link:#_Toc87278980[123]]

link:#_Toc87278981[*Table 51: Semantics of negation* link:#_Toc87278981[124]]

link:#_Toc87278982[*Table 52: General semantics of equality and inequality* link:#_Toc87278982[124]]

link:#_Toc87278983[*Table 53: Specific semantics of equality* link:#_Toc87278983[124]]

link:#_Toc87278984[*Table 54: Specific semantics of inequality* link:#_Toc87278984[125]]

link:#_Toc87278985[*Table 55: Semantics of decision table syntax* link:#_Toc87278985[126]]

link:#_Toc87278986[*Table 56: General semantics of addition and subtraction* link:#_Toc87278986[127]]

link:#_Toc87278987[*Table 57: Specific semantics of addition and subtraction* link:#_Toc87278987[127]]

link:#_Toc87278988[*Table 58: General semantics of multiplication and division* link:#_Toc87278988[129]]

link:#_Toc87278989[*Table 59: Specific semantics of multiplication and division* link:#_Toc87278989[129]]

link:#_Toc87278990[*Table 60: Semantics of exponentiation* link:#_Toc87278990[130]]

link:#_Toc87278991[*Table 61: Semantics of type-checking* link:#_Toc87278991[130]]

link:#_Toc87278992[*Table 62: Semantics of negative numbers* link:#_Toc87278992[131]]

link:#_Toc87278993[*Table 63: Semantics of invocation* link:#_Toc87278993[131]]

link:#_Toc87278994[*Table 64: General semantics of properties* link:#_Toc87278994[131]]

link:#_Toc87278995[*Table 65: List of properties per type* link:#_Toc87278995[132]]

link:#_Toc87278996[*Table 66: Specific semantics of date&#44; time and duration properties* link:#_Toc87278996[132]]

link:#_Toc87278997[*Table 67: Specific semantics of range properties* link:#_Toc87278997[133]]

link:#_Toc87278998[*Table 68: Semantics of lists* link:#_Toc87278998[134]]

link:#_Toc87278999[*Table 69: Semantics of contexts* link:#_Toc87278999[134]]

link:#_Toc87279000[*Table 70: Semantics of XML elements* link:#_Toc87279000[135]]

link:#_Toc87279001[*Table 71: Semantics of XML values* link:#_Toc87279001[135]]

link:#_Toc87279002[*Table 72: Semantics of conversion functions* link:#_Toc87279002[138]]

link:#_Toc87279003[*Table 73: Semantics of Boolean functions* link:#_Toc87279003[139]]

link:#_Toc87279004[*Table 74: Semantics of string functions* link:#_Toc87279004[139]]

link:#_Toc87279005[*Table 75: Semantics of list functions* link:#_Toc87279005[141]]

link:#_Toc87279006[*Table 76: Semantics of numeric functions* link:#_Toc87279006[143]]

link:#_Toc87279007[*Table 77: Semantics of date and time functions* link:#_Toc87279007[145]]

link:#_Toc87279008[*Table 78: Semantics of range functions* link:#_Toc87279008[146]]

link:#_Toc87279009[*Table 79: Temporal built-in functions* link:#_Toc87279009[152]]

link:#_Toc87279010[*Table 80: Semantics of sort functions* link:#_Toc87279010[153]]

link:#_Toc87279011[*Table 81: Semantics of Context functions* link:#_Toc87279011[154]]

link:#_Toc87279012[*Table 82: Miscellaneous functions* link:#_Toc87279012[156]]

link:#_Toc87279013[*Table 83: Context attributes and model association* link:#_Toc87279013[158]]

link:#_Toc87279014[*Table 84: ContextEntry attributes and model associations* link:#_Toc87279014[158]]

link:#_Toc87279015[*Table 85: FunctionDefinition attributes and model associations* link:#_Toc87279015[158]]

link:#_Toc87279016[*Table 86: List attributes and model associations* link:#_Toc87279016[159]]

link:#_Toc87279017[*Table 87: Relation attributes and model associations* link:#_Toc87279017[159]]

link:#_Toc87279018[*Table 88: Conditional attributes and model associations* link:#_Toc87279018[159]]

link:#_Toc87279019[*Table 89: ChildExpression attributes and model associations* link:#_Toc87279019[160]]

link:#_Toc87279020[*Table 90: Filter attributes and model associations* link:#_Toc87279020[160]]

link:#_Toc87279021[*Table 91: Iterator attributes and model associations* link:#_Toc87279021[160]]

link:#_Toc87279022[*Table 92: For attributes and model associations* link:#_Toc87279022[161]]

link:#_Toc87279023[*Table 93: Quantified attributes and model associations* link:#_Toc87279023[161]]

link:#_Toc87279024[*Table 94: DMNDI attributes* link:#_Toc87279024[212]]

link:#_Toc87279025[*Table 95: DMNDiagram attributes* link:#_Toc87279025[214]]

link:#_Toc87279026[*Table 96: DMNDiagramElement attributes* link:#_Toc87279026[215]]

link:#_Toc87279027[*Table 97: DMNShape attributes* link:#_Toc87279027[216]]

link:#_Toc87279028[*Table 98: DMNEdge attributes* link:#_Toc87279028[217]]

link:#_Toc87279029[*Table 99: DMNLabel attributes* link:#_Toc87279029[217]]

link:#_Toc87279030[*Table 100: DMNStyle attributes* link:#_Toc87279030[219]]

link:#_Toc87279031[*Table 101: Depiction Resolution for Decision* link:#_Toc87279031[220]]

link:#_Toc87279032[*Table 102: Depiction Resolution for Business Knowledge Model* link:#_Toc87279032[220]]

link:#_Toc87279033[*Table 103: Depiction Resolution for Input Data* link:#_Toc87279033[221]]

link:#_Toc87279034[*Table 104: Depiction Resolution for Knowledge Source* link:#_Toc87279034[221]]

link:#_Toc87279035[*Table 105: Depiction Resolution of Artifacts* link:#_Toc87279035[221]]

link:#_Toc87279036[*Table 106: Depiction Resolution of Decision Service* link:#_Toc87279036[222]]

link:#_Toc87279037[*Table 107: Depiction Resolution of Information Requirement* link:#_Toc87279037[222]]

link:#_Toc87279038[*Table 108: Depiction Resolution of Knowledge Requirement* link:#_Toc87279038[222]]

link:#_Toc87279039[*Table 109: Depiction Resolution of Authority Requirement* link:#_Toc87279039[222]]

link:#_Toc87279040[*Table 110: Depiction Resolution of Association* link:#_Toc87279040[223]]

link:#_Toc87279041[*Table 111: BPMN tasks relevant to DMN* link:#_Toc87279041[229]]

*OMG*

Founded in 1989, the Object Management Group, Inc. (OMG) is an open membership, not-for-profit computer industry standards consortium that produces and maintains computer industry specifications for interoperable, portable, and reusable enterprise applications in distributed, heterogeneous environments. Membership includes Information Technology vendors, end users, government agencies, and academia.

OMG member companies write, adopt, and maintain its specifications following a mature, open process. OMG’s specifications implement the Model Driven Architecture® (MDA®), maximizing ROI through a full-lifecycle approach to enterprise integration that covers multiple operating systems, programming languages, middleware and networking infrastructures, and software development environments. OMG’s specifications include: UML® (Unified Modeling LanguageTM); CORBA® (Common Object Request Broker Architecture); CWMTM (Common Warehouse Metamodel); and industry-specific standards for dozens of vertical markets.

More information on the OMG is available at https://www.omg.org/[[.underline]#https://www.omg.org/.#]

*OMG Specifications*

As noted, OMG specifications address middleware, modeling and vertical domain frameworks. All OMG Specifications are available from the OMG website at:

https://www.omg.org/spec[_[.underline]#https://www.omg.org/spec#_]

All of OMG’s formal specifications may be downloaded without charge from our website. (Products implementing OMG specifications are available from individual suppliers.) Copies of specifications, available in PostScript and PDF format, may be obtained from the Specifications Catalog cited above or by contacting the Object Management Group, Inc. at:

OMG Headquarters +
9C Medway Road, PMB 274 +
Milford, MA 01757

Tel: +1-781-444-0404 Fax: +1-781-444-0320 +
Email: __[.underline]#pubs@omg.org# +
__Certain OMG specifications are also available as ISO standards. +
Please consult http://www.iso.org/[[.underline]#http://www.iso.org#]

*Issues*

All OMG specifications are subject to continuous review and improvement. As part of this process we encourage readers to report any ambiguities, inconsistencies, or inaccuracies they may find by completing the Issue Reporting Form listed on the main web page https://www.omg.org/[https://www.omg.org], under Documents, Report a Bug/Issue.

== Scope 

The primary goal of *DMN* is to provide a common notation that is readily understandable by all business users, from the business analysts needing to create initial decision requirements and then more detailed decision models, to the technical developers responsible for automating the decisions in processes, and finally, to the business people who will manage and monitor those decisions. *DMN* creates a standardized bridge for the gap between the business decision design and decision implementation. *DMN* notation is designed to be usable alongside the standard *BPMN* business process notation.

Another goal is to ensure that decision models are interchangeable across organizations via an XML representation.

The authors have brought forth expertise and experience from the existing decision modeling community and have sought to consolidate the common ideas from these divergent notations into a single standard notation.

== Conformance 

=== Conformance levels

Software may claim compliance or conformance with *DMN* *1.4* if and only if the software fully matches the applicable compliance points as stated in the specification. Software developed only partially matching the applicable compliance points may claim that the software was based on this specification, but may not claim compliance or conformance with this specification.

The specification defines three levels of conformance, namely *Conformance Level 1*, *Conformance Level 2* and *Conformance Level 3*.

An implementation claiming conformance to Conformance Level 1 is not required to support Conformance Level 2 or Conformance Level 3. An implementation claiming conformance to Conformance Level 2 is not required to support Conformance Level 3.

An implementation claiming conformance to *Conformance Level 1* SHALL comply with all of the specifications set forth in clauses 6 (Decision Requirements), 7 (Decision Logic) and 8 (Decision Table) of this document. An implementation claiming conformance to Conformance Level 1 is never required to interpret expressions (modeled as an Expression elements) in decision models. However, to the extent that an implementation claiming conformance to Conformance Level 1 provides an interpretation to an expression, that interpretation SHALL be consistent with the semantics of expressions as specified in clause 7.

An implementation claiming conformance to *Conformance Level 2* SHALL comply with all of the specifications set forth in clauses 6 (Decision Requirements), 7 (Decision Logic) and 8 (Decision Table) of this document. In addition, it is required to interpret expressions in the simple expression language (S-FEEL) specified in clause 9.

An implementation claiming conformance to *Conformance Level 3* SHALL comply with all of the specifications set forth in clauses 6 (Decision Requirements), 7 (Decision Logic), 8 (Decision Table) and 10 (Expression language) of this document. Notice that the simple expression language that is specified in clause 9 is a subset of FEEL, and that, therefore, an implementation claiming conformance to Conformance Level 3 can also claim conformance to Conformance Level 2 (and to Conformance Level 1).

In addition, an implementation claiming conformance to any of the three *DMN* *1.4* conformance levels SHALL comply with all of the requirements set forth in Clause 2.2.

=== General conformance requirement

==== Visual appearance

A key element of *DMN* is the choice of shapes and icons used for the graphical elements identified in this specification. The intent is to create a standard visual language that all decision modelers will recognize and understand. An implementation that creates and displays decision model diagrams SHALL use the graphical elements, shapes, and markers illustrated in this specification.

There is flexibility in the size, color, line style, and text positions of the defined graphical elements, except where otherwise specified.

The following extensions to a *DMN* Diagram are permitted:

* {blank}
* {blank}
* {blank}
* {blank}

==== New markers or indicators MAY be added to the specified graphical elements. These markers or indicators could be used to highlight a specific attribute of a DMN element or to represent a new subtype of the corresponding concept. A new shape representing a new kind of artifact MAY be added to a Diagram, but the new shape SHALL NOT conflict with the shape specified for any other DMN element or marker.Graphical elements MAY be colored, and the coloring may have specified semantics that extend the information conveyed by the element as specified in this standard.The line style of a graphical element MAY be changed, but that change SHALL NOT conflict with any other line style required by this specification.Decision semantics

This specification defines many semantic concepts used in defining decisions and associates them with graphical elements, markers, and connections.

To the extent that an implementation provides an interpretation of some *DMN* diagram element as a semantic specification of the associated concept, the interpretation SHALL be consistent with the semantic interpretation herein specified.

==== Attributes and model associations

This specification defines a number of attributes and properties of the semantic elements represented by the graphical elements, markers, and connections. Some attributes are specified as mandatory, but have no representation or only optional representation. And some attributes are specified as optional.

For every attribute or property that is specified as mandatory, a conforming implementation SHALL provide some mechanism by which values of that attribute or property can be created and displayed. This mechanism SHALL permit the user to create or view these values for each *DMN* element specified to have that attribute or property.

Where a graphical representation for that attribute or property is specified as required, that graphical representation SHALL be used. Where a graphical representation for that attribute or property is specified as optional, the implementation MAY use either a graphical representation or some other mechanism.

If a graphical representation is used, it SHALL be the representation specified. Where no graphical representation for that attribute or property is specified, the implementation MAY use either a graphical representation or some other mechanism. If a graphical representation is used, it SHALL NOT conflict with the specified graphical representation of any other *DMN* element.

== References

=== Normative

BMM

* {blank}

_Business Motivation Model (BMM), Version 1.2_, OMG Document number: formal/2014-05-01, May 2014 +
https://www.omg.org/spec/BMM/1.2 +
BPMN 2.0

* {blank}

_Business Process Model and Notation, version 2.0_, OMG Document Number: formal/2011-01-03, January 2011 +
https://www.omg.org/spec/BPMN/2.0 +
CQL

* {blank}

_Clinical Quality Language_, V1.4, HL7 +
https://cql.hl7.org/09-b-cqlreference.html#interval-operators-3 +
IEEE 754

* {blank}

_IEEE 754-2008, IEEE Standard for Floating-Point Arithmetic_, International Electrical and Electronics +
Engineering Society, December, 2008 +
http://www.techstreet.com/ieee/searches/5835853 +
ISO 8601

* {blank}

_ISO 8601:2004, Data elements and interchange formats -- Information interchange -- Representation of dates +
and times_, International Organization for Standardization, 2004 +
http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=40874 +
ISO EBNF

* {blank}

_ISO/IEC 14977:1996, Information technology -- Syntactic metalanguage -- Extended BNF, International +
Organization for Standardization_, 1996 +
http://standards.iso.org/ittf/PubliclyAvailableStandards/s026153_ISO_IEC_14977_1996(E).zip +
Java

* {blank}

_The Java Language Specification, Java SE 7 Edition_, Oracle Corporation, February 2013 +
http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf +
PMML

* {blank}

_Predictive Model Markup Language (PMML)_, Data Mining Group, May, 2014 +
http://www.dmg.org/v4-2-1/GeneralStructure.html

RFC 3986

* {blank}

_RFC 3986: Uniform Resource Identifier (URI): Generic Syntax_. Berners-Lee, T., Fielding, R., and Masinter, L, +
editors. Internet Engineering Task Force, 2005. +
http://www.ietf.org/rfc/rfc3986.txtUML

* {blank}

_Unified Modeling Language (UML), v2.4.1_, OMG Document Number formal/2011-08-05, August 2011 +
https://www.omg.org/spec/UML/2.4.1 +
XBASE

* {blank}

_XML Base (Second Edition)_. Jonathan Marsh and Richard Tobin, editors. World Wide Web Consortium, 2009. +
http://www.w3.org/TR/xmlbase/ +
XML

* {blank}

_Extensible Markup Language (XML) 1.0 (Fifth Edition)_, W3C Recommendation 26 November 2008 +
http://www.w3.org/TR/xml/ +
XML Schema

* {blank}

_XML Schema Part 2: Datatypes Second Edition_, W3C Recommendation 28 October 2004 +
http://www.w3.org/TR/xmlschema-2/ +
XPath Data Model

* {blank}

_XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)_, W3C Recommendation 14 December 2010 +
http://www.w3.org/TR/xpath-datamodel/ +
XQuery and XPath Functions and Operators

* {blank}

=== _XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)_, W3C Recommendation 14 +
December 2010 +
http://www.w3.org/TR/xpath-functions/XQueryNon-normative

JSON

* {blank}

_ECMA-404 The JSON Data Interchange Standard_, European Computer Manufacturers Association, October, 2013 +
http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf +
PRR

* {blank}

_Production Rule Representation (PRR), Version 1.0_, December 2009, OMG document number formal/2009-12 01 +
https://www.omg.org/spec/PRR/1.0/

RIF

* {blank}

_RIF production rule dialect_, Ch. de Sainte Marie et al. (Eds.) , W3C Recommendation, 22 June 2010. +
http://www.w3.org/TR/rif-prd/

SBVR

* {blank}

_Semantics of Business Vocabulary and Business Rules (SBVR)_, V1.2, OMG document number formal/2013-11- +
04, November 2013 +
https://www.omg.org/spec/SBVR/1.2/ +
SQL

* {blank}

_ISO/IEC 9075-11:2011, Information technology -- Database languages -- SQL -- Part 11: Information and +
Definition Schemas (SQL/Schemata)_, International Organization for Standardization, 2011 +
http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=5368 +
XPath

* {blank}

_XML Path Language (XPath) Version 1.0_, W3C Recommendation 16 November 1999 +
http://www.w3.org/TR/xpath

== Additional Information

=== Acknowledgements

The following companies submitted version 1.0 of this specification:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

Decision Management SolutionsEscape VelocityFICOInternational Business MachinesOracleThe following companies supported this specification:

* {blank}
* {blank}
* {blank}
* {blank}

KU LeuvenKnowledge Partners InternationalModel SystemsTIBCOThe following persons were members of the core team that contributed to the content specification: Martin Chapman, Bob Daniel, Alan Fish, Larry Goldberg, John Hall, Barbara von Halle, Gary Hallmark, Dave Ings, Christian de Sainte Marie, James Taylor, Jan Vanthienen, Paul Vincent. In addition, the following persons contributed valuable ideas and feedback that improved the content and the quality of this specification: Bas Janssen, Robert Lario, Pete Rivett.

Version 1.1 was developed by the following persons and companies: Elie Abi-Lahoud, University College Cork; Justin Brunt, TIBCO; Alan Fish, FICO; John Hall, Rule ML Initiative; Denis Gagne, Trisotech; Gary Hallmark, Oracle; Elisa Kendall, Thematix Partners LLC; Manfred Koethe, 88solutions; Falko Menge, Camunda Services GmbH; Zbigniew Misiak, BOC Information Technologies Consulting; Sjir Nijssen, PNA Group; Mihail Popov, MITRE; Pete Rivett, Adaptive; Bruce Silver, Bruce Silver Associates; Bastian Steinert, Signavio GmbH; Tim Stephenson, Omny Link; James Taylor, Decision Management Solutions; Jan Vanthienen, K.U. Leuven; Paul Vincent, Knowledge Partners, Inc.

Version 1.2 was developed by the following persons and companies: Alan Fish, FICO; Denis Gagne, Trisotech; Gary Hallmark, Oracle; Elisa Kendall, Thematix Partners LLC; Manfred Koethe, 88solutions; Falko Menge, Camunda Services GmbH; Zbigniew Misiak, BOC Products & Services AG; Sjir Nijssen, PNA Group; Octavian Patrascoiu, Goldman Sachs; Bruce Silver, Bruce Silver Associates; Gil Ronen, Sapiens DECISION; Caroline Scharf, Tom Sawyer Software; Bastian Steinert, Signavio GmbH; James Taylor, Decision Management Solutions; Edson Tirelli, Red Hat; Jan Vanthienen, K.U. Leuven; Stephen White, Department of Veterans Affairs.

Version 1.3 was developed by the following persons and companies: Alan Fish, FICO; Denis Gagne, Trisotech; Gary Hallmark, Oracle; Uwe Kaufmann, GfSE e.V.; Elisa Kendall, Thematix Partners LLC; Manfred Koethe, 88solutions; Robert Lario, Department of Veterans Affairs; Falko Menge, Camunda Services GmbH; Zbigniew Misiak, BOC Products & Services AG; Matteo Mortari, Red Hat; Sjir Nijssen, PNA Group; Octavian Patrascoiu, Goldman Sachs; Bruce Silver, Bruce Silver Associates; Gil Segal, Sapiens Decision NA; Bastian Steinert, Signavio GmbH; James Taylor, Decision Management Solutions; Edson Tirelli, Red Hat; Jan Vanthienen, K.U. Leuven; Stephen White, Department of Veterans Affairs.

=== IPR and Patents

The submitters contributed this work to OMG on a RF on RAND basis.

=== Guide to the Specification

Clause 1 summarizes the goals of the specification.

Clause 2 defines three levels of conformance with the specification: Conformance Level 1, Conformance Level 2 and Conformance Level 3.

Clause 3 lists normative references.

Clause 4 provides additional information useful in understanding the background to and structure of the specification.

Clause 5 discusses the scope and uses of *DMN* and introduces the principal concepts, including the two levels of *DMN*: the decision requirements level and the decision logic level.

Clause 6 defines the decision requirements level of *DMN*: the Decision Requirements Graph (DRG) and its notation as a Decision Requirements Diagram (DRD).

Clause 7 introduces the principles by which decision logic may be associated with elements in a DRG: i.e., how the decision requirements level and decision logic level are related to each other.

Clauses 8, 9 and 10 then define the decision logic level of *DMN*:

* {blank}
* {blank}
* {blank}

Clause 8 defines the notation and syntax of Decision Tables in **DMN**Clause 9 defines S-FEEL: a subset of FEEL to support decision tablesClause 10 defines the full syntax and semantics of FEEL: the default expression language used for the Decision Logic level of *DMN*.Clause 11 provides examples of *DMN* used to model human and automated decision-making.

Clause 12 addresses exchange formats and provides references to machine-readable files (XSD and XMI). The Annexes provide non-normative background information:

* {blank}
* {blank}

Annex A. discusses the relationship between *DMN* and **BPMN**Annex B. provides a glossary of terms.

== Introduction to DMN

=== Context

The purpose of *DMN* is to provide the constructs that are needed to model decisions, so that organizational decision- making can be readily depicted in diagrams, accurately defined by business analysts, and (optionally) automated.

Decision-making is addressed from two different perspectives by existing modeling standards:

* {blank}
* {blank}

Business process models (e.g. *BPMN*) can describe the coordination of decision-making within business processes by defining specific tasks or activities within which the decision-making takes place.Decision logic (e.g., PRR, PMML) can define the specific logic used to make individual decisions, for example as business rules, decision tables, or executable analytic models.However, a number of authors (including members of the submission team) have observed that decision-making has an internal structure which is not conveniently captured in either of these modeling perspectives. Our intention is that *DMN* will provide a third perspective – the Decision Requirements Diagram – forming a bridge between business process models and decision logic models:

* {blank}
* {blank}
* {blank}

Business process models will define tasks within business processes where decision-making is required to occur.Decision Requirements Diagrams will define the decisions to be made in those tasks, their interrelationships, and their requirements for decision logic.Decision logic will define the required decisions in sufficient detail to allow validation and/or automation.Taken together, Decision Requirements Diagrams and decision logic can provide a complete decision model which complements a business process model by specifying in detail the decision-making carried out in process tasks. The relationships between these three aspects of modeling are shown in *Figure _5_‑_1_*.

image:extracted-media/media/image2.png[image,width=622,height=517]

[#_Toc87278783 .anchor]##*Figure 5‑1: Aspects of modeling*

The resulting connected set of models will allow detailed modeling of the role of business rules and analytic models in business processes, cross-validation of models, top-down process design and automation, and automatic execution of decision-making (e.g., by a business process management system calling a decision service deployed from a business rules management system).

Although *Figure _5_‑_1_* shows a linkage between a business process model and a decision model for the purposes of explaining the relationship between *DMN* and other standards, it must be stressed that *DMN* is not dependent on *BPMN*, and its two levels – decision requirements and decision logic – may be used independently or in conjunction to model a domain of decision-making without any reference to business processes (see *Figure _5_‑_2_*).

*DMN* will provide constructs spanning both decision requirements and decision logic modeling. For decision requirements modeling, it defines the concept of a Decision Requirements Graph (DRG) comprising a set of elements and their connection rules, and a corresponding notation: The Decision Requirements Diagram (DRD). For decision logic modeling it provides a language called FEEL for defining and assembling decision tables, calculations, if/then/else logic, simple data structures, and externally defined logic from Java and PMML into executable expressions with formally defined semantics. It also provides a notation for decision logic (“boxed expressions”) allowing components of the decision logic level to be drawn graphically and associated with elements of a Decision Requirements Diagram. The relationship between these constructs is shown in *Figure _5_‑_2_*.

image:extracted-media/media/image3.wmf[image,width=528,height=508]

[#_Toc87278784 .anchor]##*Figure 5‑2: DMN Constructs*

=== Scope and uses of DMN

Decision modeling is carried out by business analysts in order to understand and define the decisions used in a business or organization. Such decisions are typically operational decisions made in day-to-day business processes, rather than the strategic decision-making for which fewer rules and representations exist.

Three uses of *DMN* can be discerned in this context:

[arabic]
. {blank}
. {blank}
. {blank}

==== For modeling human decision-making.For modeling the requirements for automated decision-making.For implementing automated decision-making.Modeling human decision-making

*DMN* may be used to model the decisions made by personnel within an organization. Human decision-making can be broken down into a network of interdependent constituent decisions, and modeled using a DRD. The decisions in the DRD would probably be described at quite a high level, using natural language rather than decision logic.

Knowledge sources may be defined to model governance of decision-making by people (e.g., a manager), regulatory bodies (e.g., an ombudsman), documents (e.g., a policy booklet) or bodies of legislation (e.g., a government statute). These knowledge sources may be linked together, for example to show that a decision is governed (a) by a set of regulations defined by a regulatory body, and (b) by a company policy document maintained by a manager.

Business knowledge models may be used to represent specific areas of business knowledge drawn upon when making decisions. This will allow *DMN* to be used as a tool for formal definition of requirements for knowledge management. Business knowledge models may be linked together to show the interdependencies between areas of knowledge (in a manner similar to that used in the existing technique of Knowledge Structure Mapping). Knowledge sources may be linked to the business knowledge models to indicate how the business knowledge is governed or maintained, for example to show that a set of business policies (the business knowledge model) is defined in a company policy document (the knowledge source).

In some cases, it may be possible to define specific rules or algorithms for the decision-making. These may be modeled using decision logic (e.g., business rules or decision tables) to specify business knowledge models in the DRD, either descriptively (to record how decisions are currently made, or how they were made during a particular period of observation) or prescriptively (to define how decisions should be made, or will be made in the future).

Decision-making modeled in *DMN* may be mapped to tasks or activities within a business process modeled using *BPMN*. At a high level, a collaborative decision-making task may be mapped to a subset of decisions in a DRD representing the overall decision-making behavior of a group or department. At a more detailed level, it is possible to model the interdependencies between decisions made by a number of individuals or groups using *BPMN* collaborations: each participant in the decision-making is represented by a separate pool in the collaboration and a separate DRD in the decision model. Decisions in those DRDs are then mapped to tasks in the pools, and input data in the DRDs are mapped to the content of messages passing between the pools.

The combined use of *BPMN* and *DMN* thus provides a graphical language for describing multiple levels of human decision-making within an organization, from activities in business processes down to a detailed definition of decision logic. Within this context *DMN* models will describe collaborative organizational decisions, their governance, and the business knowledge required for them.

==== Modeling requirements for automated decision-making

The use of *DMN* for modeling the requirements for automated decision-making is similar to its use in modeling human decision-making, except that it is entirely prescriptive, rather than descriptive, and there is more emphasis on the detailed decision logic.

For full automation of decisions, the decision logic must be complete, i.e., capable of providing a decision result for any possible set of values of the input data.

However, partial automation is more common, where some decision-making remains the preserve of personnel. Interactions between human and automated decision-making may be modeled using collaborations as above, with separate pools for human and automated decision-makers, or more simply by allocating the decision-making to separate tasks in the business process model, with user tasks for human decision-making and business rule tasks for automated decision-making. So, for example, an automated business rules task might decide to refer some cases to a human reviewer; the decision logic for the automated task needs to be specified in full but the reviewer’s decision-making could be left unspecified.

Once decisions in a DRD are mapped to tasks in a *BPMN* business process flow, it is possible to validate across the two levels of models. For example, it is possible to verify that all input data in the DRDs are provided by previous tasks in the business process, and that the business process uses the results of decisions only in subsequent tasks or gateways. *DMN* models the relationships between Decisions and Business Processes so that the Decisions that must be made for a Business Process to complete can be identified and so that the specific decision-making tasks that perform or execute a Decision can be specified. No formal mapping of *DMN* ItemDefinition or *DMN* InputData to *BPMN* DataObject is proposed but an implementation could include such a check in a situation where such a mapping could be determined.

Together, *BPMN* and *DMN* therefore allow specification of the requirements for automated decision-making and its interaction with human decision making within business processes. These requirements may be specified at any level of detail, or at all levels. The three-tier mapping between business process models, DRDs and decision logic will allow the definition of these requirements to be supported by model-based computer-aided design tools.

==== Implementing automated decision-making

If all decisions and business knowledge models are fully specified using decision logic, it becomes possible to execute decision models.

One possible scenario is the use of “decision services” deployed from a Business Rules Management System (BRMS) and called by a Business Process Management System (BPMS). A decision service encapsulates the decision logic supporting a DRD, providing interfaces that correspond to subsets of input data and decisions within the DRD. When called with a set of input data, the decision service will evaluate the specified decisions and return their results. The constraint in *DMN* that all decision logic is free of side-effects means that decision services will comply with SOA principles, simplifying system design. Note that decision services may also be invoked internal to the decision model, a trait that they share with business knowledge models.

The structure of a decision model, as visualized in the DRD, may be used as a basis for planning an implementation project. Specific project tasks may be included to cover the definition of decision logic (e.g., rule discovery using human experts, or creation of analytic models), and the implementation of components of the decision model.

Some decision logic representing the business knowledge encapsulated in decision services needs to be maintained over time by personnel responsible for the decisions, using special “knowledge maintenance interfaces”. *DMN* supports the effective design and implementation of knowledge maintenance interfaces: any business knowledge requiring maintenance should be modeled as business knowledge models in the DRD, and the responsible personnel as knowledge sources. DRDs then provide a specification of the required knowledge maintenance interfaces and their users, and the decision logic specifies the initial configuration of the business knowledge to be maintained.

Other decision logic needs to be refreshed by regular analytic modeling. The representation of business knowledge models as functions in *DMN* makes the use of analytic models in decision services very simple: any analytic model capable of representation as a function may be directly called by or imported into a decision service.

==== Combining applications of modeling

The three contexts described above are not mutually exclusive alternatives; a large process automation project might use *DMN* in all three ways.

First, the decision-making within the existing process might be modeled, to identify the full extent of current decision making and the areas of business knowledge involved. This “as-is” analysis provides the baseline for process improvement.

Next, the process might be redesigned to make the most effective use of both automated and human decision-making, often using collaboration between the two (e.g., using automated referrals to human decision-makers, or decision support systems which advise or constrain the user). Such a redesign involves modeling the requirements for the decision-making to occur in each process task and the roles and responsibilities of individuals or groups in the organization. This model provides a “to-be” specification of the required process and the decision-making it coordinates.

Comparison of the “as-is” and “to-be” models will indicate requirements not just for automation technology, but for change management: changes in the roles and responsibilities of personnel, and training to support new or modified business knowledge.

Finally, the “to-be” model will be implemented as executable system software. Provided the decision logic is fully specified in FEEL and/or other external logic (e.g., externally defined Java methods or PMML models), components of the decision model may be implemented directly as software components.

*DMN* does not prescribe any particular methodology for carrying out the above activities; it only supports the models used for them.

=== Basic concepts

==== Decision requirements level

The word “decision” has two definitions in common use: it may denote the act of choosing among multiple possible options; or it may denote the option that is chosen. In this specification, we adopt the former usage: a *decision* is the act of determining an *output* value (the chosen option), from a number of *input* values, using logic defining how the output is determined from the inputs. This *decision logic* may include one or more *business knowledge models* which encapsulate business know-how in the form of business rules, analytic models, or other formalisms. This basic structure, from which all decision models are built, is shown in *Figure _5_‑_3_*.

image:extracted-media/media/image4.png[image,width=215,height=122]

[#_Toc87278785 .anchor]##*Figure 5‑3: Basic elements of a decision model*

For simplicity and generality, many of the figures in this specification show each decision as having a single associated business knowledge model, but it should be noted that *DMN* does not require this to be the case. The use of business knowledge models to encapsulate decision logic is a matter of style and methodology, and decisions may be modeled with no associated business knowledge models, or with several. Similar to business knowledge models, decision services may also be used to encapsulate decision logic for reuse inside the decision model, but for simplicity such examples will be presented starting in the section describing decision services.

Authorities may be defined for decisions or business knowledge models, which might be (for example) domain experts responsible for defining or maintaining them, or source documents from which business knowledge models are derived, or sets of test cases with which the decisions must be consistent. These are called *knowledge sources* (see *Figure _5_‑_4_*).

image:extracted-media/media/image5.png[image,width=380,height=141]

[#_Toc87278786 .anchor]##*Figure 5‑4: Knowledge sources*

A decision is said to “require” its inputs in order to determine its output. The inputs may be *input data*, or the outputs of other decisions. (In either case they may be data structures, rather than just simple data items.) If the inputs of a decision Decision1 include the output of another decision Decision2, Decision1 “requires” Decision2. Decisions may therefore be connected in a network called a *Decision Requirements Graph (DRG)*, which may be drawn as a *Decision* *Requirements Diagram* (*DRD*). A DRD shows how a set of decisions depend on each other, on input data, and on business knowledge models. A simple example of a DRD with only two decisions is shown in *Figure _5_‑_5_*.

image:extracted-media/media/image6.png[image,width=337,height=168]

[#_Toc87278787 .anchor]##*Figure 5‑5: A simple Decision Requirements Diagram (DRD)*

A decision may require multiple business knowledge models, and a business knowledge model may require multiple other business knowledge models, as shown in *Figure _5_‑_6_*.

This will allow (for example) the modeling of complex decision logic by combining diverse areas of business knowledge, and the provision of alternative versions of decision logic for use in different situations.

image:extracted-media/media/image7.png[image,width=334,height=123]

[#_Toc87278788 .anchor]##*Figure 5‑6: Combining business knowledge models*

DRGs and their notation as DRDs are specified in detail in clause 0.

==== Decision logic level

The components of the decision requirements level of a decision model may be described, as they are above, using only business concepts. This level of description is often sufficient for business analysis of a domain of decision-making, to identify the business decisions involved, their interrelationships, the areas of business knowledge and data required by them, and the sources of the business knowledge. Using decision logic, the same components may be specified in greater detail, to capture a complete set of business rules and calculations, and (if desired) to allow the decision-making to be fully automated.

Decision logic may also provide additional information about how to display elements in the decision model. For example, the decision logic element for a decision table may specify whether to show the rules as rows or as columns. The decision logic element for a calculation may specify whether to line up terms vertically or horizontally.

The correspondence between concepts at the decision requirements level and the decision logic level is described below. Please note that in the figures below, as in *Figure _5_‑_1_* and *Figure _5_‑_2_*, the grey ellipses and dotted lines are drawn only to indicate correspondences between concepts in different levels for the purposes of this introduction. They do _not_ form part of the notation of *DMN*, which is formally defined in clauses 6.2, 8.2, and 10.2. It is envisaged that implementations will provide facilities for moving between levels of modeling, such as “opening”, “drilling down” or “zooming in”, but *DMN* does not specify how this should be done.

At the decision logic level, every decision in a DRG is defined using a *value expression* which specifies how the decision’s output is determined from its inputs. At that level, the decision is considered to _be_ the evaluation of the expression. The value expression may be notated using a *boxed expression*, as shown in *Figure _5_‑_7_*.

image:extracted-media/media/image8.png[image,width=595,height=229]

[#_Toc87278789 .anchor]##*Figure 5‑7: Decision and corresponding value expression*

In the same way, at the decision logic level, a business knowledge model is defined using a value expression that specifies how an output is determined from a set of inputs. In a business knowledge model, the value expression is encapsulated as a function definition, which may be invoked from a decision's value expression.

The interpretation of business knowledge models as functions in *DMN* means that the combination of business knowledge models as in Figure 5‑6 has the clear semantics of functional composition. The value expression of a business knowledge model may be notated using a *boxed function* definition, as shown in Figure 5‑8. Similar to a business knowledge model, the decision service element can also be invoked from a decision’s value expression (see clause 5.3.3).

image:extracted-media/media/image9.png[image,width=649,height=178]

[#_Toc87278790 .anchor]##*Figure 5‑8: Business knowledge model and corresponding value expression*

A business knowledge model may contain any decision logic which is capable of being represented as a function. This will allow the import of many existing decision logic modeling standards (e.g., for business rules and analytic models) into *DMN*. An important format of business knowledge, specifically supported in *DMN*, is the Decision Table. Such a business knowledge model may be notated using a *Decision Table*, as shown in *Figure _5_‑_9_*.

image:extracted-media/media/image10.png[image,width=649,height=248]

[#_Toc87278791 .anchor]##*Figure 5‑9: Business knowledge model and corresponding decision table*

In most cases, the logic of a decision is encapsulated into business knowledge models, and the value expression associated with the decision specifies how the business knowledge models are invoked, and how the results of their invocations are combined to compute the output of the decision. The decision’s value expression may also specify how the output is determined from its input entirely within itself, without invoking a business knowledge model: in that case, no business knowledge model is associated with the decision (neither at the decision requirements level nor at the decision logic level).

An expression language for defining decision logic in *DMN*, covering all the above concepts, is specified fully in clause 10. This is *FEEL*: The Friendly Enough Expression Language. The notation for Decision Tables is specified in detail in clause 8.

==== Decision services

A decision service defines reusable logic within the decision model. A decision service exposes one or more decisions from a decision model as a reusable element, a service, which might be consumed (for example) internally by another decision in the decision model, or externally by a task in a *BPMN* process model. When the service is called with the necessary input data and decision results, it returns the outputs of the exposed decisions. Any decision service encapsulating a *DMN* decision model will be stateless and have no side effects.

One important use of *DMN* will be to define decision-making logic to be automated using decision services. When the decision service is invoked externally, it might be implemented, for example, as a web service. *DMN* does not specify how such services should be implemented, but it allows the functionality of a service to be defined against a decision model. The decision service therefore must be defined in a DRD. When invoked internally from a decision the decision service is invoked, similar to a BKM, by binding expressions in the logic of the calling decision to parameters in the invoked decision service.

It is assumed that the client requires a certain set of decisions to be made, and that the service is created to meet that requirement. The sole function of the decision service is to return the results of evaluating that set of decisions (the “output decisions”). The service may be provided with the results of decisions evaluated externally to the service (the “input decisions”). The service must encapsulate not just the output decisions but also any decisions in the DRG directly or indirectly required by the output decisions which are not provided in the input decisions (the “encapsulated decisions”).

The interface to the decision service will consist of:

* {blank}
* {blank}
* {blank}

Input data: instances of all the input data required by the encapsulated decisions.Input decisions: instances of the results of all the input decisions.Output decisions: the results of evaluating (at least) all the output decisions, using the provided input decisions and input data.When the service is called, providing the input data and input decisions, it returns the output decisions.

Note that to define a decision service it is only necessary to specify the output decisions and either the input decisions or the encapsulated decisions. The remaining attributes (the required input data, and whichever of the encapsulated or input decisions was not specified) may then be inferred from the decision model against which the service is defined. Alternatively, if more attributes are defined than are strictly necessary, they may be validated against the decision model.

*Figure _5_‑_10_* shows a decision service defined against a decision model that includes three decisions. The output decisions for this service are \{Decision 1}, and the input decisions are \{}, that is, the service returns the result of Decision 1 and is not provided with the results of any external decisions. Since Decision 1 requires Decision 2, which is not provided to the service as input, the service must also encapsulate Decision 2. Decision 3 is not required to be encapsulated. The encapsulated decisions are therefore \{Decision 1, Decision 2}. The service requires Input data 1 and Input data 2, but not Input data 3.

image:extracted-media/media/image11.wmf[image,width=429,height=256]

[#_Toc87278792 .anchor]##*Figure 5‑10: A decision service*

Multiple decision services may be defined against the same decision model. *Figure _5_‑_11_* shows a decision service defined against the same decision model, whose output decisions are \{Decision 1} and whose input decisions are \{Decision 2}. The encapsulated decisions for this service are \{Decision 1}. The service requires Input data 1, but not Input data 2 or Input data 3.

image:extracted-media/media/image12.wmf[image,width=461,height=235]

[#_Toc87278793 .anchor]##*Figure 5‑11: A decision service taking a decision as input*

In its simplest form a decision service would always evaluate all the decisions in the output set set and return all their results.

For computational efficiency various improvements to this basic interpretation can be imagined, for example:

* {blank}
* {blank}

An optional input parameter specifying a list of “requested decisions” (a subset of the minimal output set). Only the results of the requested decisions would be returned in the output context.An optional input parameter specifying a list of “known decisions” (a subset of the encapsulation set), with their results. The decision service would not evaluate these decisions, but would use the provided input values directly.All such implementation details are left to the software provider.

A decision service is “complete” if it contains decision logic for evaluating all the encapsulated decisions on all possible input data values. A request to the service is “valid” if instances are provided for all the input decisions and input data required by those decisions which need to be evaluated, i.e., (in the simple case) all the encapsulated decisions, or (assuming the optional parameters above) any requested decisions and any encapsulated decisions required by them which are not already known.

== 

=== Requirements (DRG and DRD)Introduction

The decision requirements level of a decision model in *DMN* consists of a Decision Requirements Graph (DRG) depicted in one or more Decision Requirements Diagrams (DRDs).

A DRG models a domain of decision-making, showing the most important elements involved in it and the dependencies between them. The elements modeled are decisions, areas of business knowledge, sources of business knowledge, input data and decision services:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

A *Decision* element denotes the act of determining an output from a number of inputs, using decision logic which may reference one or more Business Knowledge Models.A *Business Knowledge Model* element denotes a function encapsulating business knowledge, e.g., as business rules, a decision table, or an analytic model.An *Input Data* element denotes information used as an input by one or more Decisions.A *Knowledge Source* element denotes an authority for a Business Knowledge Model or Decision.A *Decision Service* element denotes a set of reusable decisions that can be invoked internally or externally. The dependencies between these elements express three kinds of requirements: information, knowledge and authority:

* {blank}
* {blank}
* {blank}

An *Information Requirement* denotes Input Data or Decision output being used as input to a Decision.A *Knowledge Requirement* denotes the invocation of a Business Knowledge Model or Decision Service by the decision logic of a Decision.An *Authority Requirement* denotes the dependence of a DRG element on another DRG element that acts as a source of guidance or knowledge.DRDs may also contain any number of artifacts representing annotations of the diagram:

* {blank}
* {blank}
* {blank}

A Text Annotation is modeler-entered text used for comment or explanation.An Association is a dotted connector used to link a Text Annotation to a DRG ElementA Group is a visual mechanism to group elements of a diagram informally. These components are summarized in *Table _1_* and described in more detail in clause 6.2.

A DRG is a graph composed of elements connected by requirements, and is self-contained in the sense that all the modeled requirements for any Decision in the DRG (its immediate sources of information, knowledge and authority) are present in the same DRG. It is important to distinguish this complete definition of the DRG from a DRD presenting any particular view of it, which may be a partial or filtered display: see clause 6.2.4.

=== Notation

The notation for all components of a DRD is summarized in *Table _1_* and described in more detail below.

.[#_Toc87278931 .anchor]##*Table 1: DRD components*
[width="100%",cols="18%,16%,33%,33%",options="header",]
|===
|*Component* | |*Description* |*Notation*
|Elements |Decision |A decision denotes the act of determining an output from a number of inputs, using decision logic which may reference one or more business knowledge models. |image:extracted-media/media/image13.wmf[image,width=115,height=38]
| |Business Knowledge +
Model |A business knowledge model denotes a function encapsulating business knowledge, e.g., as business rules, a decision table, or an analytic model. |image:extracted-media/media/image14.wmf[image,width=115,height=38]
| |Input Data a|
____
An input data element denotes information used as an input by one or more decisions. When enclosed within a knowledge model, it denotes the parameters to the knowledge model.
____

|image:extracted-media/media/image15.wmf[image,width=115,height=38]
| |Knowledge Source |A knowledge source denotes an authority for a business knowledge model or decision. |image:extracted-media/media/image16.wmf[image,width=98,height=58]
| a|
____
Decision +
Service (expanded)
____

|A decision service may enclose a set of reusable decisions (not shown in the element to the right) that can be invoked internally by another decision or externally, e.g., by a *BPMN* process. |image:extracted-media/media/image17.wmf[image,width=146,height=64]
| a|
____
Decision +
Service (collapsed)
____

|A decision service denotes a set of reusable decisions (that may be hidden using the element to the right). |image:extracted-media/media/image18.wmf[image,width=141,height=67]
|Requirements |Information Requirement |An information requirement denotes input data or a decision output being used as one of the inputs of a decision. |image:extracted-media/media/image19.wmf[image,width=179,height=20]
| |Knowledge Requirement |A knowledge requirement denotes the invocation of a business knowledge model. |image:extracted-media/media/image20.wmf[image,width=174,height=24]
| |Authority Requirement |An authority requirement denotes the dependence of a DRD element on another DRD element that acts as a source of guidance or knowledge. |image:extracted-media/media/image21.wmf[image,width=179,height=22]
|Artifacts |Text Annotation |A Text Annotation consists of a square bracket followed by modeler-entered explanatory text or comment. |image:extracted-media/media/image22.wmf[image,width=128,height=56]
| |Association |An Association connector links a Text Annotation to the DRG Element it explains or comments on. |image:extracted-media/media/image23.wmf[image,width=174,height=12]
| |Group |A Group consists of a rounded corner rectangle drawn with a solid dashed line that groups element together informally. |image:extracted-media/media/image24.wmf[image,width=153,height=81]
|===

==== DRD Elements

===== Decision notation

A Decision is represented in a DRD as a rectangle, normally drawn with solid lines, as shown in *Table _1_*. The Name of the Decision MUST be displayed inside the shape unless it is overridden by the text attribute of the associated DMNDI:DMNLabel element, which MUST be displayed instead.

If the Listed Input Data option is exercised (see 6.2.1.3), all the Decision’s requirements for Input Data SHALL be listed beneath the Decision’s Name and separated from it by a horizontal line, as shown in Figure 6‑1.The listed Input Data names SHALL be clearly inside the shape of the DRD element.

image:extracted-media/media/image25.jpeg[image,width=142,height=96]

[#_Toc87278794 .anchor]##*Figure 6‑1: Decision with Listed Input Data option*

The properties of a Decision are listed and described in 6.3.6.

===== Business Knowledge Model notation

A Business Knowledge Model is represented in a DRD as a rectangle with two clipped corners, normally drawn with solid lines, as shown in *Table _1_*. The Name of the Business Knowledge Model MUST be displayed inside the shape unless it is overridden by the text attribute of the associated DMNDI:DMNLabel element, which MUST be displayed instead.

The properties of a Business Knowledge Model are listed and described in 6.3.8.

===== Input Data notation

An Input Data element is represented in a DRD as a shape with two parallel straight sides and two semi-circular ends, normally drawn with solid lines, as shown in *Table _1_*. The Name of the Input Data element MUST be displayed inside the shape unless it is overridden by the text attribute of the associated DMNDI:DMNLabel element, which MUST be displayed instead.

An alternative compliant way to display requirements for Input Data, especially useful when DRDs are large or complex, is that Input Data are not drawn as separate notational elements in the DRD, but are instead listed on those Decision elements which require them. For convenience in this specification this is called the “Listed Input Data” option. Implementations MAY offer this option. Figure 6‑2 shows two equivalent DRDs, one drawing Input Data elements, the other exercising the Listed Input Data option. Note that if an Input Data element is not displayed it SHALL be listed on all Decisions which require it (unless it is deliberately hidden as discussed in 6.2.4).

image:extracted-media/media/image26.png[image,width=649,height=292]

[#_Toc87278795 .anchor]##*Figure 6‑2: The Listed Input Data option*

The properties of an Input Data element are listed and described in 6.3.11.

===== Knowledge Source notation

A Knowledge Source is represented in a DRD as a shape with three straight sides and one wavy one, normally drawn with solid lines, as shown in *Table _1_*. The Name of the Knowledge Source MUST be displayed inside the shape unless it is overridden by the text attribute of the associated DMNDI:DMNLabel element, which MUST be displayed instead.

The properties of a Knowledge Source element are listed and described in 6.3.12.

==== DRD Requirements

===== Information Requirement notation

Information Requirements may be drawn from Input Data elements to Decisions, and from Decisions to other Decisions. They represent the dependency of a Decision on information from input data or the results of other Decisions. They may also be interpreted as data flow: a DRD displaying only Decisions, Input Data and Information Requirements is equivalent to a dataflow diagram showing the communication of information between those elements at evaluation time. The Information Requirements of a valid DRG form a directed acyclic graph.

An Information Requirement is represented in a DRD as an arrow drawn with a solid line and a solid arrowhead, as shown in *Table _1_*. The arrow is drawn in the direction of information flow, i.e., towards the Decision that requires the information.

===== Knowledge Requirement notation

Knowledge Requirements may be drawn from invocable elements (Business Knowledge Models or Decision Services) to Decisions and from invocable elements to Business Knowledge Models. They represent the invocation of an invocable element when making a decision. If _e_ is a decision or a BKM in some DRD, and _e_ contains a knowledge requirement on some invocable element _b_, then the logic of _e_ must contain an invocation expression of _b_, including expressions for each of _b_'s parameters.

A Knowledge Requirement is represented in a DRD as an arrow drawn with a dashed line and an open arrowhead, as shown in *Table _1_*. The arrows are drawn in the direction of the information flow of the result of evaluating the function, i.e. toward the element that requires the business knowledge.

===== Authority Requirement notation

Authority Requirements may be used in two ways:

[loweralpha]
. {blank}

They may be drawn from Knowledge Sources to Decisions, Business Knowledge Models and other Knowledge Sources, where they represent the dependence of the DRD element on the knowledge source. This might be used to record the fact that a set of business rules must be consistent with a published document (e.g., a piece of legislation or a statement of business policy), or that a specific person or organizational group is responsible for defining some decision logic, or that a decision is managed by a person or group. An example of this use of Knowledge Sources is shown in Figure 6‑3: in this case the Business Knowledge Model requires two sources of authority – a policy document and legislation – and the policy document requires the authority of a policy group. +
image:extracted-media/media/image27.png[image,width=441,height=138]

[#_Toc87278796 .anchor]##*Figure 6‑3: Knowledge Sources representing authorities*

[loweralpha, start=2]
. {blank}

They may be drawn from Input Data and Decisions to Knowledge Sources, where, in conjunction with use (a), they represent the derivation of Business Knowledge Models from instances of Input Data and Decision results, using analytics. The Knowledge Source typically represents the analytic model (or modeling process); the Business Knowledge Model represents the executable logic generated from or dependent on the model. An example of this use of a Knowledge Source is shown in Figure 6‑4: in this case a business knowledge model is based on an analytic model which is derived from input data and the results of a dependent decision.image:extracted-media/media/image28.png[image,width=322,height=168]

[#_Toc87278797 .anchor]##*Figure 6‑4: Knowledge source representing predictive analytics*

However, the figures above are only examples. There are many other possible use cases for Authority Requirements (and since Knowledge Sources and Authority Requirements have no execution semantics their interpretation is necessarily vague), so this specification leaves the details of their application to the implementer.

An Authority Requirement is represented in a DRD as an arrow drawn with a dashed line and a filled circular head, as shown in *Table _1_*. The arrows are drawn from the source of authority to the element governed by it.

==== Connection rules

The rules governing the permissible ways of connecting elements with requirements in a DRD are described in Clause 6.2.2 above and summarized in *Table _2_*. For clarity, a simple DRD is shown for each permissible connection. In each of these diagrams, the upper (“to”) element requires the lower (“from”) element.

Note that no requirements may be drawn terminating in Input Data, that is, input data may have no requirements. Note also that the type of the requirement is uniquely determined by the types of the two elements connected.

.[#_Toc87278932 .anchor]##*Table 2: Requirements connection rules*
[width="100%",cols="26%,25%,25%,24%",options="header",]
|===
|*From* |*To (Required by)* |*Requirement* |*Diagram*
|Decision |Decision |Information |image:extracted-media/media/image29.wmf[image,width=132,height=84]
|Decision |Knowledge Source |Authority |image:extracted-media/media/image30.wmf[image,width=118,height=84]
|Business Knowledge Model |Decision |Knowledge |image:extracted-media/media/image31.wmf[image,width=118,height=91]
|Business Knowledge Model |Business Knowledge Model |Knowledge |image:extracted-media/media/image32.wmf[image,width=113,height=84]
|Decision Service |Decision |Knowledge |image:extracted-media/media/image33.wmf[image,width=107,height=154]
|Decision Service |Business Knowledge Model |Knowledge |image:extracted-media/media/image34.wmf[image,width=108,height=134]
|*From* |*To (Required by)* |*Requirement* |*Diagram*
|Input data |Decision |Information |image:extracted-media/media/image35.wmf[image,width=108,height=76]
|Input data |Knowledge Source |Authority |image:extracted-media/media/image36.wmf[image,width=124,height=84]
|Knowledge Source |Decision |Authority |image:extracted-media/media/image37.wmf[image,width=124,height=78]
|Knowledge Source |Business Knowledge Model |Authority |image:extracted-media/media/image38.wmf[image,width=119,height=79]
|Knowledge Source |Knowledge Source |Authority |image:extracted-media/media/image39.wmf[image,width=113,height=70]
|===

==== Partial views and hidden information

The metamodel (see 6.3) provides properties for each of the DRG elements which would not normally be displayed on the DRD, but provide additional information about their nature or function. For example, for a Decision these include properties specifying which *BPMN* processes and tasks make use of the Decision. Implementations SHALL provide facilities for specifying and displaying such properties.

For any significant domain of decision-making a DRD representing the complete DRG may be a large and complex diagram. Implementations MAY provide facilities for displaying DRDs which are partial or filtered views of the DRG, e.g., by hiding categories of elements, or hiding or collapsing areas of the network.

DRG Elements with requirements not displayed on the current DRD SHOULD be notated with an ellipsis (...) to show that this is the case. For example, see Figure 11‑5.

Two examples of DRDs providing partial views of a DRG are shown in Figure 6‑5: DRD 1 shows only the immediate requirements of a single decision; DRD 2 shows only Information Requirements and the elements they connect.

image:extracted-media/media/image40.png[image,width=618,height=357]

[#_Toc87278798 .anchor]##*Figure 6‑5: DRDs as partial views of a DRG*

DRDs can be interchanged using the Diagram Interchange mechanism defined in section 13.

==== Decision service

A Decision Service is represented in a DRD as rectangle with rounded corners, drawn with a heavy solid border. The Name of the Decision Service MUST be displayed inside the shape unless it is overridden by the text attribute of the associated DMNDI:DMNLabel element, which MUST be displayed instead. The border SHALL enclose all the encapsulated decisions, and no other decisions or input data. The border MAY enclose other DRG elements but these will not form part of the definition of the Decision Service.

If the set of output decisions is smaller than the set of encapsulated decisions, the Decision Service SHALL be divided into two parts with a straight solid line. One part SHALL enclose only the output decisions and the Decision Service's Name; the other part SHALL enclose all the encapsulated decisions which are not in the set of output decisions. Either part MAY enclose other DRG elements but these will not form part of the definition of the Decision Service.

Figure 6‑6 shows a Decision Service with two output decisions; other examples (with a single output decision) are shown in Figure 5‑10 and Figure 5‑11.

image:extracted-media/media/image41.png[image,width=293,height=180]

[#_Toc87278799 .anchor]##*Figure 6‑6: Decision Service notation*

A decision service may be defined in one DRD and then shown in a different DRD when invoked internally within the decision model by another decision. In the case of a decision service invocation internal to the decision model, a decision service may also be shown without the details of its definition, as in a “collapsed state”. Figure 6‑7 consists of two separate diagrams: DRD 1 shows the definition of Decision service 1. In DRD 2, the same Decision service 1 is shown as invoked by Decision 5. In DRD 2, Decision service 1 is shown in a collapsed form.

image:extracted-media/media/image42.wmf[image,width=650,height=220]

[#_Toc87278800 .anchor]##*Figure 6‑7: A decision service in expanded and collapsed form*

DRD 1 in Figure 6‑7 shows that Decision service 1 has 2 inputs: Decision 4 and Input data 1. It is therefore inferred that Decision Service 1 has 2 input parameters with matching characteristics to Decision 4 and Input data 1. DRD 2 in Figure 6‑7 shows that Decision 5 has 2 dependencies but whether these are mapped as parameters for the invocation of Decision Service 1 cannot be determined from the diagram.

The information and authority requirements defined on Decision 2 in DRD 1 are not depicted in the collapsed form of Decision Service 1 shown in DRD 2.

image:extracted-media/media/image43.wmf[image,width=563,height=214]

[#_Toc87278801 .anchor]##*Figure 6‑8: A decision service invoked in an expanded form*

DRDs 1 and 2 in Figure 6‑7 and DRD 3 in Figure 6‑8 are all congruent within the same DRG. They all show different aspects of Decision Service 1. DRD 3 shows an expanded form Decision service 1 being invoked by Decision 5.

The constraint imposed on the rendering of decision services within a DRD is that the same decision service MUST NOT be rendered both expanded and collapsed within the same DRD. This stems from the general restriction disallowing the same DMN Element to be present twice in the same diagram.

image:extracted-media/media/image44.wmf[image,width=650,height=225]

[#_Toc87278802 .anchor]##*Figure 6‑9: A decision service defined as an overlay*

Decision services are defined as overlays and therefore do not encapsulate the decisions within them. Therefore, the richness of connections depicted in Figure 6‑9 is allowed. In this DRD, Decision 7 is dependent on Decision 2.

==== Identifying Collections

Decisions and Input Data elements on a DRD can represent collections of elements. Implementations MAY show this with the addition of ||| in the shape. Implementations SHALL show this on all such DRD elements within a DRG OR on no DRD elements.

A Decision is considered to represent a collection if the Decision's decisionOutput InformationItem references an ItemDefinition with isCollection = TRUE.

An InputData is considered to represent a collection if the InputData's variable InformationItem references an ItemDefinition with isCollection = TRUE.

Two examples, a Decision and an Input Data, are shown in Figure 6‑10

image:extracted-media/media/image45.png[Shape Description automatically generated with medium confidence,width=257,height=39]

[#_Toc87278803 .anchor]##*Figure* *6‑10: Decision and Input Data showing collection marker*

=== Metamodel

==== DMN Element metamodel

image:extracted-media/media/image46.png[image,width=650,height=410]

[#_Toc87278804 .anchor]##*Figure 6‑11:* DMNElement *Class Diagram*

DMNElement is the abstract superclass for the decision model elements. It provides the optional attributes id, description and label, which are Strings which other elements will inherit. The id of a DMNElement is further restricted to the syntax of an XML ID (http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#ID),[[.underline]#http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#ID)&#44;#] and SHALL be unique within the decision model.

DMNElement has abstract specializations NamedElement and Expression NamedElement adds the required attribute name, and includes the abstract specializations BusinessContextElement and DRGElement, as well as concrete specializations Definitions, ItemDefinition, InformationItem, ElementCollection and DecisionService.

*Table _3_* presents the attributes and model associations of the DMNElement element.

.[#_Toc87278933 .anchor]##*Table 3:* DMNElement *attributes and model associations*
[width="100%",cols="51%,49%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*id:* ID [0..1]
____

a|
____
Optional identifier for this element. SHALL be unique within its containing Definitions element.
____

a|
____
*description*: String [0.. 1]
____

a|
____
A description of this element.
____

a|
____
*label:* String [0.. 1]
____

a|
____
An alternative short description of this element. It should primarily be used on elements that do not have a name attribute, e.g., an Input Expression. Similar to the description attribute, it has no notation defined and is neither related to the DMNLabel element that is used in Diagram Interchange nor to the outputLabel attribute of a Decision Table.
____

a|
____
*extensionElements:* ExtensionElement [0..1]
____

a|
____
This attribute is used as a container to attach additional elements to any DMN Element. See 6.3.16 for additional information on extensibility.
____

a|
____
*extensionAttributes:* ExtensionAttribute [0..*]
____

a|
____
This attribute is used to attach named extended attributes and model associations. This association is not applicable when the XML schema interchange is used, since the XSD mechanism for supporting "anyAttribute" from other namespaces already satisfies this requirement. See 6.3.16 for additional information on extensibility.
____

|===

.[#_Toc87278934 .anchor]##*Table 4:* NamedElement *attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
|*Attribute* |*Description*
|*Name:* string |The name of this element
|===

==== Definitions metamodel

image:extracted-media/media/image49.wmf[image,width=615,height=485]

[#_Toc87278805 .anchor]##*Figure 6‑12: Definitions Class Diagram*

The Definitions class is the outermost containing object for all elements of a *DMN* decision model. It defines the scope of visibility and the namespace for all contained elements. Elements that are contained in an instance of Definitions have their own defined life-cycle and are not deleted with the deletion of other elements. The interchange of *DMN* files will always be through one or more Definitions.

Definitions is a kind of NamedElement, from which an instance of Definitions inherits the name and optional id, description and label attributes, which are Strings.

An instance of Definitions has a namespace, which is a String. The namespace identifies the default target namespace for the elements in the Definitions and follows the convention established by XML Schema.

An instance of Definitions may specify an expressionLanguage, which is a URI that identifies the default expression language used in elements within the scope of this Definitions. This value may be overridden on each individual LiteralExpression. The language SHALL be specified in a URI format. The default expression language is FEEL (clause 10), indicated by the URI: “https://www.omg.org/spec/DMN/20191[[.underline]#https://www.omg.org/spec/DMN/20191#] 111/FEEL/”. The simple expression language S-FEEL (clause 9), being a subset of FEEL, is indicated by the same URI. *DMN* provides a URI for expression languages that are not meant to be interpreted automatically (e.g., pseudo-code that may resemble FEEL but is not): "http://www.omg.org/spec/DMN/uninterpreted/20140801[[.underline]#http://www.omg.org/spec/DMN/uninterpreted/20140801#]".

An instance of Definitions may specify a typeLanguage, which is a URI that identifies the default type language used in elements within the scope of this Definitions. For example, a typeLanguage value of “http://www.w3.org/2001/XMLSchema[[.underline]#http://www.w3.org/2001/XMLSchema#]” indicates that the data structures defined within that Definitions are, by default, in the form of XML Schema types. If unspecified, the default typeLanguage is FEEL. This value may be overridden on each individual ItemDefinition. The typeLanguage SHALL be specified in a URI format (the URI for FEEL is “https://www.omg.org/spec/DMN/20191[[.underline]#https://www.omg.org/spec/DMN/20191#] 111/FEEL/”; the URI "http://www.omg.org/spec/DMN/uninterpreted/20140801[[.underline]#http://www.omg.org/spec/DMN/uninterpreted/20140801#]" can be used to indicate that a type definition is not meant to be interpreted)).

An instance of Definitions may specify an exporter and exporterVersion, which are Strings naming the tool and version used to create the XML serialization. In standards such as *BPMN*, this has been found to aid in model interchange between tools.

An instance of Definitions is composed of zero or more drgElements, which are instances of DRGElement, zero or more elementCollections, which are instances of ElementCollection, zero or more itemDefinitions, which are instances of ItemDefinition and of zero or more businessContextElements, which are instances of BusinessContextElement.

It may contain any number of associated import, which are instances of Import. Imports are used to import elements defined outside of this Definitions, e.g. in other Definitions elements, and to make them available for use by elements in this Definitions.

Definitions inherits all the attributes and model associations from NamedElement. *Table _5_* presents the additional attributes and model associations of the Definitions element.

.[#_Toc87278935 .anchor]##*Table 5: Definitions attributes and model associations*
[width="100%",cols="49%,51%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*namespace*: anyURI [1]
____

a|
____
This attribute identifies the namespace associated with this Definitions and follows the convention established by XML Schema.
____

a|
____
*expressionLanguage*: anyURI [0.. 1]
____

a|
____
This attribute identifies the expression language used in LiteralExpressions within the scope of this Definitions. The Default is FEEL (clause 10). This value MAY be overridden on each individual LiteralExpression. The language SHALL be specified in a URI format.
____

a|
____
*typeLanguage*: anyURI [0.. 1]
____

a|
____
This attribute identifies the type language used in LiteralExpressions within the scope of this Definitions. The Default is FEEL (clause 10). This value MAY be overridden on each individual ItemDefinition. The language SHALL be specified in a URI format.
____

a|
____
*exporter*: string [0..1]
____

a|
____
This attribute names the tool used to export the XML serialization.
____

a|
____
*exporterVersion*: string [0.. 1]
____

a|
____
This attribute names the version of the tool used to export the XML serialization.
____

a|
____
*itemDefinition*: ItemDefinition [*]
____

a|
____
This attribute lists the instances of ItemDefinition that are contained in this Definitions.
____

a|
____
*drgElement*: DRGElement [*]
____

a|
____
This attribute lists the instances of DRGElement that are contained in this Definitions.
____

a|
____
*businessContextElement*: BusinessContextElement [*]
____

a|
____
This attribute lists the instances of BusinessContextElement that are contained in this Definitions.
____

a|
____
*elementCollection:* ElementCollection [*]
____

a|
____
This attribute lists the instances of ElementCollection that are contained in this Definitions.
____

a|
____
*import*: Import [*]
____

a|
____
This attribute is used to import externally defined elements and make them available for use by elements in this Definitions.
____

a|
____
*artifact:* Artifact [0..*]
____

a|
____
Artifacts include text annotations, groups, and associations among DMN elements.
____

a|
____
*dmnDI*: DMNDI [0..1]
____

a|
____
This attribute contains the Diagram Interchange information contained within this Definitions (see Clause 13 for more information on the DMN Diagram Interchange).
____

|===

==== Import metamodel

The Import class is used when referencing external elements, either *DMN* DRGElement or ItemDefinition instances contained in other Definitions elements, or non-*DMN* elements, such as an XML Schema or a PMML file. Imports SHALL be explicitly defined.

An instance of Import has an importType, which is a String that specifies the type of import associated with the element. For example, a value of “http://www.w3.org/2001/XMLSchema[[.underline]#http://www.w3.org/2001/XMLSchema#]” indicates that the imported element is an XML schema. The *DMN* namespace indicates that the imported element is a *DMN* Definitions element.

The location of the imported element may be specified by associating an optional locationURI with an instance of Import. The locationURI is a URI.

An instance of Import has a namespace, which is a URI that identifies the namespace of the imported element, and also a name, inherited from NamedElement, which is a string that serves as a prefix in namespace-qualified names, such as typeRefs specifying imported ItemDefinitions and expressions referencing imported

InformationItems. The namespace value should be globally unique, but the import name, which is typically a short business-friendly name,must be distinct from the names of other imports, decisions, input data, business knowledge models, decision services, and item definitions within the importing model only.

*Table _6_* presents the attributes and model associations of the Import element.

.[#_Toc87278936 .anchor]##*Table 6: Import attributes and model associations*
[width="100%",cols="49%,51%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*importType*: anyURI
____

a|
____
Specifies the style of import associated with this Import.
____

a|
____
*locationURI*: anyURI [0.. 1]
____

a|
____
Identifies the location of the imported element.
____

a|
____
*namespace*: anyURI
____

a|
____
Identifies the namespace of the imported element.
____

|===

==== Element Collection metamodel

The ElementCollection class is used to define named groups of DRGElement instances. ElementCollections may be used for any purpose relevant to an implementation, for example:

* {blank}
* {blank}

To identify the requirements subgraph of a set one or more decisions (i.e., all the elements in the closure of the requirements of the set).To identify the elements to be depicted on a DRD.ElementCollection is a kind of NamedElement, from which an instance of ElementCollection inherits the name and optional id, description and label attributes, which are Strings. The id of an ElementCollection element SHALL be unique within the containing instance of Definitions.

An ElementCollection element has any number of associated drgElements, which are the instances of DRGElement that this ElementCollection defines together as a group. Notice that an ElementCollection element must reference the instances of DRGElement that it collects, not contain them: instances of DRGElement can only be contained in Definitions elements.

ElementCollection inherits all the attributes and model associations from NamedElement. *Table _7_* presents the additional attributes and model associations of the ElementCollection element.

.[#_Toc87278937 .anchor]##*Table 7: ElementCollection attributes and model associations*
[width="100%",cols="51%,49%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*drgElement*: DRGElement [*]
____

a|
____
This attribute lists the instances of DRGElement that this ElementCollection groups.
____

|===

==== DRG Element metamodel

DRGElement is the abstract superclass for all *DMN* elements that are contained within Definitions and that have a graphical representation in a DRD. All the elements of a *DMN* decision model that are not contained directly in a Definitions element (specifically: all three kinds of requirement, bindings, clause and decision rules, import, and objective) SHALL be contained in an instance of DRGElement, or in a model element that is contained in an instance of DRGElement, recursively.

The specializations of DRGElement are Decision, InputData, Invocable, and KnowledgeSource. Invocable is further specialized into BusinessKnowledgeModel and DecisionService.

DRGElement is a specialization of NamedElement, from which it inherits the name and optional id, description and label attributes. The id of a DRGElement element SHALL be unique within the containing instance of Definitions.

A *Decision Requirements Diagram* (*DRD*) is the diagrammatic representation of one or more instances of DRGElement and their information, knowledge and authority requirement relations. The instances of DRGElement are represented as the vertices in the diagram; the edges represent instances of InformationRequirement, KnowledgeRequirement or AuthorityRequirement (see clauses 6.3.13, 6.3.14, and 6.3.15). The connection rules are specified in 6.2.3).

DRGElement inherits all the attributes and model associations of NamedElement. It does not define additional attributes and model associations of the DRGElement element.

==== Artifact metamodel

Artifacts are used to provide additional information about a Decision Model. DMN provides two standard Artifacts: Association and Text Annotation. Associations can be used to link Artifacts to any DMNElement.

===== Association

An Association is used to link information and Artifacts with DMN graphical elements. Text Annotations and other Artifacts can be associated with the graphical elements. An arrowhead on the Association indicates a direction of flow (e.g., data), when appropriate.

The Association element inherits the attributes and model associations of DMNElement (see *Table _3_*). *Table _8_* presents the additional attributes and model associations for an Association.

.[#_Toc87278938 .anchor]##*Table 8: Association attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*associationDirection:* AssociationDirection = None \{None | One | Both}
____

a|
____
associationDirection is an attribute that defines whether or not the Association shows any directionality with an arrowhead. The default is None (no arrowhead). A value of One means that the arrowhead SHALL be at the Target Object. A value of Both means that there SHALL be an arrowhead at both ends of the Association line.
____

a|
____
*sourceRef:* DMNElement [1]
____

a|
____
The DMNElement that the Association is connecting from.
____

a|
____
*targetRef:* DMNElement [1]
____

a|
____
The DMNElement that the Association is connecting to.
____

|===

===== Group

The *Group* object is an Artifact that provides a visual mechanism to group elements of a diagram informally. *Groups* are often used to highlight certain sections of a Diagram without adding additional constraints for performance. The highlighted (grouped) section of the Diagram can be separated for reporting and analysis purposes. *Groups* do not affect the execution of the Decisions.

As an Artifact, a *Group* is not a DRGElement, and, therefore, cannot be connected to/from an Information Requirement, Knowledge Requirement, or Authority Requirement. It can only be connected to/from an Association.

The Group element inherits the attributes and model associations of Artifact. *Table _9_* presents the additional attributes and model associations for a Group.

.[#_Toc87278939 .anchor]##*Table 9: Group model associations*
[width="100%",cols="51%,49%",options="header",]
|===
|*Attribute* |*Description*
|*Name:* String[0.. 1] |The descriptive name of the element.
|===

===== Text Annotation

Text Annotations are a mechanism for a modeler to provide additional text information for the reader of a DMN Diagram.

The TextAnnotation element inherits the attributes and model associations of DMNElement (see *Table _3_*). *Table _10_* presents the additional attributes for a TextAnnotation.

.[#_Toc87278940 .anchor]##*Table 10: TextAnnotation attributes*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*text:* string
____

|Text is an attribute that is text that the modeler wishes to communicate to the reader of the Diagram.
a|
____
*textFormat:* string = "text/plain"
____

|This attribute identifies the format of the text. It SHALL +
follow the mime-type format. The default is "text/plain."
|===

==== Decision metamodel

image:extracted-media/media/image50.png[image,width=628,height=415]

[#_Toc87278806 .anchor]##*Figure 6‑13: Decision Class Diagram*

The class Decision is used to model a decision.

Decision is a concrete specialization of DRGElement and it inherits the name and optional id, description and label attributes from NamedElement The name of an Invocable must be different from the name of any other invocable, input data, decision, or import in the decision model.

In addition, it may have a question and allowedAnswers, which are all strings. The optional description attribute is meant to contain a brief description of the decision-making embodied in the Decision. The optional question attribute is meant to contain a natural language question that characterizes the Decision such that the output of the Decision is an answer to the question. The optional allowedAnswers attribute is meant to contain a natural language description of the answers allowed for the question such as Yes/No, a list of allowed values, a range of numeric values etc.

In a DRD, an instance of Decision is represented by a *decision* diagram element.

A Decision element is composed of an optional decisionLogic, which is an instance of Expression, and of zero or more informationRequirement, knowledgeRequirement and authorityRequirement elements, which are instances of InformationRequirement, KnowledgeRequirement and AuthorityRequirement, respectively.

In addition, a Decision defines an InformationItem representing its output. This InformationItem may include an optional typeRef, which references an ItemDefinition or other type definition specifying the datatype of the possible outcomes of the Decision.

The *requirement subgraph* of a Decision element is the directed graph composed of the Decision element itself, its informationRequirements, its knowledgeRequirements, and the union of the requirement subgraphs of each requiredDecision or requiredKnowledge element: that is, the requirement subgraph of a Decision element is the closure of the informationRequirement, requiredInput, requiredDecision, knowledgeRequirement and requiredKnowledge associations starting from that Decision element.

An instance of Decision – that is, the model of a decision – is said to be *well-formed* if and only if all of its informationRequirement and knowledgeRequirement elements are well-formed, That condition entails, in particular, that the requirement subgraph of a Decision element SHALL be acyclic, that is, that a Decision element SHALL not require itself, directly or indirectly.

Besides its logical components: information requirements, decision logic etc, the model of a decision may also document a business context for the decision (see clause 6.3.8 and Figure 6‑14).

The business context for an instance of Decision is defined by its association with any number of supportedObjectives, which are instances of Objective as defined in OMG BMM, any number of impactedPerformance Indicators, which are instances of Performance Indicator, any number of decisionMaker and any number of decisionOwner, which are instances of OrganisationalUnit.

In addition, an instance of Decision may reference any number of usingProcess, which are instances of Process as defined in OMG *BPMN 2.0*, and any number of usingTask, which are instances of Task as defined in OMG *BPMN 2.0*, and which are the Processes and Tasks that use the Decision element.

Decision inherits all the attributes and model associations from DRGElement. *Table _11_* presents the additional attributes and model associations of the Decision class.

.[#_Toc87278941 .anchor]##*Table 11: Decision attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*question*: string [0..1]
____

a|
____
A natural language question that characterizes the Decision such that the output of the Decision is an answer to the question.
____

a|
____
*allowedAnswers*: string [0..1]
____

a|
____
A natural language description of the answers allowed for the question such as Yes/No, a list of allowed values, a range of numeric values etc.
____

a|
____
*variable*: InformationItem
____

a|
____
The instance of InformationItem that stores the result of this Decision.
____

a|
____
*decisionLogic*: Expression [0..1]
____

a|
____
The instance of Expression that represents the decision logic for this Decision.
____

a|
____
*informationRequirement*: InformationRequirement [*]
____

a|
____
This attribute lists the instances of InformationRequirement that compose this Decision.
____

a|
____
*knowledgeRequirement*: KnowledgeRequirement [*]
____

a|
____
This attribute lists the instances of KnowledgeRequirement that compose this Decision.
____

a|
____
*authorityRequirement*: AuthorityRequirement [*]
____

a|
____
This attribute lists the instances of AuthorityRequirement that compose this Decision.
____

a|
____
*supportedObjective*: BMM::Objective [*]
____

a|
____
This attribute lists the instances of BMM::Objective that are supported by this Decision.
____

a|
____
*impactedPerformanceIndicator*: PerformanceIndicator [*]
____

a|
____
This attribute lists the instances of PerformanceIndicator that are impacted by this Decision.
____

a|
____
*decisionMaker*: OrganisationalUnit [*]
____

a|
____
The instances of OrganisationalUnit that make this Decision.
____

a|
____
*decisionOwner*: OrganisationalUnit [*]
____

a|
____
The instances of OrganisationalUnit that own this Decision.
____

a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*usingProcesses*: *BPMN*::process [*]
____

a|
____
This attribute lists the instances of *BPMN*::process that require this Decision to be made.
____

a|
____
*usingTasks*: *BPMN*::task [*]
____

a|
____
This attribute lists the instances of *BPMN*::task that make this Decision.
____

|===

==== Business Context Element metamodel

image:extracted-media/media/image51.wmf[image,width=650,height=348]

[#_Toc87278807 .anchor]##*Figure 6‑14: BusinessContextElement class diagram*

The abstract class BusinessContextElement, and its concrete specializations PerformanceIndicator and OrganizationUnit are placeholders, anticipating a definition to be adopted from other OMG meta-models, such as OMG OSM when it is further developed.

BusinessContextElement is a specialization of NamedElement, from which it inherits the name and optional id, description and label attributes.

In addition, instances of BusinessContextElements may have a URI, which is a URI, and

* {blank}
* {blank}

an instance of PerformanceIndicator references any number of impactingDecision, which are the Decision elements that impact it;an instance of OrganisationalUnit references any number of decisionMade and of decisionOwned, which are the Decision elements that model the decisions that the organization unit makes or owns.BusinessContextElement inherits all the attributes and model associations from NamedElement. *Table _12_* presents the additional attributes and model associations of the BusinessContextElement class.

.[#_Toc87278942 .anchor]##*Table 12: BusinessContextElement attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*URI*: anyURI [0..1]
____

a|
____
The URI of this BusinessContextElement.
____

|===

PerformanceIndicator inherits all the attributes and model associations from BusinessContextElement. *Table _13_* presents the additional attributes and model associations of the PerformanceIndicator class.

.[#_Toc87278943 .anchor]##*Table 13: PerformanceIndicator attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*impactingDecision:* Decision [*]
____

a|
____
This attribute lists the instances of Decision that impact this PerformanceIndicator.
____

|===

OrganisationalUnit inherits all the attributes and model associations from BusinessContextElement. *Table _14_* presents the additional attributes and model associations of the OrganisationalUnit class.

.[#_Toc87278944 .anchor]##*Table 14: OrganisationalUnit attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*decisionMade*: Decision [*]
____

a|
____
This attribute lists the instances of Decision that are made by this OrganisationalUnit.
____

a|
____
*decisionOwned*: Decision [*]
____

a|
____
This attribute lists the instances of Decision that are owned by this OrganisationalUnit.
____

|===

==== Business Knowledge Model metamodel

image:extracted-media/media/image52.png[image,width=524,height=330]

[#_Toc87278808 .anchor]##*Figure 6‑15: BusinessKnowledgeModel class diagram*

A business knowledge model has an abstract part, representing reusable, invocable decision logic, and a concrete part, which mandates that the decision logic must be a single FEEL boxed function definition. A decision service is also an invocable element, and thus can be invoked as required knowledge from other decisions and business knowledge models.

The class Invocable is used to model an invocable element and the class BusinessKnowledgeModel is used to model a business knowledge model.

Invocable is a specialization of DRGElement and it inherits the name and optional id, description, and label attributes from NamedElement. The name of an Invocable must be different from the name of any other invocable, input data, decision, or import in the decision model. BusinessKnowledgeModel is a specialization of Invocable from which it additionally inherits the variable attribute.

A BusinessKnowledgeModel element may have zero or more knowledgeRequirement, which are instance of KnowledgeRequirement, and zero or more authorityRequirement, which are instances of AuthorityRequirement. These model elements are described below.

The *requirement subgraph* of a BusinessKnowledgeModel element is the directed graph composed of the BusinessKnowledgeModel element itself, its knowledgeRequirement elements, and the union of the requirement subgraphs of all the requiredKnowledge elements that are referenced by its knowledgeRequirements.

An instance of BusinessKnowledgeModel is said to be *well-formed* if and only if, either it does not have any knowledgeRequirement, or all of its knowledgeRequirement elements are well-formed. That condition entails, in particular, that the requirement subgraph of a BusinessKnowledgeModel element SHALL be acyclic, that is, that a BusinessKnowledgeModel element SHALL not require itself, directly or indirectly.

At the decision logic level, a BusinessKnowledgeModel element contains a FunctionDefinition, which is an instance of Expression containing zero or more parameters, which are instances of Information Item. The FunctionDefinition that is contained in a BusinessKnowledgeModel element is the reusable module of decision logic that is represented by this BusinessKnowledgeModel element. An Invocable element contains an InformationItem that holds an invocable reference to the abstract business knowledge, which allows a Decision to invoke it by name. The name of that InformationItem SHALL be the same as the name of the Invocable element. Invocable inherits all the attributes and model associations from DRGElement.

*Table _15_* presents the additional attributes and model associations of the Invocable class. *Table _16_* presents the additional attributes and model associations of the BusinessKnowledgeModel class.

.[#_Toc87278945 .anchor]##*Table 15: Invocable attributes and model associations*
[width="100%",cols="51%,49%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*variable:* InformationItem
____

a|
____
This attribute defines a variable that is bound to the function defined by the FunctionDefinition, allowing decision logic to invoke the function by name.
____

|===

.[#_Toc87278946 .anchor]##*Table 16: BusinessKnowledgeModel attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*encapsulatedLogic:* FunctionDefinition [0.. 1]
____

a|
____
The function that encapsulates the logic encapsulated by this BusinessKnowledgeModel.
____

a|
____
*knowledgeRequirement*: KnowledgeRequirement [*]
____

a|
____
This attribute lists the instances of KnowledgeRequirement that compose this BusinessKnowledgeModel.
____

a|
____
*authorityRequirement*: AuthorityRequirement [*]
____

a|
____
This attribute lists the instances of AuthorityRequirement that compose this BusinessKnowledgeModel.
____

|===

==== Decision service metamodel

image:extracted-media/media/image53.wmf[image,width=649,height=274]

[#_Toc87278809 .anchor]##*Figure 6‑16: DecisionService class diagram*

The DecisionService class is used to define named decision services against the decision model contained in an instance of Definitions.

DecisionService is a kind of Invocable element, from which an instance of DecisionService inherits the name and optional id, description, and label attributes, which are Strings, and a variable, which is an InformationItem. The id of a DecisionService element SHALL be unique within the containing instance of Definitions. The name of the variable and the name of the DecisionService SHALL be the same. This name may be used to invoke a DecisionService from the decision logic of another decision or business knowledge model.

A DecisionService element has one or more associated outputDecisions, which are the instances of Decision required to be output by this DecisionService, i.e., the Decisions whose results the Decision Service must return when called.

A DecisionService element has zero or more encapsulatedDecisions, which are the instances of Decision required to be encapsulated by this DecisionService, i.e., the Decisions to be evaluated by the Decision Service when it is called.

A DecisionService element has zero or more inputDecisions, which are the instances of Decision required as input by this DecisionService, i.e., the Decisions whose results will be provided to the Decision Service when it is called.

A DecisionService element has zero or more inputData, which are the instances of InputData required as input by this DecisionService, i.e., the Input Data which will be provided to the Decision Service when it is called.

The encapsulatedDecisions, inputDecisions and inputData attributes are optional. At least one of the encapsulatedDecisions and inputDecisions attributes SHALL be specified.

The *requirement subgraph* of a DecisionService element is the directed graph composed of the DecisionService element itself and the union of the requirement subgraphs of all the Decision elements that are referenced by its encapsulatedDecisions and outputDecisions.

An instance of DecisionService is said to be *well-formed* if and only if its requirement subgraph is acyclic, that is, that a DecisionService element SHALL not require itself, directly or indirectly.

DecisionService inherits all the attributes and model associations from Invocable. *Table _17_* presents the additional attributes and model associations of the DecisionService element.

.[#_Toc87278947 .anchor]##*Table 17: DecisionService attributes and model associations*
[width="100%",cols="51%,49%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*outputDecisions*: Decision [1..*]
____

a|
____
This attribute lists the instances of Decision required to be output by this DecisionService.
____

a|
____
*encapsulatedDecisions*: Decision [0..*]
____

a|
____
If present, this attribute lists the instances of Decision to be encapsulated in this DecisionService
____

a|
____
*inputDecisions*: Decision [0..*]
____

a|
____
If present, this attribute lists the instances of Decision required as input by this Decis ionService.
____

a|
____
*inputData*: InputData [0..*]
____

a|
____
If present, this attribute lists the instances of InputData required as input by this Decis ionService
____

|===

==== Input Data metamodel

image:extracted-media/media/image54.png[image,width=284,height=311]

[#_Toc87278810 .anchor]##*Figure 6‑17: InputData class diagram*

*DMN* uses the class InputData to model the inputs of a decision whose values are defined outside of the decision model.

InputData is a concrete specialization of DRGElement and it inherits the name and optional id, description and label attributes from NamedElement. The name of an InputData must be different from the name of any other decision, input data, business knowledge model, decision service, or import in the decision model.

An instance of InputData defines an InformationItem that stores its value. This InformationItem may include a typeRef that specifies the type of data that is this InputData represents, either an ItemDefinition, base type in the specified expressionLanguage, or imported type.

In a DRD, an instance of InputData is represented by an *input data* diagram element. An InputData element does not have a *requirement subgraph*, and it is always *well-formed.*

InputData inherits all the attributes and model associations from DRGElement. *Table _18_* presents the additional attributes and model associations of the InputData class.

.[#_Toc87278948 .anchor]##*Table 18: InputData attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*variable*: InformationItem
____

a|
____
The instance of InformationItem that stores the result of this InputData.
____

|===

==== Knowledge Source metamodel

image:extracted-media/media/image55.png[image,width=636,height=274]

[#_Toc87278811 .anchor]##*Figure 6‑18: KnowledgeSource class diagram*

The class KnowledgeSource is used to model authoritative knowledge sources in a decision model. In a DRD, an instance of KnowledgeSource is represented by a *knowledge source* diagram element.

KnowledgeSource is a concrete specialization of DRGElement, and thus of NamedElement, from which it inherits the name and optional id, description and label attributes. In addition, a KnowledgeSource has a locationURI, which is a URI. It has a type, which is a string, and an owner, which is an instance of OrganisationalUnit. The type is intended to identify the kind of the authoritative source, e.g., Policy Document, Regulation, Analytic Insight.

A KnowledgeSource element is also composed of zero or more authorityRequirement elements, which are instances of AuthorityRequirement.

KnowledgeSource inherits all the attributes and model associations from DRGElement. *Table _19_* presents the attributes and model associations of the KnowledgeSource class.

.[#_Toc87278949 .anchor]##*Table 19: KnowledgeSource attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*locationURI*: anyURI [0.. 1]
____

a|
____
The URI where this KnowledgeSource is located. The locationURI SHALL be specified in a URI format.
____

a|
____
*type*: string [0..1]
____

a|
____
The type of this Knowledge Source.
____

a|
____
*owner*: OrganisationalUnit [0..1]
____

a|
____
The owner of this KnowledgeSource.
____

a|
____
*authorityRequirement*: AuthorityRequirement [*]
____

a|
____
This attribute lists the instances of AuthorityRequirement that contribute to this KnowledgeSource.
____

|===

==== Information Requirement metamodel

The class InformationRequirement is used to model an *information requirement*, as represented by a plain arrow in a DRD. InformationRequirement is a specialization of DMNElement, from which it inherits the optional id, description, and label attributes.

An InformationRequirement element is a component of a Decision element, and it associates that requiring Decision element with a requiredDecision element, which is an instance of Decision, or a requiredInput element, which is an instance of InputData.

An InformationRequirement element references an instance of either a Decision or InputData, which defines a variable. That variable, which is an instance of InformationItem, represents the InformationRequirement element at the decision logic level.

Notice that an InformationRequirement element must reference the instance of Decision or InputData that it associates with the requiring Decision element, not contain it: instances of Decision or InputData can only be contained in Definitions elements.

An instance of InformationRequirement is said to be *well-formed* if and only if all of the following are true:

* {blank}
* {blank}
* {blank}
* {blank}

It references a requiredDecision or a requiredInput element, but not both.The referenced requiredDecision or requiredInput element is well-formed.The Decision element that contains the instance of InformationRequirement is not in the requirement subgraph of the referenced requiredknowledge element, if this InformationRequirement element references one.The referenced requiredDecision or requiredInput element is defined in the same decision model or in an imported decision model. +
*Table _20_* presents the attributes and model associations of the InformationRequirement element.

.[#_Toc87278950 .anchor]##*Table 20: InformationRequirement attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*requiredDecision*: Decision [0..1]
____

a|
____
The instance of Decision that this InformationRequirement associates with its containing Decision element.
____

a|
____
*requiredInput*: InputData [0..1]
____

a|
____
The instance of InputData that this InformationRequirement associates with its containing Decision element.
____

|===

==== Knowledge Requirement metamodel

The class KnowledgeRequirement is used to model a *knowledge requirement*, as represented by a dashed arrow in a DRD. KnowledgeRequirement is a specialization of DMNElement, from which it inherits the optional id, description, and label attributes.

A KnowledgeRequirement element is a component of a Decision element or of a BusinessKnowledgeModel element, and it associates that requiring Decision or BusinessKnowledgeModel element with a requiredKnowledge element, which is an instance of Invocable.

Notice that a KnowledgeRequirement element must reference the instance of Invocable that it associates with the requiring Decision or BusinessKnowledgeModel element, not contain it: instances of BusinessKnowledgeModel can only be contained in Definitions elements.

An instance of KnowledgeRequirement is said to be *well-formed* if and only if all of the following are true:

* {blank}
* {blank}
* {blank}
* {blank}

It references a requiredKnowledge element.The referenced requiredKnowledge element is well-formed.If the KnowledgeRequirement element is contained in an instance of BusinessKnowledgeModel, that BusinessKnowledgeModel element is not in the requirement subgraph of the referenced requiredKnowledge element.The referenced requiredKnowledge element is defined in the same decision model or in an imported decision model.*Table _21_* presents the attributes and model associations of the KnowledgeRequirement element.

.[#_Toc87278951 .anchor]##*Table 21: KnowledgeRequirement attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*requiredKnowledge*: Invocable
____

a|
____
The instance of Invocable that this KnowledgeRequirement associates with its containing Decision or BusinessKnowledgeModel element.
____

|===

==== Authority Requirement metamodel

The class AuthorityRequirement is used to model an *authority requirement*, as represented by an arrow drawn with a dashed line and a filled circular head in a DRD. AuthorityRequirement is a specialization of DMNElement, from which it inherits the optional id, description, and label attributes.

An AuthorityRequirement element is a component of a Decision, BusinessKnowledgeModel or KnowledgeSource element, and it associates that requiring Decision, BusinessKnowledgeModel or KnowledgeSource element with a requiredAuthority element, which is an instance of KnowledgeSource, a requiredDecision element, which is an instance of Decision, or a requiredInput element, which is an instance of InputData.

Notice that an AuthorityRequirement element must reference the instance of KnowledgeSource, Decision or InputData that it associates with the requiring element, not contain it: instances of Knowledge Source, Decision or InputData can only be contained in Definitions elements.

*Table _22_* presents the attributes and model associations of the AuthorityRequirement element.

.[#_Toc87278952 .anchor]##*Table 22: AuthorityRequirement attributes and model associations*
[width="100%",cols="49%,51%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*requiredAuthority*: KnowledgeSource [0.. 1]
____

a|
____
The instance of KnowledgeSource that this AuthorityRequirement associates with its containing KnowledgeSource, Decision or BusinessKnowledgeModel element.
____

a|
____
*requiredDecision*: Decision [0..1]
____

a|
____
The instance of Decision that this AuthorityRequirement associates with its containing KnowledgeSource element.
____

a|
____
*requiredInput*: InputData [0.. 1]
____

a|
____
The instance of InputData that this AuthorityRequirement associates with its containing KnowledgeSource element.
____

|===

==== Extensibility

image:extracted-media/media/image56.png[image,width=279,height=196]

[#_Toc87278812 .anchor]##*Figure 6‑19: Extensibility class diagram*

The *DMN* metamodel is aimed to be extensible. This allows *DMN* adopters to extend the specified metamodel in a way that allows them to be still *DMN*-compliant. It provides a set of extension elements, which allows *DMN* adopters to attach additional attributes and elements to standard and existing *DMN* elements. This approach results in more interchangeable models, because the standard elements are still intact and can still be understood by other *DMN* adopters. It's only the additional attributes and elements that MAY be lost during interchange.

A *DMN* extension can be done using two different elements:

[arabic]
. {blank}
. {blank}

ExtensionElementsExtensionAttribute +
ExtensionElements is a container for attaching arbitrary elements from other metamodels to any *DMN* element. ExtensionAttribute allows these attachments to also have name. This allows *DMN* adopters to integrate any metamodel into the *DMN* metamodel and reuse already existing model elements.

===== ExtensionElements

The ExtensionElements element is a container to aggregate elements from other metamodels inside any DMNElement. *Table _23_* presents the attributes and model associations for the ExtensionElements element.

.[#_Toc87278953 .anchor]##*Table 23: ExtensionElements attributes and model associations*
[width="100%",cols="36%,64%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*extensionElement:* Element [0..*]
____

a|
____
The contained Element. This association is not applicable when the XML schema interchange is used, since the XSD mechanism for supporting "any" elements from other namespaces already satisfies this requirement.
____

|===

The ExtensionAttribute element contains an Element or a reference to an Element from another metamodel. An ExtensionAttribute also has a name to define the role or purpose of the associated element. This type is not applicable when the XML schema interchange is used, since the XSD mechanism for supporting "anyAttribute" from other namespaces already satisfies this requirement. *Table _24_* presents the model associations for the ExtensionAttribute element.

.[#_Toc87278954 .anchor]##*Table 24: ExtensionAttribute attributes and model associations*
[width="100%",cols="26%,74%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*name:* string
____

a|
____
The name of the extension attribute.
____

a|
____
*value:* Element [0..1]
____

a|
____
The contained Element. This attribute SHALL NOT be used together with valueRef.
____

a|
____
*valueRef:* Element [0..1]
____

a|
____
A reference to the associated Element. This attribute SHALL NOT be used together with value.
____

|===

=== Examples

____
Examples of DRDs are provided in clause 11.1.3.
____

== Relating Decision Logic to Decision Requirements

=== Introduction

Clause 0 described how the decision requirements level of a decision model – a DRG represented in one or more DRDs – may be used to model the structure of an area of decision making. However, the details of how each decision's outcome is derived from its inputs must be modeled at the decision logic level. This section introduces the principles by which decision logic may be associated with elements in the DRG. Specific representations of decision logic (decision tables and FEEL expressions) are then defined in clauses 8, 9 and 10.

The decision logic level of a decision model in *DMN* consists of one or more value expressions. The elements of decision logic modeled as value expressions include tabular expressions such as decision tables and invocations, and literal (text) expressions such as _age > 30_.

* {blank}
* {blank}
* {blank}

A *literal expression* represents decision logic as text that describes how an output value is derived from its input values. The expression language may, but need not, be formal or executable: examples of literal expressions include a plain English description of the logic of a decision, a first order logic proposition, a Java computer program and a PMML document. Clause10 specifies an executable expression language called *FEEL*. Clause 9 specifies a subset of FEEL (S-FEEL) that is the default language for literal expressions in *DMN* decision tables (clause 8).A *decision table* is a tabular representation of decision logic, based on a discretization of the possible values of the inputs of a decision, and organized into rules that map discretized input values onto discrete output values (see clause 8).An *invocation* is a tabular representation of how decision logic that is represented by a business knowledge model or a decision service is invoked by a decision, or by another business knowledge model. An invocation may also be represented as a literal expression, but usually the tabular representation will be more understandable.Tabular representations of decision logic are called _boxed expressions_ in the remainder of this specification.

All three *DMN* conformance levels include all the above expressions. At *DMN* Conformance Level 1, literal expressions are not interpreted and, therefore, free. At *DMN* Conformance Level 2, literal expressions are restricted to S-FEEL. Clause 10 specifies additional boxed expressions available at *DMN* Conformance Level 3.

Decision logic is added to a decision model by including a value expression component in some of the decision model elements in the DRG:

* {blank}
* {blank}

From a decision logic viewpoint, a decision is a piece of logic that defines how a given question is answered, based on the input data. As a consequence, each *decision* element in a decision model may include a value expression that describes how a decision outcome is derived from its required input, possibly invoking a business knowledge model;From a decision logic viewpoint, a business knowledge model is a piece of decision logic that is defined as a function allowing it to be re-used in multiple decisions. As a consequence, each *business knowledge model* element may include a value expression, which is the body of that function.Another key component of the decision logic level is the *variable*: Variables are used to store values of Decisions and InputData for use in value expressions. InformationRequirements specify variables in scope via reference to those Decisions and InputData, so that value expressions may reference these variables. Variables link information requirements in the DRG to the value expressions at the decision logic level:

* {blank}
* {blank}

From a decision logic viewpoint, an information requirement is a requirement for an externally provided value to be assigned to a free variable in the decision logic, so that a decision can be evaluated. As a consequence, each *information requirement* in a decision model points to a Decision or InputData, which in turn defines a variable that represents the associated data input in the decision’s expression.The variables that are used in the body of the function defined by a business knowledge model element in the DRG must be bound to the information sources in each of the requiring decisions. As a consequence, each *business knowledge model* includes zero or more variables that are the parameters of the function.The third key element of the decision logic level are the *item definitions* that describe the types and structures of data items in a decision model: *input data* elements in the DRG, and *variables* and *value expressions* at the decision logic level, may reference an associated item definition that describes the type and structure of the data expected as input, assigned to the variable or resulting from the evaluation of the expression.

Notice that *knowledge sources* are not represented at the decision logic level: knowledge sources are part of the documentation of the decision logic, not of the decision logic itself.

The dependencies between decisions, required information sources and business knowledge models, as represented by the information and knowledge requirements in a DRG, constrain how the value expressions associated with these elements relate to each other.

As explained above, every decision, input data, and business knowledge model at the DRG level is associated with a variable used at the decision logic level. Each variable that is referenced by a decision’s expression must be associated with a required decision, required input data, or required knowledge. Also, each variable associated with the required decisions, required input data, and required knowledge must be referenced in the decision’s expression.

* {blank}
* {blank}

If a decision requires another decision, the value expression of the required decision assigns the value to the variable for use in evaluating the requiring decision. This is the generic mechanism in *DMN* for composing decisions at the decision logic level.If a decision requires an input data, the value of the variable is assigned the value of the data source attached to the input data at execution time. This is the generic mechanism in *DMN* for instantiating the data requirements for a decision.The input variables of a decision's decision logic must not be used outside that value expression or its component value expressions: the decision element defines the lexical scope of the input variables for its decision logic. To avoid name collisions and ambiguity, the name of a variable must be unique within its scope. When DRG elements are mapped to FEEL, the name of a variable is the same as the (possibly qualified) name of its associated input data or decision, which guarantees its uniqueness.

When DRG elements are mapped to FEEL, all the decisions and input data in a DRG define a _context_, which is the literal expression that represents the logic associated with the decision element and that represents that scope (see 9.3.2.8). The information requirement elements in a decision are _context entries_ in the associated context, where the _key_ is the name of the variable that the information requirement defines, and where the _expression_ is the _context_ that is associated with the required decision or input data element that the information requirement references. The value expression that is associated with the decision as its decision logic is the _expression_ in the _context entry_ that specifies what is the result of the _context_.

In the same way, a business knowledge model element defines the lexical scope of its parameters, that is, of the input variables for its body.

In FEEL, the literal expression and scoping construct that represents the logic associated with a business knowledge model element is a _function definition_ (see 10.3.2.13), where the _formal parameters_ are the names of the parameters in the business knowledge model element, and the expression is the value expression that is the body of the business knowledge model element.

If a business knowledge model element requires one or more other business knowledge models, it must have an explicit value expression that describes how the required business knowledge models are invoked and their results combined or otherwise elaborated.

At the decision logic level, a decision invokes a required business knowledge model by evaluating the business knowledge model's value expression with the parameters bound to its own input value. How this may be achieved depends on how the decision logic is partitioned between the decision and business knowledge models:

* {blank}
* {blank}
* {blank}
* {blank}

If a decision element requires more than one business knowledge element, its value expression must be a literal expression that specifies how the business knowledge model elements are invoked and how their results are combined into the decision's outcome.If a decision does not require any business knowledge models, its value expression must be a literal expression or decision table that specifies the entire decision logic for deriving the output from the inputs.Similarly, if a decision element requires only one business knowledge model element, but the logic of the decision elaborates on the logic of its required business knowledge model, the decision element must have a literal expression that specifies how the business knowledge model's value expression is invoked, and how its result is elaborated to provide the decision's outcome.In all other cases (i.e., when a decision requires exactly one business knowledge model and does not elaborate the logic), the value expression of a decision element may be a value expression of type invocation. In a value expression of type invocation, only the bindings of the business knowledge model parameters to the decisions input data need be specified: the outcome of the decision is the result returned by the business knowledge model's value expression for the values passed to its parameters.The binding of a business knowledge model's parameter is a value expression that specifies how the value passed to that parameter is derived from the values of the input variables of the invoking decision.

=== Notation

==== Expressions

We define a graphical notation for decision logic called *boxed expressions*. This notation serves to decompose the decision logic model into small pieces that can be associated with DRG artifacts. The DRD plus the boxed expressions form a complete, mostly graphical language that completely specifies Decision Models.

In addition to the generic notion of *boxed expression*, this section specifies two kinds of boxed expressions:

* {blank}
* {blank}

*boxed literal expression*,*boxed invocation*.The boxed expression for a decision table is defined in clause 8. Further types of boxed expressions are defined for FEEL, in clause 10.

Boxed expressions are defined recursively, _i.e.,_ boxed expressions can contain other boxed expressions. The top-level boxed expression corresponds to the decision logic of a single DRG artifact. This boxed expression SHALL have a name box that contains the name of the DRG artifact. The name box may be attached in a single box on top, as shown inFigure 7‑1:

image:extracted-media/media/image57.emf[image,width=255,height=115]

[#_Toc87278813 .anchor]##*Figure 7‑1: Boxed Expression*

Alternatively, the name box and expression box can be separated by white space and connected on the left side with a line, as shown in Figure 7‑2:

image:extracted-media/media/image58.wmf[image,width=290,height=160]

[#_Toc87278814 .anchor]##*Figure 7‑2: Boxed expression with separated name and expression boxes*

Name is the only visual link defined between DRD elements and boxed expressions. Graphical tools are expected to support appropriate graphical links, for example, clicking on a decision shape opens a decision table. How the boxed expression is visually associated with the DRD element is left to the implementation.

==== Boxed literal expression

In a boxed expression, a literal expression is represented by its text. However, two notational conventions are provided to improve the readability of boxed literal expressions: typographical string literals and typographical date and time literals.

===== Typographical string literals

A string literal such as "DECLINED" can be represented alternatively as the italicized literal _DECLINED_. For example, Figure 7‑3 is equivalent to Figure 7‑4:

image:extracted-media/media/image59.wmf[image,width=454,height=181]

[#_Toc87278815 .anchor]##*Figure 7‑3: Decision table with italicized literals*

image:extracted-media/media/image60.wmf[image,width=464,height=191]

[#_Toc87278816 .anchor]##*Figure 7‑4: Decision table with string literals*

To avoid having to discern whether (e.g.,) _HIGH, DECLINE_ is "HIGH," "DECLINE," or "HIGH, DECLINE," typographical string literals SHALL be free of commas ("," characters). FEEL typographical string literals SHALL conform to grammar rule 22 (name).

===== Typographical date and time literals

A date, time, date and time, or duration expression such as date("2013-08-09") can be represented alternatively as the bold italicized literal *_2013-08-09_.* The literal SHALL obey the syntax specified in clauses 10.3.2.3.4, 10.3.2.3.5, and 10.3.2.3.7.

==== Boxed invocation

An invocation is a container for the parameter bindings that provide the context for the evaluation of the body of a business knowledge model.

The representation of an invocation is the name of the business knowledge model with the parameters’ bindings explicitly listed.

As a boxed expression, an invocation is represented by a box containing the name of the business knowledge model to be invoked, and boxes for a list of bindings, where each binding is represented by two boxed expressions on a row: the box on the left contains the name of a parameter, and the box on the right contains the binding expression, that is the expression whose value is assigned to the parameter for the purpose of evaluating the invoked business knowledge model (see Figure 7‑5).

image:extracted-media/media/image61.wmf[image,width=309,height=210]

[#_Toc87278817 .anchor]##*Figure 7‑5: Boxed invocation*

The invoked business knowledge model is represented by the name of the business knowledge model. Any other visual linkage is left to the implementation.

=== Metamodel

An important characteristic of decisions and business knowledge models is that they may contain an expression that describes the logic by which a modeled decision shall be made, or pieces of that logic.

The class Expression is the abstract superclass for all expressions that are used to describe complete or parts of decision logic in *DMN* models and that return a single value when interpreted (clause 7.3.1). Here “single value” possibly includes structured data, such as a decision table with multiple output clauses.

*DMN* defines three concrete kinds of Expression: LiteralExpression, DecisionTable (see 8) and Invocation.

An expression may reference variables, such that the value of the expression, when interpreted, depends on the values assigned to the referenced variables. The class InformationItem is used to model variables in expressions.

The value of an expression, like the value assigned to a variable, may have a structure and a range of allowable values. The class ItemDefinition is used to model data structures and ranges.

image:extracted-media/media/image62.png[image,width=547,height=442]

[#_Toc87278818 .anchor]##*Figure 7‑6: Expression class diagram*

==== Expression metamodel

An important characteristic of decisions and business knowledge models, is that they may contain an expression that describes the logic by which a modeled decision shall be made, or pieces of that logic.

Expression is an abstract specialization of DMNElement, from which it inherits the optional id, description and label attributes.

An instance of Expression is a component of a Decision element, of a BusinessKnowledgeModel element, or of an ItemDefinition element, or it is a component of another instance of Expression, directly or indirectly.

An Expression references zero or more variables implicitly by using their names in its expression text. These variables, which are instances of InformationItem, are lexically scoped, depending on the Expression type. If the Expression is the logic of a Decision, the scope includes that Decision's requirements. If the Expression is the body of the encapsulatedLogic of a BusinessKnowledgeModel, the scope includes the FunctionDefinition's parameters and the BusinessKnowledgeModel's requirements. If the Expression is the value of a ContextEntry, the scope includes the previous entries in the Context. An instance of Expression references an optional typeRef, which points to either a base type in the default typeLanguage, a custom type specified by an ItemDefinition, or an imported type. The referenced type specifies the Expression's range of possible values. If an instance of Expression that defines the output of a Decision element includes a typeRef, the referenced type SHALL be the same as the type of the containing Decision element.

An instance of Expression can be interpreted to derive a single value from the values assigned to its variables. How the value of an Expression element is derived from the values assigned to its variablesdepends on the concrete kind of the Expression. The ItemDefinition element specializes NamedElement and it inherits its attributes and model associations. *Table _26_* presents the additional attributes and model associations of the ItemDefinition element.

Expression inherits from the attributes and model associations of DMNElement.

==== UnaryTests Metamodel

The class UnaryTests is used to model a boolean test where the argument to be tested is implicit or denoted with a ?, and whose value is specified by text in some specified expression language.

UnaryTests is a concrete subclass of Expression.

An instance of UnaryTests inherits an optional typeRef from Expression, which SHALL NOT be used. An instance of UnaryTests also has an optional text, which is a String, and an optional expressionLanguage, which is a String that identifies the expression language of the text. If no expressionLanguage is specified, the expression language of the text is the expressionLanguage that is associated with the containing instance of Definitions. The expressionLanguage SHALL be specified in a URI format. The default expression language is FEEL. When the expression language is FEEL, the text must conform to grammar rule 15 in section 10.3.1.2.

*Table _25_* presents additional attributes and model associations of the UnaryTests element.

.[#_Toc87278955 .anchor]##*Table 25: UnaryTests attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
|*Attribute* |*Description*
|text: string[0..1] a|
____
The text of this UnaryTests. It SHALL be a valid expression in the expressionLanguage
____

|expressionLanguage: anyURI[0..1] a|
____
This attribute identifies the expression language used in this UnaryTests. This value overrides the expression language specified for the containing instance of DecisionRequirementDiagram. The language SHALL be specified in a URI format.
____

|===

==== ItemDefinition metamodel

The inputs and output of decisions, business knowledge models, and decision services, and the output of input data (all DRGElements) are data items whose value, at the logic level, is assigned to variables or represented by Expressions.

An important characteristic of data items in decision models is their structure. *DMN* does not require a particular format for this data structure, but it does designate a subset of FEEL as its default.

The class ItemDefinition is used to model the structure and the range of values of the input and the outcome of decisions.

As a concrete specialization of NamedElement, an instance of ItemDefinition has a name and an optional id and description. The name of an ItemDefinition element SHALL be distinct from the names of other ItemDefinitions and Imports within the same model.

The default type language for all elements can be specified in the Definitions element using the typeLanguage attribute. For example, a typeLanguage value of http://www.w3.org/2001/XMLSchema[[.underline]#http://www.w3.org/2001/XMLSchema#]” indicates that the data structures used by elements within that Definitions are in the form of XML Schema types. If unspecified, the default is FEEL.

Notice that the data types that are built-in in the typeLanguage that is associated with an instance of Definitions need not be redefined by ItemDefinition elements contained in that Definitions element: they are considered imported and can be referenced in *DMN* elements within the Definitions element.

The type language can be overridden locally using the typeLanguage attribute in the ItemDefinition element.

Notice, also, that the data types and structures that are defined at the top level in a data model that is imported using an Import element that is associated with an instance of Definitions need not be redefined by ItemDefinition elements contained in that Definitions element: they are considered imported and can be referenced in *DMN* elements within the Definitions element.

An ItemDefinition element MAY have a typeRef, which is a string that references, as a qualified name, either an ItemDefinition in the current instance of Definitions or a built-in type in the specified typeLanguage or a type defined in an imported DMN, XSD, or other document. In the latter case, the external document SHALL be imported in the Definitions element that contains the instance of ItemDefinition, using an Import element specifying both the namespace value and its name when used a qualifier. For example, in the case of data structures contributed by an XML schema, an Import would be used to specify the file location of that schema, and the typeRef attribute would reference the type or element definition in the imported schema. If the type language is FEEL the built-in types are the FEEL built-in data types: _number_, _string_, _boolean_, _days and time duration_, _years and months duration_, _date, time_, _date and time_ and _Any_. A typeRef referencing a built-in type SHALL omit the prefix.

An ItemDefinition element may restrict the values that are allowed from typeRef, using the allowedValues attribute. The allowedValues are an instance of unaryTests that specifies the allowed values or ranges of allowed values within the domain of the typeRef. The type of the allowed values SHALL be consistent with the containing ItemDefinition element. If an ItemDefinition element contains one or more allowedValues, the allowedValues specifies the complete range of values that this ItemDefinition represents. If an ItemDefinition element does not contain allowedValues, its range of allowed values is the full range of the referenced typeRef. In cases where the values that an ItemDefinition element represents are collections of values in the allowed range, the multiplicity can be projected into the attribute isCollection. The default value for this attribute is _false_.

An alternative way to define an instance of ItemDefinition is as a composition of ItemDefinition elements. An instance of ItemDefinition may contain zero or more itemComponent, which are themselves ItemDefinitions. Each itemComponent in turn may be defined by either a typeRef and allowedValues or a nested itemComponent. In this way, complex types may be defined within DMN. The name of an itemComponent (nested ItemDefinition) must be unique within its containing ItemDefinition or itemComponent.

An alternative way to define an instance of ItemDefinition is by specifying a FunctionItem element, which defines the signature of a function: the parameters and the output of the function. An instance of ItemDefinition may contain at most one FunctionItem. A FunctionItem may contain zero or more parameters defined as InformationItems and one output type defined as a typeRef. The names of the parameters of a FunctionItem are unique.

An ItemDefinition element SHALL be defined using only one of the alternative ways:

* {blank}
* {blank}
* {blank}

reference to a built-in or imported typeRef, possibly restricted with allowedValues;composition of ItemDefinition elementsfunction signature element. +
The ItemDefinition element specializes NamedElement and it inherits its attributes and model associations. *Table _26_* presents the additional attributes and model associations of the ItemDefinition element.

____
____

.[#_Toc87278956 .anchor]##*Table 26: ItemDefinition attributes and model associations*
[width="100%",cols="42%,58%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*typeRef*: String [1]
____

a|
____
This attribute identifies by namespace-prefixed name the base type of this ItemDefinition.
____

a|
____
*typeLanguage*: String [0..1]
____

a|
____
This attribute identifies the type language used to specify the base type of this ItemDefinition. This value overrides the type language specified in the Definitions element. The language SHALL be specified in a URI format.
____

a|
____
*allowedValues*: UnaryTests [0..1]
____

a|
____
This attribute lists the possible values or ranges of values in the base type that are allowed in this ItemDefinition.
____

a|
____
*itemComponent*: ItemDefinition [*]
____

a|
____
This attribute defines zero or more nested ItemDefinitions that compose this ItemDefinition.
____

a|
____
*IsCollection*: Boolean
____

a|
____
Setting this flag to _true_ indicates that the actual values defined by this ItemDefinition are collections of allowed values. The default is _false_.
____

a|
____
functionItem: FunctionItem [0..1]
____

a|
____
This attribute describes an optional FunctionItem that compose this ItemDefinition.
____

|===

.[#_Toc87278957 .anchor]##*Table 27: FunctionItem attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*outputTypeRef*: String [0..1]
____

a|
____
Reference to output type of function
____

a|
____
*parameters*: InformationItem [0. .*]
____

a|
____
Function parameters as InformationItems
____

|===

image:extracted-media/media/image63.png[image,width=630,height=339]

[#_Toc87278819 .anchor]##*Figure 7‑7: ItemDefinition class diagram*

==== InformationItem metamodel

The class InformationItem is used to model variables at the decision logic level in decision models.

InformationItem is a concrete subclass of NamedElement, from which it inherits the id, and optional name, description, and label attributes, except that an InformationItem element SHALL have a name attribute, which is the name that is used to represent it in other Expression elements. The name of an InformationItem element SHALL be unique within its scope.

Variables represent values that result from a decision, are assigned to input data by an external data source, or are passed to a module of decision logic that is defined as a function (and that is represented by a business knowledge model element). In the first or second case, a variable may be referenced by other dependent decisions by means of their information requirements. In the third case, a variable is one of the parameters of the function that is the realization, at the decision logic level, of a business knowledge model element.

A variable representing an instance of Decision or InputData referenced by an InformationRequirement SHALL be referenced by the value expression of the decision logic in the Decision element that contains the InformationRequirement element. A parameter in an instance of BusinessKnowledgeModel SHALL be a variable in the value expression of that BusinessKnowledgeModel element.

An InformationItem element contained in a Decision is assigned the value of the Decision's value expression.

* {blank}
* {blank}
* {blank}

An InformationItem element that is a parameter in a FunctionDefinition is assigned a value by a Binding element as part of an instance of Invocation.An InformationItem element contained in an InputData is assigned a value by an external data source that is attached at runtime.An InformationItem element contained in a ContextEntry is assigned a value by the ContextEntry's value expression.In any case, the datatype indicated by the typeRef that is associated with an instance of InformationItem SHALL be compatible with the datatype that is associated with the *DMN* model element from which it takes its value. InformationItem inherits all of the attributes and model associations of NamedElement. *Table _28_* presents the additional attributes and model associations of the InformationItem element.

.[#_Toc87278958 .anchor]##*Table 28: InformationItem attributes and model associations*
[width="100%",cols="44%,56%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*/valueExpression*: Expression [0..1]
____

a|
____
The Expression whose value is assigned to this InformationItem. This is a derived attribute.
____

a|
____
*typeRef*: String [1]
____

a|
____
Qualified name of the type of this InformationItem.
____

|===

==== Literal expression metamodel

The class LiteralExpression is used to model a value expression whose value is specified by text in some specified expression language.

LiteralExpression is a concrete subclass of Expression, from which it inherits the id and typeRef attributes.

An instance of LiteralExpression has an optional text, which is a String, and an optional expressionLanguage, which is a String that identifies the expression language of the text. If no expressionLanguage is specified, the expression language of the text is the expressionLanguage that is associated with the containing instance of Definitions. The expressionLanguage SHALL be specified in a URI format. The default expression language is FEEL.

As a subclass of Expression, each instance of LiteralExpression has a value. The text in an instance of LiteralExpression determines its value, according to the semantics of the LiteralExpression’s

expressionLanguage. The semantics of *DMN* decision models as described in this specification applies only if the text of all the instances of LiteralExpression in the model are valid expressions in their associated expression language.

An instance of LiteralExpression may include importedValues, which is an instance of a subclass Import that identifies where the text of the LiteralExpression is located. importedValues is an expression that selects text from an imported document. An instance of LiteralExpression SHALL NOT have both a text and importedValues. The importType of the importedValues identifies the type of document containing the imported text and SHALL be consistent with the expressionLanguage of the LiteralExpression element. The expressionLanguage of the importedValues element identifies how the imported text is selected from the imported document. For example, if the importType indicates an XML document, the expressionLanguage of importedValues could be XPATH 2.0.

LiteralExpression inherits of all the attributes and model associations of Expression. *Table _29_* presents the additional attributes and model associations of the LiteralExpression element.

.[#_Toc87278959 .anchor]##*Table 29: LiteralExpression attributes and model associations*
[width="100%",cols="41%,59%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*text:* string [0..1]
____

a|
____
The text of this LiteralExpression. It SHALL be a valid expression in the express ionLanguage.
____

a|
____
*expressionLanguage:* anyURI [0.. 1]
____

a|
____
This attribute identifies the expression language used in this LiteralExpression. This value overrides the expression language specified for the containing instance of DecisionRequirementDiagram. The language SHALL be specified in a URI format.
____

a|
____
*importedValues:* ImportedValues [0..1]
____

a|
____
The instance of ImportedValues that specifies where the text of this LiteralExpression is located.
____

|===

==== Invocation metamodel

Invocation is a mechanism that permits the evaluation of one value expression – the invoked expression _–_ inside another value expression – the invoking expression – by binding locally the input variables of the invoked expression to values inside the invoking expression. In an invocation, the input variables of the invoked expression are usually called: _parameters_. Invocation permits the same value expression to be re-used in multiple expressions, without having to duplicate it as a sub-expression in all the using expressions.

The class Invocation is used to model invocations as a kind of Expression: Invocation is a concrete specialization of Expression.

An instance of Invocation is made of zero or more binding, which are instances of Binding, and model how the bindingFormulas are bound to the formalParameters of the invoked function. The formalParameters of a FunctionDefinition are InformationItems and the parameters of the Bindings are InformationItems. The binding is by matching the InformationItem names.

An Invocation contains a calledFunction, an Expression, which must evaluate to a function. Most commonly, it is a LiteralExpression naming a BusinessKnowledgeModel.

The value of an instance of Invocation is the value of the associated calledFunction's body, with its formalParameters assigned values at runtime per the bindings in the Invocation.

Invocation MAY be used to model invocations in decision models, when a Decision element has exactly one knowledgeRequirement element, and when the decisionLogic in the Decision element consists only in invoking the BusinessKnowledgeModel element that is referenced by that requiredKnowledge and a more complex value expression is not required.

Using Invocation instances as the decisionLogic in Decision elements permits the re-use of the encapsulatedLogic of a BusinessKnowledgeModel as the logic for any instance of Decision that requires that BusinessKnowledgeModel, where each requiring Decision element specifies its own bindings for the encapsulatedLogic's parameters.

The calledFunction that is associated with the Invocation element SHALL BE the encapsultedLogic of the BusinessKnowledgeModel element that is required by the Decision element that contains the Invocation. The Invocation element SHALL have exactly one binding for each parameter in the BusinessKnowledgeModel's encapsulatedLogic.

Invocation inherits of all the attributes and model associations of Expression. *Table _30_* presents the additional attributes and model associations of the Invocation element.

.[#_Toc87278960 .anchor]##*Table 30: Invocation attributes and model associations*
[width="100%",cols="41%,59%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*calledFunction:* Expression [1]
____

a|
____
An expression whose value is a function.
____

a|
____
*binding:* Binding [*]
____

a|
____
This attribute lists the instances of Binding used to bind the formalParameters of the calledFunction in this Invocation.
____

|===

==== Binding metamodel

The class Binding is used to model, in an Invocation element, the binding of the calledFunction's formalParameters to values.

A Binding is made of one bindingFormula, which is an Expression, and of one parameter, which is an InformationItem.

The parameter names in the Binding elements SHALL be a subset of the formalParameters of the calledFunction.

When the Invocation element is executed, each InformationItem element that is referenced as a parameter by a binding in the Invocation element is assigned, at runtime, the value of the bindingFormula.

*Table _31_* presents the attributes and model associations of the Binding element.

.* +
*[#_Toc87278961 .anchor]##*Table 31: Binding attributes and model associations*
[width="100%",cols="41%,59%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*parameter:* InformationItem
____

a|
____
The InformationItem on which the calledFunction of the owning instance of Invocation depends that is bound by this Binding.
____

a|
____
*bindingFormula:* Expression [0..1]
____

a|
____
The instance of Expression to which the parameter in this Binding is bound when the owning instance of Invocation is evaluated.
____

|===

== 

=== Decision TableIntroduction

One of the ways to express the decision logic corresponding to the DRD decision artifact is as a decision table. A decision table is a tabular representation of a set of related input and output expressions, organized into rules indicating which output entry applies to a specific set of input entries. The decision table contains all (and only) the inputs required to determine the output. Moreover, a complete table contains all possible combinations of input values (all the rules).

Decision tables and decision table hierarchies have a proven track record in decision logic representation. It is one of the purposes of *DMN* to standardize different forms and types of decision tables.

A decision table consists of:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

An information item name: the name of an InformationItem, if any, for which the decision table is its value expression. This will usually be the name of the Decision or Business Knowledge Model for which the decision table provides the decision logic.A list of input clauses (zero or more). Each input clause is made of an input expression and optional allowed values for the input entries that correspond to the clause. The input entries are contained in the rules, and the __i__th input entry corresponds to the _i_^th^ input clause.A list of output clauses (one or more). Each output clause is made of a name and optional allowed values for the output entries that correspond to the clause. The output entries are contained in the rules, and the ith output entry corresponds to the ith output clause. A single output clause has no name. Two or more output clauses describe a decision table that returns a context for each hit with an entry for each output clause. Each of the multiple output clauses SHALL be named.A set of outputs (one or more). A single output has no name, only a value. Two or more outputs are called output components. Each output component SHALL be named. Each output (component) SHALL specify an output entry for each rule. The specification of output component name (if multiple outputs) and all output entries is referred to as an output clause.A list of annotation clauses (zero or more). Each annotation clause is made of a name. Each annotation SHALL be named as part of a rule annotation clause. The annotation entries are contained in the rules, and the ith annotation entry corresponds to the i^th^ annotation clause.A list of rules (one or more) in rows or columns of the table (depending on orientation), where each rule is composed of the specific input entries, output entries and optional rule annotations of the table row (or column). If the rules are expressed as rows, the columns are clauses, and vice versa.

image:extracted-media/media/image64.wmf[image,width=650,height=334]

[#_Toc87278820 .anchor]##*Figure 8‑1: Decision table example (vertical orientation: rules as columns)*

image:extracted-media/media/image65.wmf[image,width=650,height=325]

[#_Toc87278821 .anchor]##*Figure 8‑2: Decision table example (horizontal orientation: rules as rows)*

image:extracted-media/media/image66.wmf[image,width=650,height=309]

[#_Toc87278822 .anchor]##*Figure 8‑3: Decision table example (vertical orientation, multiple output components)*

image:extracted-media/media/image67.wmf[image,width=650,height=286]

[#_Toc87278823 .anchor]##*Figure 8‑4: Decision table example (horizontal orientation, multiple output components)*

The decision table shows the rules in a shorthand notation by arranging the entries in table cells. This shorthand notation shows all inputs in the same order in every rule and therefore has a number of readability and verification advantages.

____
For example:
____

.[#_Toc87278962 .anchor]##*Table 32: DecisionTable attributes and model associations*
[width="99%",cols="39%,38%,23%",options="header",]
|===
a|
____
Customer
____

a|
____
OrderSize
____

a|
____
Discount
____

a|
____
_Business_
____

a|
____
<10
____

a|
____
0.10
____

|===

reads as:

____
*If* Customer = “Business” *and* OrderSize < 10 *then* Discount = 0.10
____

In general, this is expressed as:

.[#_Toc87278963 .anchor]##*Table 33: InputClause attributes and model associations*
[width="100%",cols="36%,36%,28%",options="header",]
|===
a|
____
input expression 1
____

a|
____
input expression 2
____

a|
____
Output label
____

a|
____
input entry a
____

a|
____
input entry b
____

a|
____
output entry c
____

|===

____
____

The three highlighted cells in the decision table fragment above represent the following rule:

____
*If* the value of input expression 1 satisfies input entry a

*and* the value of input expression 2 satisfies input entry b

*then* the rule _matches_ and the result of the decision table is output entry c.
____

An input expression value _satisfies_ an input entry if the value is equal to the input entry, or belongs to the list of values indicated by the input entry (e.g., a list or a range), or one of the expressions in the input entry evaluates to true. For the complete specification of the input entry satisfaction conditions, please refer to section 8.3.3. If the input entry is ‘-’ (meaning _irrelevant_), every value of the input expression satisfies the input entry and that particular input is irrelevant in the specified rule.

A rule _matches_ if the value of every input expression satisfies the corresponding input entry. If there are no input entries, any rule matches.

The list of rules expresses the logic of the decision. For a given set of input values, the matching rule (or rules) indicate the resulting value for the output name. If rules _overlap_, multiple rules can match and a _hit policy_ indicates how to handle the multiple matches.

If two input entries of the same input expression share no values, the entries (cells) are called _disjoint_. If there is an intersection, the entries are called _overlapping_ (or even equal). ‘Irrelevant’ (‘-’) overlaps with any input entry of the input expression.

Two rules are overlapping if all corresponding input entries are _overlapping_. A specific configuration of input data may then match the two rules.

Two rules are _disjoint_ (non-overlapping) if at least one pair of corresponding input expressions is disjoint. No specific configuration of input data will match the two rules.

If tables are allowed to contain overlapping rules, the table hit policy indicates how overlapping rules have to be handled and which is the resulting value(s) for the output name, in order to avoid inconsistency.

=== Notation

This section builds on the generic notation for decision logic and boxed expressions defined in clause 7.2. A decision table representation standardizes:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

The orientation (rules as rows, columns or crosstab), as shown by the table.Placement of inputs, outputs and (optional) allowed values in standard locations on a grid of cells. Each input expression is optionally associated with unary tests restricting the allowed input values. In this text the optional cells with allowed values are indicated in inverse. Each output (component) is optionally associated with allowed values. In this text the optional allowed output values are indicated in inverse.Line style and optional use of color.The contents of specific rule input and output entry cells.The hit policy, indicating how to interpret overlapping input combinations.Placement of information item name, hit policy (H) and rule numbers as indicated in Figure 8‑5, Figure 8‑7 and Figure 8‑9. Rule numbers are consecutive natural numbers starting at 1. Rule numbering is required for tables with hit indicator F (first) or R (rule order), because the meaning depends on rule sequence. Crosstab tables have no rule numbers. Rule numbering is optional for other table types.Input expressions, input values, output values, input entries and output entries can be any text (e.g., natural language, formal language, pseudo-code). Implementations claiming level 2 or 3 conformance SHALL support (S-)FEEL syntax. Implementations claiming level 1 conformance are not required to interpret the expressions. To avoid misinterpretation (e.g., when expressions are not meant to be valid (S-)FEEL but may conflict with the look and feel of (S-)FEEL syntax), conformant implementations SHOULD indicate when the input expression is not meant to be interpreted by using the URI: "http://www.omg.org/spec/DMN/uninterpreted/20140801[[.underline]#http://www.omg.org/spec/DMN/uninterpreted/20140801#]".

==== Line style and color

Line style is normative. There is a double line between the input clauses and output clauses, continuing between the input entries and the output entries. There is also a double line between the output clauses and the annotation clauses, continuing between the output entries and the annotation entries. These two double lines are parallel to each other. There is a third double line, that intersects at right angles with the previous two, between input clauses and the input entries, continuing between the output clauses and the output entries, and continuing between the annotation clauses and the annotation entries. All other cells are separated by a single line.

Color is suggested, but does not influence the meaning. It is considered good practice to use different colors for the input clauses, the output clauses, and the annotation clauses, and another (or no) color for the input, output, and annotation entries. In section 8:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

Blue is suggested for input expressionsPink is suggested for output labels and (in crosstab tables) output entriesGreen is suggested for annotation labelsRed is used to highlight incorrect usageGrey is used to indicate optional cells

==== Table orientation

Depending on size, a decision table can be presented horizontally (rules as rows), vertically (rules as columns), or crosstab (rules composed from two input dimensions). Crosstab tables can only have the default hit policy (see later).

Decision table inputs and outputs should not be mixed. In a horizontal table, all input columns SHALL be represented on the left of all output columns. In a vertical table, all the input rows SHALL be represented above all output rows. In a crosstab, all the output cells SHALL be in the bottom-right part of the table.

The table SHALL be arranged in one of the following ways (see Figure 8‑5, Figure 8‑7, Figure 8‑9). Cells indicated in inverse are optional.

The input cell entry ‘-’ means ‘irrelevant’. HC is a placeholder for hit policy indicator (e.g., U, A, F, ...).

image:extracted-media/media/image68.wmf[image,width=531,height=170]

[#_Toc87278824 .anchor]##*Figure 8‑5: Rules as rows – schematic layout*

image:extracted-media/media/image69.wmf[image,width=514,height=185]

[#_Toc87278825 .anchor]##*Figure 8‑6: Rules as rows – example*

image:extracted-media/media/image70.wmf[image,width=510,height=167]

[#_Toc87278826 .anchor]##*Figure 8‑7: Rules as columns – schematic layout*

image:extracted-media/media/image71.wmf[image,width=536,height=138]

[#_Toc87278827 .anchor]##*Figure 8‑8: Rules as columns – example*

image:extracted-media/media/image72.wmf[image,width=396,height=168]

[#_Toc87278828 .anchor]##*Figure 8‑9: Rules as crosstab - schematic layout (optional input and output values not shown)*

image:extracted-media/media/image73.wmf[image,width=496,height=136]

[#_Toc87278829 .anchor]##*Figure 8‑10: Rules as crosstab - simplified example with only two inputs*

image:extracted-media/media/image74.wmf[image,width=491,height=160]

[#_Toc87278830 .anchor]##*Figure 8‑11: Rules as crosstab - example with three inputs*

Crosstab tables with more than two inputs are possible (as shown in Figure 8‑11).

==== Input expressions

Input expressions are usually simple, for example, a name (e.g., CustomerStatus) or a test (e.g. Age<25). The order of input expressions is not related to any execution order in implementation.

==== Input values

Input expressions may be expected to result in a limited number or a limited range of values. It is important to model these expected input values, because a decision table will be considered complete if its rules cover all combinations of expected input values for all input expressions.

Regardless of how the expected input values are modeled, input values SHOULD be exclusive and complete. Exclusive means that input values are disjoint. Complete means that all relevant input values from the domain are present.

For example, the following two input value ranges overlap: <5, <10. The following two ranges are incomplete: <5, >5. The list of input values is optional. If provided, it is a list of unary tests that must be satisfied by the corresponding input.

==== Information Item names, output labels, and output component names

A decision table with multiple output components SHALL specify a name for each output component.

A decision table that is the value expression of an InformationItem (e.g., a Decision's logic or a boxed Invocation's binding formula) SHALL specify the name of the InformationItem as its Information Item name. A decision table that is not contained in another boxed expression shall place the Information Item name in a name box just above and adjoining the table.

A decision table that is contained in another boxed expression may use the containing expression for its Information Item name. For example, the Information Item name for a decision table bound to a function parameter is the name of the function parameter. Or, to save space, the Information Item name box may be omitted and the Output label used instead.

Output values

The output entries of a decision table are often drawn from a list of output values.

The list of output values is optional. If provided, it is a list restricting output entries to the given list of values.

When the hit policy is P (priority), meaning that multiple rules can match, but only one hit should be returned, the ordering of the list of output values is used to specify the (decreasing) priority.

The ordering of the list of output values is also used when the hit policy is output order.

==== Multiple outputs

The decision table can show a compound output (see Figure 8‑12, Figure 8‑13 and Figure 8‑14).

image:extracted-media/media/image75.wmf[image,width=508,height=144]

[#_Toc87278831 .anchor]##*Figure 8‑12: Horizontal table with multiple output components*

image:extracted-media/media/image76.wmf[image,width=492,height=177]

[#_Toc87278832 .anchor]##*Figure 8‑13: Vertical table with multiple output components*

image:extracted-media/media/image77.wmf[image,width=490,height=170]

[#_Toc87278833 .anchor]##*Figure 8‑14: Crosstab with multiple output components*

==== Input entries

Rule input entries are unary tests (grammar rule 15).

A dash symbol (‘-’) can be used to mean any input value, _i.e.,_ the input is irrelevant for the containing rule.

The input entries in a unary test SHOULD be ‘-’ or a subset of the input values specified. For example, if the input values for input ‘Age’ are specified as _[0..120]_, then an input entry of _<0_ SHOULD be reported as invalid.

Tables containing at least one ‘-’ input entry are called _contracted_ tables. The others are called _expanded_.

Tables where every input entry is _true, false, or ‘-_’ are historically called _limited-entry_ tables, but there is no need to maintain this restriction.

Evaluation of the input expressions in a decision table does not produce side-effects that influence the evaluation of other input expressions. This means that evaluating an expression or executing a rule should not change the evaluation of other expressions or rules of the same table. This is particularly important in first hit tables where the rules are evaluated in a predefined sequence: evaluating or executing a rule should not influence other rules.

==== Merged input entry cells

Adjacent input entry cells from different rules, with the same content and same (or no) prior cells can be merged, as shown in Figure 8-15 and Figure 8-16. Rule output cells cannot be merged (except in crosstabs).

image:extracted-media/media/image78.wmf[image,width=500,height=150]

[#_Toc87278834 .anchor]##*Figure 8‑15: Merged rule input cells allowed*

image:extracted-media/media/image79.wmf[image,width=500,height=173]

[#_Toc87278835 .anchor]##*Figure 8‑16: Merged rule input cells not allowed*

==== Output entry

A rule output entry is an expression.

Rule output cells cannot be merged (except in crosstabs, where adjacent output cells with the same content can be merged).

*Shorthand notation*

In vertical (rules as columns) tables with a single output name (equal to the information item name), a shorthand notation may be used to indicate: output value applies (‘X’) or does not apply (‘-’), as is common practice in decision tables.

Because there can be only one output entry for an output name, every rule must indicate no more than one ‘X’. The other output entries must contain ‘-’.

The table in Figure 8‑17 is shorthand notation for the table in Figure 8‑18. It is called shorthand, because the output entries need not be (re-)written in every column, but are indicated with a one-character notation (‘X’ or ‘-’), thereby saving space in vertical tables, which tend to expand in width as the number of rules increases. The output values are written only once, before the rules, in the output expression part.

If an information item name is provided, and there is only one output name (which has to be equal to the information item name), the output name is optional.

image:extracted-media/media/image80.wmf[image,width=369,height=167]

[#_Toc87278836 .anchor]##*Figure 8‑17: Shorthand notation for vertical tables (rules as columns)*

image:extracted-media/media/image81.wmf[image,width=444,height=125]

[#_Toc87278837 .anchor]##*Figure 8‑18: Full notation for vertical tables (rules as columns)*

==== Hit policy

A decision table normally has several rules. As a default, rules do not overlap. If rules overlap, meaning that more than one rule may match a given set of input values, the hit policy indicator is required in order to recognize the table type and unambiguously understand the decision logic. The hit policy can be used to check correctness at design-time.

The hit policy specifies what the result of the decision table is in cases of overlapping rules, i.e., when more than one rule matches the input data. For clarity, the hit policy is summarized using a single character in a particular decision table cell. In horizontal tables this is the top-left cell (Figure 8‑2) and in vertical tables this is the bottom-left cell (Figure 8‑1).The character is the initial letter of the defined hit policy (**U**nique, **A**ny, **P**riority, **F**irst, **C**ollect, **O**utput order or **R**ule order). Crosstab tables are always Unique and need no indicator.

The hit policy SHALL default to Unique, in which case the hit indicator is optional. Decision tables with the Unique hit policy SHALL NOT contain overlapping rules.

Tools may support only a nonempty subset of hit policies, but the table type SHALL be clear and therefore the hit policy indication is mandatory, except for the default unique tables. Unique tables SHALL always be supported.

*Single and multiple hit tables*

A single hit table shall return the output of one rule only; a multiple hit table may return the output of multiple rules (or a function of the outputs, e.g., sum of values). If rules are allowed to overlap, the hit policy indicates how overlapping rules have to be interpreted.

The initial letter for hit policy also identifies if a table is single hit or multiple hits.

A single hit table may or may not contain overlapping rules, but returns the output of one rule only. In case of overlapping rules, the hit policy indicates which of the matching rules to select. Some restrictions apply to tables with compound outputs.

Regardless of whether a single or multiple hit policy is used, some columns in a decision table may be designated as _rule annotations_. Rule Annotations contain text that is not returned as part of the expression results, and they are ignored for purposes of the hit policy validations described below. Although there is no standard mechanism to access the annotations of the matched rules in a decision table at execution time, implementations may use the annotations for auditing, debugging, logging, documentation, analytics, consumption by down-stream systems, or for other purposes.

*Single hit policies* for single output decision tables are:

[arabic]
. {blank}
. {blank}
. {blank}
. {blank}

**U**nique: no overlap is possible and all rules are disjoint. Only a single rule can be matched. This is the default.**A**ny: there may be overlap, but all the matching rules show equal output entries for each output (ignoring rule annotations), so any match can be used. If the output entries are non-equal (ignoring rule annotations), the hit policy is incorrect and the result is undefined.**P**riority: multiple rules can match, with different output entries. This policy returns the matching rule with the highest output priority. Output priorities are specified in the ordered list of output values, in decreasing order of priority. Note that priorities are independent from rule sequence.**F**irst: multiple (overlapping) rules can match, with different output entries. The first hit by rule order is returned (and evaluation can halt). This is still a common usage, because it resolves inconsistencies by forcing the first hit. However, first hit tables are not considered good practice because they do not offer a clear overview of the decision logic. It is important to distinguish this type of table from others because the meaning depends on the order of the rules. The last rule is often the catch-remainder. Because of this order, the table is hard to validate manually and therefore has to be used with care. +
A multiple hit table may return output entries from multiple rules. The result will be a list of rule outputs or a simple function of the outputs.

*Multiple hit policies* for single output decision tables can be:

[arabic, start=5]
. {blank}
. {blank}
. {blank}

**O**utput order: returns all hits in decreasing output priority order. Output priorities are specified in the ordered list of output values in decreasing order of priority.**R**ule order: returns all hits in rule order. Note: the meaning may depend on the sequence of the rules.**C**ollect: returns all hits in arbitrary order. An operator (‘+’, ‘<’, ‘>’, ‘#’) can be added to apply a simple function to the outputs. If no operator is present, the result is the list of all the output entries.Collect operators are:

[loweralpha]
. {blank}
. {blank}
. {blank}
. {blank}

+ (sum): the result of the decision table is the sum of all the outputs.< (min): the result of the decision table is the smallest value of all the outputs.> (max): the result of the decision table is the largest value of all the outputs.# (count): the result of the decision table is the number of outputs.Other policies, such as more complex manipulations on the outputs, can be performed by post-processing the output list (outside the decision table).

Decision tables with compound outputs support only the following hit policies: Unique, Any, Priority, First, Output order, Rule order and Collect without operator, because the collect operator is undefined over multiple outputs. This restriction ignores rule annotations of which there may be multiple regardless of the hit policy specified.

For the Priority and Output order hit policies, priority is decided in compound output tables over all the outputs for which output values have been provided (ignoring rule annotations). The priority for each output is specified in the ordered list of output values in decreasing order of priority, and the overall priority is established by considering the ordered outputs from left to right in horizontal tables (i.e., columns to the left take precedence over columns to the right), or from top to bottom in vertical tables. Outputs for which no output values are provided are not taken into account in the ordering, although their output entries are included in the ordered compound output.

So, for example, if called with Age = 17, Risk category = “HIGH” and Debt review = true, the Routing rules table in *Figure _8_‑_19_* would return the outputs of all four rules, in the order 2, 4, 3, 1.

image:extracted-media/media/image82.wmf[image,width=519,height=163]

[#_Toc87278838 .anchor]##*Figure 8‑19: Output order with compound output*

*Note 1*

Crosstab tables are unique and complete by definition and therefore do not need a hit policy.

*Note 2*

The sequence of the rules in a decision table does not influence the meaning, except in **F**irst tables (single hit) and **R**ule order tables (multiple hit). These tables should be used with care.

==== Default output values

Tables may specify a default output. The default value is underlined in the list of output values.

=== Metamodel

image:extracted-media/media/image83.png[image,width=585,height=439]

[#_Toc87278839 .anchor]##*Figure 8‑20: DecisionTable class diagram*

==== Decision Table metamodel

The class DecisionTable is used to model a decision table.

DecisionTable is a concrete specialization of Expression.

An instance of DecisionTable contains a list of rules which are instances of DecisionRule, a list of inputs which are instances of InputClause, a list of outputs which are instances of OutputClause, and a list of annotations which are instances of RuleAnnotationClause.

It has a preferredOrientation, which SHALL be one of the enumerated DecisionTableOrientation: Rule-as-Row, Rule-as-Column or CrossTable. An instance of DecisionTable SHOULD BE represented as specified by its preferredOrientation, as defined in clause 8.2.2.

An instance of DecisionTable has an associated hitPolicy, which SHALL be one of the enumerated HitPolicy: UNIQUE, FIRST, PRIORITY, ANY, COLLECT, RULE ORDER, OUTPUT ORDER. The default value for the hitPolicy attribute is: UNIQUE. In the diagrammatic representation of an instance of DecisionTable, the hitPolicy is represented as specified in clause 8.2.10.

The semantics that is associated with an instance of DecisionTable depends on its associated hitPolicy, as specified below and in clause 8.2.10. The hitPolicy attribute of an instance of DecisionTable is represented as specified in clause 8.2.10.

If the hitPolicy associated with an instance of DecisionTable is FIRST or RULE ORDER, the rules that are associated with the DecisionTable SHALL be ordered. The ordering is represented by the explicit numbering of the rules in the diagrammatic representation of the DecisionTable.

If the hitPolicy associated with an instance of DecisionTable is PRIORITY or OUTPUT ORDER, the outputValue s determine the result as specified in clause 8.2.10.

If the hitPolicy that is associated with an instance of DecisionTable is COLLECT, the DecisionTable MAY have an associated aggregation, which is one of the enumerated BuiltinAggregator (see clause 8.2.10).

As a kind of Expression, an instance of DecisionTable has a value, which depends on the outputs of the associated rules, the associated hitPolicy and the associated aggregration, if any. The value of an instance of DecisionTable is determined according to the specification in clause 10.3.2.10.

DecisionTable inherits all the attributes and model associations from Expression. *Table _32_* presents the additional attributes and model associations of the DecsionTable element.

.[#_Toc87278964 .anchor]##*Table 34: OutputClause attributes and model associations*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*input*: InputClause [*]
____

a|
____
This attributes lists the instances of InputClause that compose this DecisionTable.
____

a|
____
*output*: OutputClause [*]
____

a|
____
This attributes lists the instances of OutputClause that compose this DecisionTable.
____

a|
____
*annotation*: RuleAnnotationClause [*]
____

a|
____
This attribute lists the instances of RuleAnnotationClause that compose this DecisionTable.
____

a|
____
*rule*: DecisionRule [*]
____

a|
____
This attributes lists the instances of DecisionRule that compose this DecisionTable.
____

a|
____
*hitPolicy:* HitPolicy
____

a|
____
The hit policy that determines the semantics of this DecisionTable. Default is: UNIQUE.
____

a|
____
*aggregation:* BuiltinAggregator
____

a|
____
If present, this attribute specifies the aggregation function to be applied to the unordered set of values of the applicable rules to determine the value of this DecisionTable when the hitPolicy is COLLECT.
____

a|
____
*preferredOrientation:*

Decis ionTableOrientation [0.. 1]
____

a|
____
The preferred orientation for the diagrammatic representation of this DecisionTable. This DecisionTable SHOULD BE represented as specified by this attribute.
____

a|
____
*outputLabel:* string[0..1]
____

a|
____
This attribute gives a description of the decision table output, and is often the same as the name of the InformationItem for which the decision table is the value expression.
____

|===

==== Decision Table Input and Output metamodel

In a DecisionTable, an input specifies an inputExpression (the subject) and a number of inputEntries. An output specifies the name and the domain of definition of an output value, a number of outputEntries.

The class InputClause is used to model a decision table input, and the class OutputClause is used to model a decision table output, and the class RuleAnnotationClause is used to model a decision table annotation.

An instance of InputClause is made of an optional inputExpression and an ordered list of inputEntry, which are instances of UnaryTests. An instance of OutputClause optionally references a typeRef, specifying its datatype, and it is made of an ordered list of outputEntry, which are instances of LiteralExpression, and an optional defaultOutputEntry, which is also an instance of LiteralExpression. An instance of RuleAnnotationClause contains a name of type String.

When a DecisionTable contains more than one OutputClause, each OutputClause SHALL have a name. When a DecisionTable has a single OutputClause, the OutputClause SHALL NOT have a name. A RuleAnnotationClause SHALL have a name.

*Table _33_*, *Table _34_* and *Table _35_* present the attributes and model associations of InputClause, OutputClause and RuleAnnotationClause respectively.

.[#_Toc87278965 .anchor]##*Table 35: RuleAnnotationClause attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*inputExpression:* Expression [0..1]
____

a|
____
The subject of this InputClause.
____

a|
____
*inputValues:* UnaryTests [0..1]
____

a|
____
This attribute contains UnaryTests that constrain the result of the inputExpression of this InputClause.
____

|===

.[#_Toc87278966 .anchor]##*Table 36: DecisionRule attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*typeRef: String* [1]
____

a|
____
The OutputClause of a single output decision table SHALL NOT specify a typeRef. OutputClauses of a multiple output decision table MAY specify a typeRef. A typeRef is the name of the datatype of the output, either an ItemDefinition, a base type in the specified expressionLanguage, or an imported type.
____

a|
____
*name:* string [0..1]
____

a|
____
The OutputClause of a single output decision table SHALL NOT specify a name. OutputClauses of a multiple output decision table SHALL specify a name.
____

a|
____
*outputValues:* UnaryTests [0..1]
____

a|
____
This attribute contains UnaryTests that constrain the result of the outputEntrys of the DecisionRules corresponding to this OutputClause.
____

a|
____
*defaultOutputEntry:* Expression [0..1]
____

a|
____
In an Incomplete table, this attribute lists an instance of Expression that is selected when no rules match for the decision table.
____

|===

.[#_Toc87278967 .anchor]##*Table 37: RuleAnnotation attributes and model associations*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*name*: string [1]
____

a|
____
RuleAnnotationClause SHALL specify a name that is used as the name of the rule annotation column of the containing decision table.
____

|===

==== Decision Rule metamodel

The class DecisionRule is used to model the rules in a decision table (see 8.2).

An instance of DecisionRule has an ordered list of inputEntry instances which are instances of UnaryTests, an ordered list of outputEntry instances, which are instances of LiteralExpression, and an ordered list of ruleAnnotations.

In a tabular representation of the containing instance of DecisionTable, the representation of an instance of DecisonRule depends on the orientation of the decision table. For instance, if the decision table is represented

horizontally (rules as row, see 8.2.2), instances of DecisionRule are represented as rows, with all the inputEntrys represented on the left of all the outputEntrys, and all the ruleAnnotations represented to their right.

By definition, a DecisionRule element that has no inputEntrys is always applicable. Otherwise, an instance of DecisionRule is said to be _applicable_ if and only if, all of the DecisionTable’s inputExpression values satisfy their corresponding inputEntry.

An inputExpression satisfies its corresponding inputEntry if and only if one of the following alternatives is true:

[loweralpha]
. {blank}
. {blank}
. {blank}
. {blank}

One of the expressions in the inputEntry evaluates to a value, and the inputExpression value is equal to that value.One of the expressions in the inputEntry evaluates to a list of values, and the inputExpression value is equal to at least one of the values in that list.One of the expressions in the inputEntry is a unary test, and the unary test evaluates to true when the inputExpression value is applied to it.One of the expressions in the inputEntry is a boolean expressions using the special ‘?’ variable and that expression evaluates to true when the inputExpression value is assigned to ‘?’.The inputEntrys are matched in arbitrary order.

The inputEntry elements SHALL be in the same order as the containing DecisionTable's inputs.

The _i^th^_ inputExpression must satisfy the _i^th^_ inputEntry for all inputEntrys in order for the DecisionRule to _match_, as defined in section 8.1.

The outputEntry elements SHALL be in the same order as the containing DecisionTable's outputs. The _i^th^_ outputEntry SHALL be consistent with the typeRef of the _i^th^_ OutputClause.

The ruleAnnotation elements SHALL be in the same order as the containing DecisionTable's annotations. The _ith_ ruleAnnotation refers to the _i^th^_ RuleAnnotationClause.

*Table _36_* presents the attributes and model associations of the DecisionRule element; *Table _36_* presents the attributes and model associations of the RuleAnnotation element.

.[#_Toc87278968 .anchor]##*Table 38: Examples of decision tables*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*inputEntry:* UnaryTests[0..*]
____

a|
____
The instances of UnaryTests that specify the input conditions that this DecisionRule must match for the corresponding (by index) inputExpression.
____

a|
____
*outputEntry:* LiteralExpression [1..*]
____

a|
____
A list of the instances of LiteralExpression that compose the output components of this DecisionRule.
____

a|
____
*annotationEntry*: RuleAnnotation [0..*]
____

a|
____
A list of the instances of RuleAnnotation that compose the annotations of this DecisionRule and match the corresponding (by index) instances of RuleAnnotationClause.
____

|===

.[#_Toc87278969 .anchor]##*Table 39: FEEL range comparisons*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
text: string [0..1]
____

a|
____
The text of the RuleAnnotation
____

|===

=== Examples

*Table _38_* provides examples for the various types of decision table discussed in this section. Further examples may be found in clause 11.1.4, in the context of a complete example of a *DMN* decision model.

.[#_Toc87278970 .anchor]##*Table 40: FEEL numbers and calculations*
[width="100%",cols="27%,6%,15%,1%,1%,4%,1%,2%,3%,1%,1%,8%,,1%,6%,3%,4%,4%,1%,11%",options="header",]
|===
a|
____
Single Hit **U**nique
____

| | | | | | | | | | | | | | | | | | |
| a|
____
*Applicant Risk Rating*
____

| | | | | | | | | | | | | | | | | |
| |*U* |Applicant Age | | |Medical History Applicant Risk Rating | | | | | | | | | | | | | |
| a|
____
1

2
____

|> 60 | | |_good_ | | | | | | |_Medium_ | | | | | | |
| | | | | |_bad_ | | | | | | |_High_ | | | | | | |
| a|
____
3
____

|[25..60] | | |_-_ | | | | | | |_Medium_ | | | | | | |
| a|
____
4

5
____

|< 25 | | |_good_ | | | | | | |_Low_ | | | | | | |
| | | | | |_bad_ | | | | | | |_Medium_ | | | | | | |
| | | | | | | | | | | | | | | | | | | |
| a|
____
*Applicant Risk Rating*
____

| | | | | | | | | | | | | | | | | |
| a|
____
Applicant Age
____

| |< 25 | | | | | | | |[25..60] | | |> 60 | | | | |
| a|
____
Medical History _good_
____

| | | | |_bad_ | | | | |_-_ | | |_good_ | |_bad_ | | |
| a|
____
Applicant Risk Rating _Low_
____

| | | | |_Medium_ | | | | |_Medium_ | | |_Medium_ | |_High_ | | |
| |*U* 1 | | | | |2 | | | | |3 | | |4 | |5 | | |
| | | | | | | | | | | | | | | | | | | |
| a|
____
*Applicant Risk Rating*
____

| | | | | | | | | | | | | | | | | |
| a|
____
Applicant Age
____

| | |< 25 | | | | | |[25..60] | | |> 60 | | | | | |
| a|
____
Medical History
____

| | |_good_ | | |_bad_ | | |_-_ | | |_good_ | |_bad_ | | | |
| a|
____
_Low_
____

| | |X | | |- | | |- | | |- | |- | | | |
| a|
____
_Medium_
____

| | | | | |X | | |X | | |X | | | | | |
| a|
____
_High_
____

| | | | | | | | | | | | | |X | | | |
| |*U* | | |1 | | |2 | | |3 | | |4 | |5 | | | |
| | | | | | | | | | | | | | | | | | | |
|===

.[#_Toc87278971 .anchor]##*Table 41: EBNF notation*
[width="100%",cols="26%,6%,15%,1%,1%,4%,1%,2%,1%,1%,3%,3%,10%,3%,1%,17%,1%,4%",options="header",]
|===
a|
____
Single Hit **A**ny
____

| | | | | | | | | | | | | | | | |
| a|
____
*Person Loan Compliance*
____

| | | | | | | | | | | | | | | |
| |*A* |Persons Credit +
Rating from Bureau | | |Person Credit +
Card Balance | | | | | |Person Education +
Loan Balance | | | |Person Loan +
Compliance | |
| a|
____
1
____

|_A_ | | |< 10000 | | | | | |< 50000 | | | |_Compliant_ | |
| a|
____
2
____

|Not(_A_) | | |- | | | | | |- | | | |_Not Compliant_ | |
| a|
____
3
____

|- | | |>= 10000 | | | | | |- | | | |_Not Compliant_ | |
| a|
____
4
____

|- | | |- | | | | | |>= 50000 | | | |_Not Compliant_ | |
| |_Example case:_ not A, >= $10K, >= 50K -> Not Compliant (rules 2,3,4) | | | | | | | | | | | | | | | |
a|
____
Single Hit **P**riority
____

| | | | | | | | | | | | | | | | |
| a|
____
*Applicant Risk Rating*
____

| | | | | | | | | | | | | | | |
| |*P* |Applicant Age | | | |Medical History | | | | | | |Applicant Risk Rating | | | |
| | | | | | | | | | | | | |_High, Medium, Low_ | | | |
| |1 |>= 25 | | | |_good_ | | | | | | |_Medium_ | | | |
| |2 |> 60 | | | |_bad_ | | | | | | |_High_ | | | |
| |3 |- | | | |_bad_ | | | | | | |_Medium_ | | | |
| |4 |< 25 | | | |_good_ | | | | | | |_Low_ | | | |
| | | | | | | | | | | | | | | | | |
a|
____
Single Hit **F**irst
____

| | | | | | | | | | | | | | | | |
| a|
____
*Special Discount*
____

| | | | | | | | | | | | | | | |
| |*F* |Type of Order |Customer Location | | | | | | | |Type of Customer Special Discount % | | | | | |
| |1 |_Web_ |_US_ | | | | | | | |_Wholesaler_ | | |10 | | |
| |2 |_Phone_ |_-_ | | | | | | | |_-_ | | |0 | | |
| |3 |_-_ |_Non-US_ | | | | | | | |_-_ | | |0 | | |
| |4 |_-_ |_-_ | | | | | | | |_Retailer_ | | |5 | | |
| | | | | | | | | | | | | | | | | |
| a|
____
*Special Discount*
____

| | | | | | | | | | | | | | | |
| a|
____
Type of Order _Web_
____

| | | | | | | | | | |- | | | | |
| a|
____
Customer Location _US_
____

| | | | | | | | | | |- | | | | |
| a|
____
Type of Customer
____

| | |_Wholesale +
r_ | | | | |_Retaile +
r_ | | |- | | | | |
| a|
____
Special Discount % 10
____

| | | | | | | |5 | | |0 | | | | |
| |*F* 1 | | | | | | | |2 | | |3 | | | | |
| a|
____
_Example case:_ Web, non-US, Retailer -> 0 (rule 3)
____

| | | | | | | | | | | | | | | |
|===

.[#_Toc87278973 .anchor]##*Table 43: Examples of types of domain elements*
[width="100%",cols="27%,6%,9%,,1%,4%,1%,2%,4%,,4%,2%,7%,2%,4%,1%,6%,7%,4%,9%",options="header",]
|===
a|
____
Multiple Hit **N**o order
____

| | | | | | | | | | | | | | | | | | |
| a|
____
*Holidays*
____

| | | | | | | | | | | | | | | | | |
| a|
____
Age
____

| | |- | | |<18 | | |>=60 | |- |[18..60) | | |>=60 |- | |
| |Years of Service | | |- | | |- | | |- | |>=30 |[15..30) | | |- |>=30 | |
| a|
____
Holidays
____

| | |22 | | |5 | | |5 | |5 |2 | | |3 |3 | |
| |*C+* | | |1 | | |2 | | |3 | |4 |5 | | |6 |7 | |
| a|
____
_Example case:_ Age=58, Service=3 1 -> Result=sum(22, 5, 3)=30
____

| | | | | | | | | | | | | | | | | |
a|
____
Multiple Hit **O**utput order
____

| | | | | | | | | | | | | | | | | | |
| a|
____
*Holidays*
____

| | | | | | | | | | | | | | | | | |
| |*O* |Age | | |Years of Service | | | | | |Holidays | | | | | | | |
| | | | | | | | | | | |_22, 5, 3, 2_ | | | | | | | |
| |1 |- | | |- | | | | | |22 | | | | | | | |
| |2 |>= 60 | | |- | | | | | |3 | | | | | | | |
| |3 |- | | |>= 30 | | | | | |3 | | | | | | | |
| |4 |< 18 | | |- | | | | | |5 | | | | | | | |
| |5 |>= 60 | | |- | | | | | |5 | | | | | | | |
| |6 |- | | |>= 30 | | | | | |5 | | | | | | | |
| |7 |[18..60) | | |[15..30) | | | | | |2 | | | | | | | |
| |8 |[45..60) | | |< 30 | | | | | |2 | | | | | | | |
| a|
____
_Example case:_ Age=58, Service=3 1 -> Result=(22, 5, 3)
____

| | | | | | | | | | | | | | | | | |
a|
____
Multiple Hit **R**ule order
____

| | | | | | | | | | | | | | | | | | |
| a|
____
*Student Financial Package Eligibility*
____

| | | | | | | | | | | | | | | | | |
| |*R* |Student +
GPA |Student Extra- +
Curricular +
Activities +
Count | | | | | |Student National +
Honor Society +
Membership | | | | |Student Financial Package +
Eligibility List | | | | |
| |1 |> 3.5 |>= 4 | | | | | |_Yes_ | | | | |20% Scholarship | | | | |
| |2 |> 3.0 |- | | | | | |_Yes_ | | | | |30% Loan | | | | |
| |3 |> 3.0 |>= 2 | | | | | |_No_ | | | | |20% Work-On-Campus | | | | |
| |4 |<= 3.0 |- | | | | | |- | | | | |5% Work-On-Campus | | | | |
| a|
____
_Example case:_ For GPA=3.6, EC Activities=4, NHS Membership -> result = (20% scholarship, 30% loan)
____

| | | | | | | | | | | | | | | | | |
|===

== 

=== Simple Expression Language (S-FEEL)Introduction

*DMN* defines the friendly enough expression language (FEEL) for the purpose of giving standard executable semantics to many kinds of expressions in decision model (see 10).

This section defines a simple subset of FEEL, S-FEEL, for the purpose of giving standard executable semantics to decision models that use only simple expressions: in particular, decision models where the decision logic is modeled mostly or only using decision tables.

Experience with DMN since its release has shown that few if any complete decision models can be defined using S- FEEL. Individual decision tables can be defined using only S-FEEL but within a decision model there is generally at least one decision that requires FEEL. Developers and users are therefore encouraged to use and implement the full FEEL specification rather than the S-FEEL subset.

=== S-FEEL syntax

The syntax for the S-FEEL expressions used in this section is specified in the EBNF below: it is a subset of the FEEL syntax specified in clause 10.3.1.2.

*Grammar rules*:

[arabic]
. {blank}
. {blank}

expression = simple expression ;arithmetic expression =2.a addition | subtraction |

2.b multiplication | division |

2.c exponentiation |

2.d arithmetic negation ;

3 simple expression = arithmetic expression | simple value | comparison ;

4 simple expressions = simple expression , \{ "," , simple expression } ;

5 simple positive unary test =

5.a [ "<" | "<=" | ">" | ">=" ] , endpoint |

5.b interval ;

6 interval = ( open interval start | closed interval start ) , endpoint , ".." , endpoint , ( open interval end | closed interval

____
end ) ;
____

7 open interval start = "(" | "]" ;

8 closed interval start = "[" ;

9 open interval end = ")" | "[" ;

10 closed interval end = "]" ;

11 simple positive unary tests = simple positive unary test , \{ "," , simple positive unary test } ;

12 simple unary tests =

12.a simple positive unary tests |

12.b "not", "(", simple positive unary tests, ")" |

____
12.c "-";

13 endpoint = simple value ;

14 simple value = qualified name | simple literal ;

15 qualified name = name , \{ "." , name } ;

16 addition = expression , "+" , expression ;

17 subtraction = expression , "-" , expression ;

18 multiplication = expression , "*" , expression ;

19 division = expression , "/" , expression ;

20 exponentiation = expression, "**", expression ;

21 arithmetic negation = "-" , expression ;

22 name = name start , \{ name part | additional name symbols } ;

23 name start = name start char, \{ name part char } ;

24 name part = name part char , \{ name part char } ;

25 name start char = "?" | [A-Z] | "_" | [a-z] | [\uC0-\uD6] | [\uD8-\uF6] | [\uF8-\u2FF] | [\u370-\u37D] | [\u37F-\u1FFF] | [\u200C-\u200D] | [\u2070-\u218F] | [\u2C00-\u2FEF] | [\u3001-\uD7FF] | [\uF900-\uFDCF] | [\uFDF0-\uFFFD] | [\u1 0000-\uEFFFF] ;

26 name part char = name start char | digit | \uB7 | [\u0300-\u036F] | [\u203F-\u2040] ;

27 additional name symbols = "." | "/" | "-" | "’" | "+" | "*" ;

28 simple literal = numeric literal | string literal | boolean literal | date time literal ;

29 string literal = """, \{ character – (""" | vertical space) | string escape sequence}, """ ;

30 boolean literal = "true" | "false" ;

31 numeric literal = [ "-" ] , ( digits , [ ".", digits ] | "." , digits ) ;

32 digit = [0-9] ;

33 digits = digit , \{digit} ;

34 date time literal = ("date" | "time" | "duration" ) , "(" , string literal , ")" ;

35 comparison = expression , ( "=" | "!=" | "<" | "<=" | ">" | ">=" ) , expression ;

36 white space = vertical space | \u0009 | \u0020 | \u0085 | \u00A0 | \u1 680 | \u1 80E | [\u2000-\u200B] | \u2028 | \u2029 | \u202F | \u205F | \u3000 | \uFEFF ;

37 vertical space = [\u000A-\u000D];

38 string escape sequence = "\'" | "\"" | "\\" | "\n" | "\r" | "\t" | "\u", hex digit, hex digit, hex digit, hex digit;
____

=== S-FEEL data types

S-FEEL supports all FEEL data types: _number_, _string_, _boolean_, _days and time duration_, _years and months duration_, _time_ and _date_, although with a simplified definition for some of them.

S-FEEL _number_ has the same literal and values spaces as the XML Schema decimal datatype. Implementations are allowed to limit precision to 34 decimal digits and to round toward the nearest neighbor with ties favoring the even neighbor. Notice that “_precision is not reflected in this value space: the number 2.0 is not distinct from the number 2.00_” [XML Schema]. Notice, also, that this value space is totally ordered. The definition of S-FEEL _number_ is a simplification over the definition of FEEL _number_.

S-FEEL supports FEEL _string_ and FEEL _Boolean_: FEEL _string_ has the same literal and values spaces as the Java String and XML Schema string datatypes. FEEL _boolean_ has the same literal and values spaces as the Java Boolean and XML Schema Boolean datatypes.

S-FEEL supports the FEEL _time_ data type. The lexical and value spaces of FEEL _time_ are the literal and value spaces of the XML Schema time datatype. Notice that, “_since the lexical representation allows an optional time zone indicator, time values are partially ordered because it may not be able to determine the order of two values one of which has a time zone and the other does not. Pairs of time values with or without time zone indicators are totally ordered_” [XSD].

S-FEEL does not support FEEL date and time. However, it supports the _date_ type, which is like FEEL _date and time_ with hour, minute, and second required to be absent. The lexical and value spaces of FEEL _date_ are the literal and value spaces of the XML Schema date datatype.

S-FEEL supports the FEEL _days and time duration_ and _years and months duration_ datatypes. FEEL _days and time duration_ and _years and months duration_ have the same literal and value spaces as the XPath Data Model dayTimeDuration and yearMonthDuration datatypes, respectively. That is, FEEL _days and time duration_ is derived from the XML Schema duration datatype by restricting its lexical representation to contain only the days, hours, minutes and seconds components, and FEEL _years and months duration_ is derived from the XML Schema duration datatype by restricting its lexical representation to contain only the year and month components.

The FEEL data types are specified in details in clause 10.3.2.2.

=== S-FEEL semantics

S-FEEL contains only a limited set of basic features that are common to most expression and programming languages, and on the semantics of which most expression and programming languages agree.

The semantics of S-FEEL expressions are defined in this section, in terms of the semantics of the XML Schema datatypes and the XQuery 1.0 and XPath 2.0 Data Model datatypes, and in terms of the corresponding functions and operators defined by XQuery 1.0 and XPath 2.0 Functions and Operators (prefixed by “op:” below). A complete stand-alone specification of the semantics is to be found in clause 10.3.2, as part of the definition of FEEL. Within the scope of S- FEEL, the two definitions are equivalent and equally normative.

Arithmetic addition and subtraction (grammar rule 2.a) have the same semantics as:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

op:numeric-add and op:numeric-subtract, when its two operands are numbers;op:add-yearMonthDurations and op:subtract-yearMonthDurations, when the two operands are years and months durations;op:add-dayTimeDuration and subtract:dayTimeDurations, when the two operands are days and time durations;op:add-yearMonthDuration-to-date and op:subtract-yearMonthDuration-from-date, when the first operand is a years and months duration and the second operand is a date;op:add-dayTimeDuration-to-date and op:subtract-dayTimeDuration-from-date, when the first operand is a days and time duration and the second operand is a date;op:add-dayTimeDuration-to-time and op:subtract-dayTimeDuration-from-time, when the first operand is a days and time duration and the second operand is a time.In addition, arithmetic subtraction has the semantics of op:subtract-dates or op:subtract-times, when the two operands are dates or times, respectively.

Arithmetic addition and subtraction are not defined in other cases.

Arithmetic multiplication and division (grammar rule 2.b) have the same semantics as defined for op:numeric-multiply and op:numeric-divide, respectively, when the two operands are numbers. They are not defined otherwise.

Arithmetic exponentiation (grammar rule 2.c) is defined as the result of raising the first operand to the power of the second operand, when the two operands are numbers. It is not defined in other cases.

Arithmetic negation (grammar rule 2.d) is defined only when its operand is a number: in that case, its semantics is according to the specification of op:numeric-unary-minus.

Comparison operators (grammar rule 35) between numbers are defined according to the specification of op:numeric­equal, op-numeric-less-than and op:numeric-greater-than, comparisons between dates are defined according to the specification of op:date-equal, op:date-less-than and op:date-greater-than; comparisons between times are defined according to the specification of op:time-equal, op:time-less-than and op:time-greater-than; comparisons between years and months durations are defined according to the specification of op:duration-equal, op:yearMonthDuration-less-than and op:year-MonthDuration-greater-than; comparisons between days and time durations are defined according to the specification of op:duration-equal, op:dayTimeDuration-less-than and op:dayTimeDuration-greater-than.

String and Booleans can only be compared for equality: the semantics of strings and Booleans equality is as defined in the specification of fn:codepoint-equal and op:Boolean-equal, respectively.

Comparison operators are defined only when the two operands have the same type, except for years and months duration and days and time duration, which can be compared for equality. Notice, however, that “_with the exception of the zero- length duration, no instance of xs:dayTimeDuration can ever be equal to an instance of xs:yearMonthDuration_.” [XFO].

Given an expression o to be tested and two endpoint e1 and e2:

* {blank}
* {blank}
* {blank}
* {blank}

is in the interval (e1..e2), also notated ]e1..e2[, if and only if o > e1 and o < e1is in the interval (e1..e2], also notated ]e1..e2], if and only if o > e1 and o ≤ e2is in the interval [e1..e2] if and only if o ≥ e1 and o ≤ e2is in the interval [e1..e2), also notated [e1..e2[, if and only if o ≥ e1 and o < e2An expression to be tested satisfies an instance of simple unary tests (grammar rule 12) if and only if, either the expression is a list and the expression satisfies at least one simple unitary test in the list, or the simple unitary tests is “-”.

=== Use of S-FEEL expressions

This section summarizes which kinds of S-FEEL expressions are allowed in which role, when the expression language is S-FEEL.

==== Item definitions

The expression that defines an *allowed value* SHALL be an instance of _simple unary tests_ (grammar rule 12), where only the values in the defined or referenced type that satisfy the test are allowed values.

==== Invocations

In the bindings of an invocation, the *binding formula* SHALL be a _simple expression_ (grammar rule 3).

==== Decision tables

Each *input expression* SHALL be a _simple expression_ (grammar rule 3).

Each list of *input values* SHALL be an instance of _simple unary tests_ (grammar rule 12).

Each list of *output values* SHALL be an instance of _simple unary tests_ (grammar rule 12). Each *input entry* SHALL be an instance of _simple unary tests_ (grammar rule 12).

Each *output entry* SHALL be a _simple expression_ (grammar rule 3).

==  Expression Language (FEEL)

=== Introduction

In *DMN*, all decision logic is represented as _boxed expressions_. Clause 7.2 introduced the concept of the boxed expression and defined two simple kinds: boxed literal expressions and boxed invocations. Clause 8 defined decision tables, a very important kind of boxed expression__.__ This section completes the graphical notation for decision logic, by defining other kinds of boxed expressions.

The expressions 'in the boxes' are FEEL expressions. FEEL stands for Friendly Enough Expression Language and it has the following features:

* {blank}
* {blank}
* {blank}
* {blank}

Side-effect freeSimple data model with numbers, dates, strings, lists, and contextsSimple syntax designed for a wide audienceThree-valued logic (*true, false, null*)This section also completely specifies the syntax and semantics of FEEL. The syntax is specified as a grammar (10.3.1). The subset of the syntax intended to be rendered graphically as a boxed expression is also specified as a meta-model (10.5).

FEEL has two roles in *DMN*:

[arabic]
. {blank}
. {blank}

=== As a textual notation in the boxes of boxed expressions such as decision tables.As a slightly larger language to represent the logic of expressions and DRGs for the main purpose of composing the semantics in a simple and uniform way. Notation

==== Boxed Expressions

This section builds on the generic notation for decision logic and boxed expressions defined in clause 7.2.

We define a graphical notation for decision logic called *boxed expressions*. This notation serves to decompose the decision logic model into small pieces that can be associated with DRG artifacts. The DRG plus the boxed expressions form a complete, mostly graphical language that completely specifies Decision Models.

A boxed expression is either:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

a decision tablea boxed FEEL expressiona boxed invocationa boxed contexta boxed lista relationa boxed functiona boxed conditionala boxed filter, ora boxed iteratorBoxed expressions are defined recursively, _i.e.,_ boxed expressions can contain other boxed expressions. The top-level boxed expression corresponds to the decision logic of a single DRG artifact. This boxed expression SHALL have a name box that contains the name of the DRG artifact. The name box may be attached in a single box on top, as shown in Figure 10‑1:

image:extracted-media/media/image84.emf[image,width=204,height=65]

[#_Toc87278840 .anchor]##*Figure 10‑1: Boxed expression*

Alternatively, the name box and expression box can be separated by white space and connected on the left side with a line, as shown in Figure 10‑2:

image:extracted-media/media/image85.wmf[image,width=206,height=107]

[#_Toc87278841 .anchor]##*Figure 10‑2: Boxed expression with separated name and expression boxes*

Graphical tools are expected to support appropriate graphical links, for example, clicking on a decision shape opens a decision table.

Color is suggested, but does not influence the meaning. In section 10:

* {blank}
* {blank}

Green is used for names of parameters, names of context entries, keywords in boxed conditionals and boxed iterators, and brackets in boxed filters.Embedded decision tables are colored as in section 8.

===== Decision Tables

The executable decision tables defined here use the same notation as the decision tables defined in Clause 8. Their execution semantics is defined in clause 10.3.2.10.

===== Boxed FEEL expression

A *boxed FEEL expression* is any FEEL expression _e,_ as defined by the FEEL grammar (clause 10.3.1), in a table cell, as shown in Figure 10‑3:

image:extracted-media/media/image86.wmf[image,width=55,height=49]

[#_Toc87278842 .anchor]##*Figure 10‑3: Boxed FEEL expression*

The meaning of a boxed expression containing _e_ is *FEEL(*_e,_ *s)*, where *s* is the scope. The scope includes the context derived from the containing DRD as described in 10.4, and any boxed contexts containing _e_.

It is usually good practice to make _e_ relatively simple, and compose small boxed expressions into larger boxed expressions.

===== Boxed Invocation

The syntax for boxed invocation is described in clause 7.2.3. This syntax may be used to invoke any function (e.g., business knowledge model, FEEL built-in function, boxed function definition).

The box labeled 'invoked business knowledge model' can be any boxed expression whose value is a function, as shown in Figure 10‑4 :

.[#_Toc87278974 .anchor]##*Table 44: Examples of equivalence and conformance relations*
[width="100%",cols="35%,7%,58%",]
|===
a|
____
*Name*
____

| |
a|
____
function-valued expression
____

| |
a|
____
parameter 1
____

a|
____
binding expression 1
____

|
a|
____
parameter 2
____

a|
____
binding expression 2
____

|
a|
____
…
____

| |
a|
____
parameter _n_
____

a|
____
binding expression _n_
____

|
|===

[#_Toc87278843 .anchor]##*Figure 10‑4: Boxed invocation*

The boxed syntax maps to the textual syntax defined by grammar rules 38, 39, 40, 41. Boxed invocation uses named parameters. Positional invocation can be achieved using a boxed expression containing a textual positional invocation.

The boxed syntax requires at least one parameter. A parameterless function must be invoked using the textual syntax, e.g., as shown in Figure 10‑5.

[#_Toc87278844 .anchor]##*Figure 10‑5: Parameterless function*

Formally, the meaning of a boxed invocation is given by the semantics of the equivalent textual invocation, _e.g.,_ **function-valued expression(**parameter1**: binding expression1,** parameter2**: binding expression2, ...)**.

===== Boxed Context

A *boxed context* is a collection of _n_ (name, value) pairs with an optional result value. The names SHALL be distinct within a context. Each pair is called a context entry. Context entries may be separated by whitespace and connected with a line on the left (top). The intent is that all the entries of a context should be easily identified by looking down the left edge of a vertical context or across the top edge of a horizontal context. Cells SHALL be arranged in one of the following ways (see Figure 10‑6, Figure 10‑7):

.[#_Toc87278975 .anchor]##*Table 45: Examples of singleton list conversions*
[width="100%",cols="48%,52%",]
|===
a|
____
Name 1
____

a|
____
Value 1
____

| |
a|
____
Name 2
____

a|
____
Value 2
____

a|
____
Name _n_
____

a|
____
Value _n_
____

a|
____
Result
____

|
|===

[#_Toc87278845 .anchor]##*Figure 10‑6: Vertical context*

.[#_Toc87278976 .anchor]##*Table 46: Semantics of decision table*
[width="100%",cols="25%,22%,22%,11%,20%",]
|===
a|
____
Name 1
____

a|
____
Name 2
____

a|
____
Name _n_
____

| a|
____
Result
____

a|
____
Value 1
____

a|
____
Value 2
____

a|
____
Value _n_
____

| |
|===

[#_Toc87278846 .anchor]##*Figure 10‑7: Horizontal context*

The context entries in a context are often used to decompose a complex expression into simpler expressions, each with a name. These context entries may be thought of as intermediate results. For example, contexts without a final Result box are useful for representing case data (see Figure 10‑8).

.[#_Toc87278977 .anchor]##*Table 47: Mapping between FEEL and other domains*
[width="100%",cols="45%,13%,13%,29%",]
|===
a|
____
*Applicant Data*
____

| | |
a|
____
Age
____

a|
____
51
____

| |
a|
____
MaritalStatus
____

a|
____
"M"
____

| |
a|
____
EmploymentStatus
____

a|
____
"EMPLOYED"
____

| |
a|
____
ExistingCustomer
____

a|
____
false
____

| |
a|
____
Monthly
____

a|
____
Income
____

| a|
____
10000.00
____

| a|
____
Repayments
____

| a|
____
2500.00
____

| a|
____
Expenses
____

| a|
____
3000.00
____

|===

[#_Toc87278847 .anchor]##*Figure 10‑8: Use of context entries*

Contexts with a final result box are useful for representing calculations (see Figure 10‑9).

.[#_Toc87278978 .anchor]##*Table 48: Semantics of FEEL functions*
[width="100%",cols="42%,7%,51%",]
|===
a|
____
*Eligibility*
____

| |
a|
____
Age
____

a|
____
Applicant. Age
____

|
a|
____
Monthly Income
____

a|
____
Applicant. Monthly. Income
____

|
a|
____
Pre-Bureau Risk Category
____

a|
____
Affordability. Pre-Bureau Risk Category
____

|
a|
____
Installment Affordable
____

a|
____
Affordability. Installment Affordable
____

|
a|
____
if Pre-Bureau Risk Category = "DECLINE" or Installment Affordable = false or

Age < 18 or

Monthly Income < 100 then "INELIGIBLE"

else "ELIGIBLE"
____

| |
|===

[#_Toc87278848 .anchor]##*Figure 10‑9: Use of final result box*

When decision tables are (non-result) context entries, the output cell can be used to name the entry, thus saving space. Any format decision table can be used in a vertical context. A jagged right edge is allowed. Whitespace between context entries may be helpful. See Figure 10‑10.

.[#_Toc87278979 .anchor]##*Table 49: Semantics of other FEEL expressions*
[width="100%",cols="43%,18%,26%,13%",]
|===
a|
____
Name 1
____

a|
____
Value 1
____

| |
| | | |
| | a|
____
Name 2
____

|
| | | |
| | | |
a|
____
Name _n_
____

a|
____
Value _n_
____

| |
a|
____
Result
____

| | |
|===

[#_Toc87278849 .anchor]##*Figure 10‑10: Vertical context with decision table entry*

The names SHALL be legal FEEL names. The values and optional result are boxed expressions.

Boxed contexts may have a decision table as the result, and use the named context entries to compute the inputs, and give them names. For example (see Figure 10‑11):

.[#_Toc87278980 .anchor]##*Table 50: Semantics of conjunction and disjunction*
[width="100%",cols="13%,19%,4%,15%,4%,16%,29%",]
|===
a|
____
*Post-Bureau Risk Category*
____

| | | | | |
| | | | | | |
a|
____
Existing Customer
____

| | a|
____
Applicant. ExistingCustomer
____

| | |
a|
____
Credit Score
____

| | a|
____
Report. CreditScore
____

| | |
a|
____
Application Risk Score
____

| | a|
____
Affordability Model(Applicant, Product). Application Risk Score
____

| | |
| | | | | | |
a|
____
U
____

a|
____
Existing Customer
____

a|
____
Application Risk Score
____

| a|
____
Credit Score
____

| a|
____
Post-Bureau Risk Category
____

a|
____
1
____

a|
____
true
____

a|
____
<=120
____

| a|
____
<590
____

| a|
____
“HIGH”
____

a|
____
2
____

| | | a|
____
{empty}[590..610]
____

| a|
____
“MEDIUM”
____

a|
____
3
____

| | | a|
____
>610
____

| a|
____
“LOW”
____

a|
____
4
____

| a|
____
>120
____

| a|
____
<600
____

| a|
____
“HIGH”
____

a|
____
5
____

| | | a|
____
{empty}[600..625]
____

| a|
____
“MEDIUM”
____

a|
____
6
____

| | | a|
____
>625
____

| a|
____
“LOW”
____

a|
____
7
____

a|
____
false
____

a|
____
<=100
____

| a|
____
<580
____

| a|
____
“HIGH”
____

a|
____
8
____

| | | a|
____
{empty}[580..600]
____

| a|
____
“MEDIUM”
____

a|
____
9
____

| | | a|
____
>600
____

| a|
____
“LOW”
____

a|
____
10
____

| a|
____
>100
____

| a|
____
<590
____

| a|
____
“HIGH”
____

a|
____
11
____

| | | a|
____
{empty}[590..615]
____

| a|
____
“MEDIUM”
____

a|
____
12
____

| | | a|
____
>615
____

| a|
____
“LOW”
____

|===

[#_Toc87278850 .anchor]##*Figure 10‑11: Use of boxed expressions with a decision table*

Formally, the meaning of a boxed context is \{ “Name 1”: Value 1, “Name 2”: Value 2, ..., “Name _n”_: Value _n_ } if no Result is specified. Otherwise, the meaning is \{ “Name 1”: Value 1, “Name 2”: Value 2, ..., “Name _n”_: Value _n_, “result”: Result }.result. Recall that the bold face indicates elements in the FEEL Semantic Domain. The scope includes the context derived from the containing DRG as described in 10.4.

Boxed context entries for contexts that do not have a result box are accessible outside the context (as QNs), subject to the scope rules defined in clause 10.3.2.11. Boxed context entries for contexts that have a result box are not accessible outside the context.

===== Boxed List

A *boxed list* is a list of _n_ items. Cells SHALL be arranged in one of the following ways (see Figure 10‑12, Figure 10‑13):

image:extracted-media/media/image87.emf[image,width=147,height=123]

[#_Toc87278851 .anchor]##*Figure 10‑12: Vertical list*

[#_Toc87278852 .anchor]##*Figure 10‑13: Horizontal list*

Line styles are normative. The items are boxed expressions. Formally, the meaning of a boxed list is just the meaning of the list, i.e., *[ Item 1, Item 2, ..., Item _n_ ]*. The scope includes the context derived from the containing DRG as described in 10.4.

===== Relation

A vertical list of homogeneous horizontal contexts (with no result cells) can be displayed with the names appearing just once at the top of the list, like a relational table, as shown in Figure 10‑14:

.[#_Toc87278981 .anchor]##*Table 51: Semantics of negation*
[width="100%",cols="32%,30%,38%",]
|===
|Name 1 |Name 2 a|
____
Name _n_
____

|Value 1a |Value 2a a|
____
Value __n__a
____

|Value 1b |Value 2b a|
____
Value __n__b
____

|Value 1__m__ |Value 2__m__ a|
____
Value _nm_
____

|===

* +
*[#_Toc87278853 .anchor]##*Figure 10‑14: Relation*

===== Boxed Function

A Boxed Function Definition is the notation for parameterized boxed expressions.

The boxed expression associated with a Business Knowledge Model SHALL be a boxed function definition or a decision table whose input expressions are assumed to be the parameter names.

A boxed function has 3 cells:

____
{empty}1. *Kind*, containing the initial letter of one of the following:
____

* {blank}
* {blank}
* {blank}

**F**EEL**P**MML**J**ava The *Kind* box can be omitted for FEEL functions, including decision tables.

[arabic, start=2]
. {blank}
. {blank}

Parameters: 0 or more comma-separated names, in parenthesesBody: a boxed expression

The 3 cells SHALL be arranged as shown in Figure 10‑15:

.[#_Toc87278982 .anchor]##*Table 52: General semantics of equality and inequality*
[width="100%",cols="14%,86%",]
|===
a|
____
K
____

a|
____
(Parameter1, Parameter2, …)
____

a|
____
Body
____

|
|===

[#_Toc87278854 .anchor]##*Figure 10‑15: Boxed function definition*

For FEEL functions, denoted by *Kind* FEEL or by omission of *Kind*, the Body SHALL be a FEEL expression that references the parameters. For externally defined functions denoted by Kind Java, the Body SHALL be a context as described in 10.3.2.13.3 and the form of the mapping information SHALL be the _java_ form. For externally defined functions denoted by *Kind* PMML, the Body SHALL be a context as described in 10.3.2.13.3 and the form of the mapping information SHALL be the _pmml_ form.

Formally, the meaning of a boxed function is just the meaning of the function, _i.e._, FEEL(_funcion(Parameter1, Parameter2, ...) Body_) if the *Kind* is FEEL, and FEEL(_funcion(Parameter1, Parameter2, ...) external Body_) otherwise. The scope includes the context derived from the containing DRG as described in 10.4.

===== Boxed conditional

Boxed conditional offers a visual representation of an *if* statement using three rows. The first one is labelled “if”; the second one is labelled “then” and the last one is labelled “else”. In the right part, another FEEL expression is expected. The expression in the “if” part MUST resolve to a boolean.

image:extracted-media/media/image88.png[Table Description automatically generated,width=317,height=150]

[#_Toc87278855 .anchor]##*Figure* *10‑16: Boxed conditional*

image:extracted-media/media/image89.png[Table Description automatically generated,width=503,height=387]

[#_Toc87278856 .anchor]##*Figure* *10‑17: Use of conditional expression with decision table and invocation*

===== Boxed filter

Boxed filter offers a visual representation of collection filtering. The top part is an expression that is the collection to be filtered. The bottom part, between the square brackets, holds the filter expression. The expression in the top part MUST resolve to a collection. The expression in the bottom part MUST resolve to a Boolean.

image:extracted-media/media/image90.png[Table Description automatically generated,width=340,height=100]

[#_Toc87278857 .anchor]##*Figure* *10‑18:* *Filter* *expression*

Color is suggested but it is considered a good practice to have a different color for the square brackets, so the filtering expression is easier to see.

image:extracted-media/media/image91.png[Table Description automatically generated,width=247,height=294]

[#_Toc87278858 .anchor]##*Figure* *10‑19: Use of filter expression with a list expression*

===== Boxed iterator

Boxed iterator offers a visual representation of an iterator statement. There are three flavors to it: *for* loop and quantified expression *some* and *every*.

For the *for* loop, the three rows are labelled “for”, “in” and “return”. The right part of the “for” displays the iterator variable name. The second row holds an expression representing the collection that will be iterated over. The expression in the in row MUST resolve to a collection. The last row contains the expression that will process each element of the collection.

image:extracted-media/media/image92.png[image,width=317,height=148]

[#_Toc87278859 .anchor]##*Figure* *10‑20: For expression*

image:extracted-media/media/image93.png[Table Description automatically generated,width=625,height=193]

[#_Toc87278860 .anchor]##*Figure* *10‑21: Use of for expression that returns a context*

*Every* and *some* expression have a similar structure. The only difference between the two is the caption on the first line which is “every” or “some”. The second line is labelled “in” and the last one “satisfies”. The right part of the first line is the iterator variable name. The expression defined in the second row is the collection that will be tested. The expression in the in row MUST resolve to a collection. The last line is an expression that will be evaluated on each item. The expression defined in the satisfies MUST resolve to a boolean.

image:extracted-media/media/image94.png[Table Description automatically generated,width=317,height=148]

[#_Toc87278861 .anchor]##*Figure* *10‑22: Every expression*

image:extracted-media/media/image95.png[Table Description automatically generated,width=317,height=390]

[#_Toc87278862 .anchor]##*Figure* *10‑23: Use of every with a list expression*

image:extracted-media/media/image96.png[Table Description automatically generated,width=317,height=148]

[#_Toc87278863 .anchor]##*Figure* *10‑24: Some expression*

image:extracted-media/media/image97.png[Table Description automatically generated with medium confidence,width=415,height=586]

[#_Toc87278864 .anchor]##*Figure* *10‑25: Use of some with a relation and a decision table*

====  FEEL

A subset of FEEL, defined in the next section, serves as the notation "in the boxes" of boxed expressions. A FEEL object is a number, a string, a date, a time, a duration, a function, a context, or a list of FEEL objects (including nested lists).

Note: A JSON object is a number, a string, a context (JSON calls them maps) or a list of JSON objects. So, FEEL is an extension of JSON in this regard. In addition, FEEL provides friendlier syntax for literal values, and does not require context keys to be quoted.

Here we give a "feel" for the language by starting with some simple examples.

===== Comparison of ranges

Ranges and lists of ranges appear in decision table input entry, input value, and output value cells. In the examples in *Table _39_*, this portion of the syntax is shown underlined. Strings, dates, times, and durations also may be compared, using typographical literals defined in section 7.2.2.1.

.[#_Toc87278983 .anchor]##*Table 53: Specific semantics of equality*
[width="100%",cols="47%,53%",options="header",]
|===
|*FEEL Expression* |*Value*
|5 in ([.underline]#<=5# ) |true
|5 in ( ([.underline]#5..10#] ) |false
|5 in ( [[.underline]#5..10#] ) |true
|5 in ([.underline]#4, 5, 6#) |true
|5 in (<5, >5) |false
|*_2012-12-31_* in ( (*_[.underline]#2012-12-25..2013-02-14#_*) ) |true
|===

===== Numbers

FEEL numbers and calculations are exemplified in *Table _40_*.

.[#_Toc87278984 .anchor]##*Table 54: Specific semantics of inequality*
[width="100%",cols="40%,60%",options="header",]
|===
|*FEEL Expression* |*Value*
a|
____
decimal(1, 2)
____

a|
____
1.00
____

a|
____
.25 + .2
____

a|
____
0.45
____

a|
____
.10 * 30.00
____

a|
____
3.0000
____

a|
____
1 + 3/2*2 - 2**3
____

a|
____
-4.0
____

a|
____
1/3
____

a|
____
0.3333333333333333333333333333333333
____

a|
____
decimal(1/3, 2)
____

a|
____
0.33
____

a|
____
1 = 1.000
____

a|
____
true
____

a|
____
1.01/2
____

a|
____
0.505
____

a|
____
decimal(0.505, 2)
____

a|
____
0.50
____

a|
____
decimal(0.515, 2)
____

a|
____
0.52
____

a|
____
1.0*10**3
____

a|
____
1000.0
____

|===

===  Full FEEL Syntax and Semantics

Clause 9 introduced a subset of FEEL sufficient to support decision tables for Conformance Level 2 (see clause 2). The full *DMN* friendly-enough expression language (FEEL) required for Conformance Level 3 is specified here. FEEL is a simple language with inspiration drawn from Java, JavaScript, XPath, SQL, PMML, Lisp, and many others.

The syntax is defined using grammar rules that show how complex expressions are composed of simpler expressions. Likewise, the semantic rules show how the meaning of a complex expression is composed from the meaning of constituent simper expressions.

*DMN* completely defines the meaning of FEEL expressions that do not invoke externally-defined functions. There are no implementation-defined semantics. FEEL expressions (that do not invoke externally-defined functions) have no side- effects and have the same interpretation in every conformant implementation. Externally-defined functions SHOULD be deterministic and side-effect free.

====  Syntax

FEEL syntax is defined as grammar here and equivalently as a UML Class diagram in the meta-model (10.5)

===== Grammar notation

The grammar rules use the ISO EBNF notation. Each rule defines a non-terminal symbol _S_ in terms of some other symbols _S1, S2, ..._ The following table summarizes the EBNF notation.

.[#_Toc87278985 .anchor]##*Table 55: Semantics of decision table syntax*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Example*
____

a|
____
*Meaning*
____

a|
____
_S = S1 ;_
____

a|
____
Symbol _S_ is defined in terms of symbol _S1_
____

a|
____
_S1 | S2_
____

a|
____
Either _S1_ or _S2_
____

a|
____
_S1, S2_
____

a|
____
_S1_ followed by _S2_
____

a|
____
_[S1]_
____

a|
____
_S1_ occurring 0 or 1 time
____

a|
____
_\{S1}_
____

a|
____
_S1_ repeated 0 or more times
____

a|
____
_k * S1_
____

a|
____
_S1_ repeated k times
____

a|
____
"and"
____

a|
____
literal terminal symbol
____

|===

We extend the ISO notation with character ranges for brevity, as follows:

A character range has the following EBNF syntax:

character range = "[", low character, "-", high character, "]" ;

low character = unicode character ;

high character = unicode character ;

unicode character = simple character | code point ;

code point = "\u", 4 * hexadecimal digit | "\U", 6 * hexadecimal digit;

hexadecimal digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" |

"a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e" | "E" | "f" | "F" ;

A simple character is a single Unicode character, _e.g._ a, 1, $, _etc._ Alternatively, a character may be specified by its hexadecimal code point value, prefixed with _\u_.

Every Unicode character has a numeric code point value. The low character in a range must have numeric value less than the numeric value of the high character.

For example, hexadecimal digit can be described more succinctly using character ranges as follows:

____
hexadecimal digit = [0-9] | [a-i | [A-F] ;
____

Note that the character range that includes all Unicode characters is _[\u0-\u10FFFF]_.

===== Grammar rules

The complete FEEL grammar is specified below. Grammar rules are numbered, and in some cases alternatives are lettered, for later reference. Boxed expression syntax (rule 53) is used to give execution semantics to boxed expressions.

____
{empty}1. expression =
____

[loweralpha]
. {blank}
. {blank}

____
boxed expression |textual expression ;2. textual expression =
____

[loweralpha]
. {blank}
. {blank}
. {blank}
. {blank}
. {blank}
. {blank}
. {blank}
. {blank}

____
for expression | if expression | quantified expression |disjunction |conjunction |comparison |arithmetic expression |instance of |path expression | filter expression | function invocation |literal | simple positive unary test | name | "(" , expression , ")" ;3. textual expressions = textual expression , \{ "," , textual expression } ;

{empty}4. arithmetic expression =
____

[loweralpha]
. {blank}
. {blank}
. {blank}
. {blank}

____
addition | subtraction |multiplication | division |exponentiation |arithmetic negation ;5. simple expression = arithmetic expression | simple value ;

{empty}6. simple expressions = simple expression , \{ "," , simple expression } ;

{empty}7. simple positive unary test =
____

[loweralpha]
. {blank}
. {blank}

____
( "<" | "<=" | ">" | ">=" ) , endpoint |interval ;8. interval = ( open interval start | closed interval start ) , endpoint , ".." , endpoint , ( open interval end | closed interval end ) ;

{empty}9. open interval start = "(" | "]" ;

{empty}10. closed interval start = "[" ;

{empty}11. open interval end = ")" | "[" ;

{empty}12. closed interval end = "]" ;

{empty}13. positive unary test = expression ;

{empty}14. positive unary tests = positive unary test , \{ "," , positive unary test } ;

{empty}15. unary tests =
____

[loweralpha]
. {blank}
. {blank}
. {blank}

____
positive unary tests |"not", " (", positive unary tests, ")" |"-"16. endpoint = expression ;

{empty}17. simple value = qualified name | simple literal ;

{empty}18. qualified name = name , \{ "." , name } ;

{empty}19. addition = expression , "+" , expression ;

{empty}20. subtraction = expression , "-" , expression ;

{empty}21. multiplication = expression , "*" , expression ;

{empty}22. division = expression , "/" , expression ;

{empty}23. exponentiation = expression, "**", expression ;

{empty}24. arithmetic negation = "-" , expression ;

{empty}25. name = name start , \{ name part | additional name symbols } ;

{empty}26. name start = name start char, \{ name part char } ;

{empty}27. name part = name part char , \{ name part char } ;

{empty}28. name start char = "?" | [A-Z] | "_" | [a-z] | [\uC0-\uD6] | [\uD8-\uF6] | [\uF8-\u2FF] | [\u370-\u37D] | [\u37F-\u1FFF] | [\u200C-\u200D] | [\u2070-\u21 8F] | [\u2C00-\u2FEF] | [\u3001 -\uD7FF] | [\uF900-\uFDCF] | [\uFDF0-\uFFFD] | [\u10000-\uEFFFF] ;

{empty}29. name part char = name start char | digit | \uB7 | [\u0300-\u036F] | [\u203F-\u2040] ;

{empty}30. additional name symbols = "." | "/" | "-" | "’" | "+" | "*" ;

{empty}31. literal = simple literal | "null" ;

{empty}32. simple literal = numeric literal | string literal | boolean literal | date time literal ;

{empty}33. string literal = """, \{ character – (""" | vertical space) | string escape sequence}, """ ;

{empty}34. boolean literal = "true" | "false" ;

{empty}35. numeric literal = [ "-" ] , ( digits , [ ".", digits ] | "." , digits ) ;

{empty}36. digit = [0-9] ;

{empty}37. digits = digit , \{digit} ;

{empty}38. function invocation = expression , parameters ;

{empty}39. parameters = "(" , ( named parameters | positional parameters ) , ")" ;

{empty}40. named parameters = parameter name , ":" , expression , \{ "," , parameter name , ":" , expression } ;

{empty}41. parameter name = name ;

{empty}42. positional parameters = [ expression , \{ "," , expression } ] ;

{empty}43. path expression = expression , "." , name ;

{empty}44. for expression = "for" , name , "in" , iteration context \{ "," , name , "in" , iteration context } , "return" , expression ;

{empty}45. if expression = "if" , expression , "then" , expression , "else" expression ;

{empty}46. quantified expression = ("some" | "every") , name , "in" , expression , \{ "," , name , "in" , expression } , "satisfies" ,

expression ;

{empty}47. disjunction = expression , "or" , expression ;

{empty}48. conjunction = expression , "and" , expression ;

{empty}49. comparison =
____

[loweralpha]
. {blank}
. {blank}
. {blank}
. {blank}

____
expression , ( "=" | "!=" | "<" | "<=" | ">" | ">=" ) , expression |expression , "between" , expression , "and" , expression |expression , "in" , positive unary test |expression , "in" , " (", positive unary tests, ")" ;50. filter expression = expression , "[" , expression , "]" ;

{empty}51. instance of = expression , "instance" , "of" , type ;

{empty}52. type =

qualified name |

"range" "<" type ">" |

"list" "<" type ">" |

"context" "<" name ":" type \{ "," name ":" type } ">" | "function" "<" [ type \{ ", " type } ] ">" "->" type

;

{empty}53. boxed expression = list | function definition | context ;

{empty}54. list = "[" , [ expression , \{ "," , expression } ] , "]" ;

{empty}55. function definition = "function" , "(" , [ formal parameter \{ "," , formal parameter } ] , ")" , [ "external" ] , expression ;

{empty}56. formal parameter = parameter name [":" type ] ;

{empty}57. context = "\{" , [context entry , \{ "," , context entry } ] , "}" ;

{empty}58. context entry = key , ":" , expression ;

{empty}59. key = name | string literal ;

{empty}60. date time literal = at literal | function invocation;

{empty}61. white space = vertical space | \u0009 | \u0020 | \u0085 | \u00A0 | \u1 680 | \u1 80E | [\u2000-\u200B] | \u2028 | \u2029 | \u202F | \u205F | \u3000 | \uFEFF ;

{empty}62. vertical space = [\u000A-\u000D]

{empty}63. iteration context = expression, [ “..”, expression ];

{empty}64. string escape sequence = "\'" | "\"" | "\\" | "\n" | "\r" | "\t" | code point;

{empty}65. at literal = “@”, string literal
____

Additional syntax rules:

* {blank}
* {blank}
* {blank}
* {blank}

===== Operator precedence is given by the order of the alternatives in grammar rules 1, 2 and 4, in order from lowest to highest. _E.g.,_ (boxed) invocation has higher precedence than multiplication, multiplication has higher precedence than addition, and addition has higher precedence than comparison. Addition and subtraction have equal precedence, and like all FEEL infix binary operators, are left associative.Java-style comments can be used, _i.e._ '//' to end of line and /* ... */.In rule 62, the only permitted functions are the builtins _date_, _time_, _date and time,_ and _duration_.The string in rule 65 must follow the date string, time string, date and time string or duration string syntax, as detailed in section 10.3.4.1. Literals, data types, built-in functions

FEEL supports literal syntax for numbers, strings, booleans, date, time, date and time, duration, and _null_. (See grammar rules, clause 10.3.1.2). Literals can be mapped directly to values in the FEEL semantic domain (clause 10.3.2.1).

FEEL supports the following datatypes:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

===== NumberStringBooleandays and time durationyears and months durationdatetimedate and timelistrangecontextfunctionTokens, Names and White space

A FEEL expression consists of a sequence of tokens, possibly separated with white space (grammar rule 63). A token is a sequence of Unicode characters, either:

* {blank}
* {blank}

A literal terminal symbol in any grammar rule other than grammar rule 30. Literal terminal symbols are enclosed in double quotes in the grammar rules, e.g., “and”, “+”, “=”, orA sequence conforming to grammar rule 28, 29, 35, or 37For backward compatibility reasons, “list”, “context” and “range” from grammar rule 52 are not considered literal terminal symbols.

White space (except inside strings) acts as token separators. Most grammar rules act on tokens, and thus ignore white space (which is not a token).

A name (grammar rule 27) is defined as a sequence of tokens. I.e. the name IncomeTaxesAmount is defined as the list of tokens *[ Income, Taxes, Amount ]*. The name Income+Expenses is defined as the list of tokens *[ Income, + , Expenses ]*. A consequence of this is that a name like Phone Number with one space in between the tokens is the same as Phone Number with several spaces in between the tokens.

A name start (grammar rule 26) SHALL NOT be a literal terminal symbol.

A name part (grammar rule 27) MAY be a literal terminal symbol.

===== Contexts, Lists, Qualified Names, and Context Lists

A context is a map of key-value pairs called context entries, and is written using curly braces to delimit the context, commas to separate the entries, and a colon to separate key and value (grammar rule 57). The key can be a string or a name. The value is an expression.

A list is written using square brackets to delimit the list, and commas to separate the list items (grammar rule 54).

Contexts and lists can reference other contexts and lists, giving rise to a directed acyclic graph. Naming is path based. The _qualified name_ (QN) of a context entry is of the form _N1_._N2 ... N~n~_ where _N1_ is the name of an in-scope context.

Nested lists encountered in the interpretation of _N1_._N2 ... N~n~_ are preserved. _E.g.,_

[loweralpha]
. {blank}
. {blank}

____
_\{b: [1]}}, \{a: \{b: [2.1, 2.2]}}, \{a: \{b: [3]}}, \{a: \{b: [4, 5]}}].a.b =[1]}, \{b: [2.1,2.2]}, \{b: [3]}, \{b: [4, 5]}].b =[[1], [2.1, 2.2], [3], [4, 5]]_
____

Nested lists can be flattened using the _flatten()_ built-in function (10.3.4).

===== Ambiguity

FEEL expressions reference InformationItems by their qualified name (QN), in which name parts are separated by a period. For example, variables containing components are referenced as [varName].[componentName]. Imported elements such as InformationItems and ItemDefinitions are referenced by namespace-qualified name, in which the first name part is the name specified by the Import element importing the element. For example, an imported variable containing components is referenced as [import name].[varName].[componentName].

Because names are a sequence of tokens, and some of those tokens can be FEEL operators and keywords, context is required to resolve ambiguity. For example, the following could be names or other expressions:

* {blank}
* {blank}
* {blank}
* {blank}

a-ba – bwhat if?Profit and lossAmbiguity is resolved using the scope. Name tokens are matched from left to right against the names in-scope, and the longest match is preferred. In the case where the longest match is not desired, parenthesis or other punctuation (that is not allowed in a name) can be used to disambiguate a FEEL expression. For example, to subtract b from a if a-b is the name of an in-scope context entry, one could write (a)-(b). Notice that it does not help to write a - b, using space to separate the tokens, because the space is not part of the token sequence and thus not part of the name.

====  Semantics

FEEL semantics is specified by mapping syntax -fragments to values in the FEEL semantic domain. Literals (clause 10.3.1.3) can be mapped directly. Expressions composed of literals are mapped to values in the semantic domain using simple logical and arithmetic operations on the mapped literal values. In general, the semantics of any FEEL expression are composed from the semantics of its sub-expressions.

===== Semantic Domain

The FEEL semantic domain *D* consists of an infinite number of typed values. The types are organized into a lattice called *L*.

The types include:

* {blank}
* {blank}
* {blank}
* {blank}

simple datatypes such as number, boolean, string, date, time, and durationconstructed datatypes such as functions, lists, and contextsthe Null type, which includes only the *null* valuethe special type Any, which includes all values in **D**A function is a lambda expression with lexical closure or is externally defined by Java or PMML. A list is an ordered collection of domain elements, and a context is a partially ordered collection of (string, value) pairs called context entries.

We use _italics_ to denote syntactic elements and *boldface* to denote semantic elements. For example, FEEL**(**_[1+ 1, 2+2]_*) is [2, 4]*

Note that we use bold *[]* to denote a list in the FEEL semantic domain, and bold numbers *2, 4* to denote those decimal values in the FEEL semantic domain.

===== Equality, Identity and Equivalence

The semantics of equality are specified in the semantic mappings in clause 10.3.2.15. In general, the values to be compared must be of the same kind, for example, both numbers, to obtain a non-null result.

Identity simply compares whether two objects in the semantic domain are the same object. We denote the test for identity using infix *is*, and its negation using infix *is not*. For example, FEEL( _"1" = 1_) *is null*. Note that *is* never results in *null*.

Every FEEL expression _e_ in scope s can be mapped to an element *e* in the FEEL semantic domain. This mapping defines the meaning of _e_ in s. The mapping may be written *e is* FEEL(_e_,s). Two FEEL expressions _e~1~_ and _e~2~_ are equivalent in scope s if and only if FEEL(_e~1~_,s) *is* FEEL(_e~2~_,s). When s is understood from context (or not important), we may abbreviate the equivalence as *e~1~ is e~2~*.

===== Semantics of literals and datatypes

FEEL datatypes are described in the following sub-sections. The meaning of the datatypes includes:

[arabic]
. {blank}
. {blank}

A mapping from a literal form (which in some cases is a string) to a value in the semantic domain.A precise definition of the set of semantic domain values belonging to the datatype, and the operations on them. Each datatype describes a (possibly infinite) set of values. The sets for the datatypes defined below are disjoint. We use _italics_ to indicate a literal and *boldface* to indicate a value in the semantic domain.

====== number

FEEL Numbers are based on IEEE 754-2008 Decimal128 format, with 34 decimal digits of precision and rounding toward the nearest neighbor with ties favoring the even neighbor. Numbers are a restriction of the XML Schema type precisionDecimal, and are equivalent to Java BigDecimal with MathContext DECIMAL 128.

Grammar rule 35 defines literal numbers. Literals consist of base 10 digits and an optional decimal point. –INF, +INF, and NaN literals are not supported. There is no distinction between -0 and 0. The number(from, grouping separator, decimal separator) built-in function supports a richer literal format. E.g., FEEL(number("1. 000.000,01 ", ". ", ",")) = *1000000.01*.

FEEL does not support a literal scientific notation. E.g., 1 .2e3 is not valid FEEL syntax. Use _1.2*10**3_ instead.

A FEEL number is represented in the semantic domain as a pair of integers *(p,s)* such that *p* is a signed 34 digit integer carrying the precision information, and *s* is the scale, in the range [−611 1..6176]. Each such pair represents the number *p*/10**^s^**. To indicate the numeric value, we write *value(p,s)*. _E.g._ *value(100,2) = 1.* If precision is not of concern, we may write the value as simply *1*. Note that many different pairs have the same value. For example, *value(1,0) = value(10,1) = value(100,2)*.

There is no value for notANumber, positiveInfinity, or negativeInfinity. Use *null* instead.

====== string

Grammar rule 33 defines literal strings as a double-quoted sequence of Unicode characters (see https://unicode.org/glossary/#character),[[.underline]#https://unicode.org/glossary/#character)&#44;#] e.g., "abc". The supported Unicode character range is [\u0-\u10FFFF]. The string literals are described by rule 33. The corresponding Unicode code points are used to encode a string literal.

image:extracted-media/media/image98.png[image,height=14]The literal string _"abc"_ is mapped to the semantic domain as a sequence of three Unicode characters *a*, *b*, and *c*, written *"abc"*. The literal _"\ U01F4 0E"_ is mapped to a sequence of one Unicode character written *"ὀ"* corresponding to the code point U+1F40E.

====== boolean

The Boolean literals are given by grammar rule 34. The values in the semantic domain are *true* and *false*.

====== time

Times in FEEL can be expressed using either a time literal (see grammar rule 65) or the _time()_ built-in function (See 10.3.4.1). We use boldface time literals to represent values in the semantic domain.

A time in the semantic domain is a value of the XML Schema time datatype. It can be represented by a sequence of numbers for the hour, minute, second, and an optional time offset from Universal Coordinated Time (UTC). If a time offset is specified, including time offset = 00:00, the time value has a UTC form and is comparable to all time values that have UTC forms. If no time offset is specified, the time is interpreted as a local time of day at some location, whose relationship to UTC time is dependent on time zone rules for that location, and may vary from day to day. A local time of day value is only sometimes comparable to UTC time values, as described in XML Schema Part 2 Datatypes.

____
A time *t* can also be represented as the number of seconds since midnight. We write this as *valuet(t)*. _E.g.,_ *valuet(01:01:01) = 3661*.

The *valuet* function is one-to-one, but its range is restricted to [0..86400]. So, it has an inverse function *valuet ^-1^*(x) that returns: the corresponding time value for x, if x is in [0..86400]; and *valuet ^-1^*(y), where y = x – floor(x/86400) * 86400, if x is not in [0..86400].

Note: That is, *valuet ^-1^*(x) is always actually applied to x modulo 86400. For example, *valuet ^-1^*(3600) will return the time of day that is “01:00:00”, *valuet ^-1^*(90000) will also return “T01 :00:00”, and *valuet ^-1^*(-3600) will return the time of day that is “23 :00:00”, treating -3600 seconds as one hour _before_ midnight.
____

====== date

Dates in FEEL can be expressed using either a date literal (see grammar rule 65) or the date() built-in function (See 10.3.4.1). A date in the semantic domain is a sequence of numbers for the year, month, day of the month. The year must be in the range [-999,999,999. .999,999,999]. We use boldface date literals to represent values in the semantic domain.

Where necessary, including the value**_dt_** function (see 10.3.2.3.6), a date value is considered to be equivalent to a date time value in which the time of day is UTC midnight (00:00:00).

====== date-time

_Date and time_ in FEEL can be expressed using either a _date time literal_ (see grammar rule 65) or the _date and time()_ built-in function (See 10.3.2.3.6). We use boldface _date and time literals_ to represent values in the semantic domain.

A date and time in the semantic domain is a sequence of numbers for the year, month, day, hour, minute, second, and optional time offset from Universal Coordinated Time (UTC). The year must be in the range [-999,999,999..999,999,999]. If there is an associated time offset, including 00:00, the date-time value has a UTC form and is comparable to all other date-time values that have UTC forms. If there is no associated time offset, the time is taken to be a local time of day at some location, according to the time zone rules for that location. When the time zone is specified, e.g., using the IANA tz form (see 10.3.4.1), the date-time value may be converted to a UTC form using the time zone rules for that location, if applicable.

Note: projecting timezone rules into the future may only be safe for near-term date-time values.

A date and time *d* that has a UTC form can be represented as a number of seconds since a reference date and time (called the epoch). We write *valuedt(d)* to represent the number of seconds between *d* and the epoch. The *valuedt* function is one- to-one and so it has an inverse function *valuedt ^-1^*. _E.g.,_ *valuedt^-1^(valuedt(d)) = d. valuedt ^-1^* returns *null* rather than a date with a year outside the legal range.

====== days and time duration

Days and time durations in FEEL can be expressed using either a duration literal (see grammar rule 65) or the duration() built-in function (See 10.3.4.1). We use boldface days and time duration literals to represent values in the semantic domain. The literal format of the characters within the quotes of the string literal is defined by the lexical space of the XPath Data Model dayTimeDuration datatype. A days and time duration in the semantic domain is a sequence of numbers for the days, hours, minutes, and seconds of duration, normalized such that the sum of these numbers is minimized. For example, FEEL(_duraion("P0DT25H")_) = *P1DT1H*.

The value of a days and time duration can be expressed as a number of seconds. _E.g._, *valuedtd(P1DT1H) = 90000.* The *valuedtd* function is one-to-one and so it has an inverse function *valuedtd -1*. _E.g.,_ *valuedtd ^-1^(90000) = P1DT1H.*

====== years and months duration

Years and months durations in FEEL can be expressed using either a duration literal (see grammar rule 65) or the duration() built-in function (See 10.3.4.1). We use boldface years and month duration literals to represent values in the semantic domain. The literal format of the characters within the quotes of the string literal is defined by the lexical space of the XPath Data Model yearMonthDuration datatype. A years and months duration in the semantic domain is a pair of numbers for the years and months of duration, normalized such that the sum of these numbers is minimized. For example, FEEL(_duraion("P0Y13M")_) = *P1Y1M*.

The value of a years and months duration can be expressed as a number of months. _E.g._, *value~ym~d(P1Y1M) = 13.* The *valueymd* function is one-to-one and so it has an inverse function *valueymd -1*. _E.g.,_ *valueymd ^-1^(13) = P1Y1M.*

===== Ternary logic

FEEL, like SQL and PMML, uses of ternary logic for truth values. This makes *and* and *or* complete functions from _*D* x *D* → *D*_. Ternary logic is used in Predictive Modeling Markup Language to model missing data values.

===== Lists and filters

Lists are immutable and may be nested. The _first_ element of a list _L_ can be accessed using _L[1]_ and the _last_ element can be accessed using _L[-1]_. The _n^th^_ element from the beginning can be accessed using _L[n],_ and the _n^th^_ element from the end can be accessed using _L[-n]_.

If FEEL(_L_) = *L* is a list in the FEEL semantic domain, the first element is FEEL(_L[1]_) = *L[1]*. If *L* does not contain *n* items, then *L[n] is null*.

*L* can be filtered with a Boolean expression in square brackets. The expression in square brackets can reference a list element using the name _item_, unless the list element is a context that contains the key *"item"*. If the list element is a context, then its context entries may be referenced within the filter expression without the _'item.'_ prefix. For example:

____
_[1, 2, 3, 4][item > 2] = [3, 4]_

_[ \{x:1, y:2}, \{x:2, y:3} ][x=1] = [\{x:1, y:2}]_
____

The filter expression is evaluated for each item in list, and a list containing only items where the filter expression is *true* is returned. E.g:

____
{empty}[ \{x:1, y:2}, \{x:null, y:3} ][x < 2] = [\{x:1, y:2}]
____

The expression to be filtered is subject to implicit conversions (10.3.2.9.4) before the entire expression is evaluated.

For convenience, a selection using the "." operator with a list of contexts on its left hand side returns a list of selections, _i.e._ FEEL(_e.f,_ *c*) = *[* FEEL(_f_, *c'*)*,* FEEL(_f_, *c"*)*, ... ]* where FEEL(_e_) = *[ e', e", ... ]* and *c'* is *c* augmented with the context entries of *e'*, *c"* is *c* augmented with the context entries of *e"*, etc. For example,

____
_[ \{x:1, y:2}, \{x:2, y:3} ].y = [2,3]_
____

===== Context

A FEEL context is a partially ordered collection of (key, expression) pairs called context entries. In the syntax, keys can be either names or strings. Keys are mapped to strings in the semantic domain. These strings are distinct within a context. A context in the domain is denoted using bold FEEL syntax with string keys, _e.g._ *\{ "key1" : expr1, "key2" : expr2, ... }*.

The syntax for selecting the value of the entry named _key1_ from context-valued expression _m_ is _m.key1._

If _key1_ is not a legal name or for whatever reason one wishes to treat the key as a string, the following syntax is allowed: _get value(m, "key1 ")._ Selecting a value by key from context *m* in the semantic domain is denoted as *m.key1* or *get value(m, "key1")*

To retrieve a list of key,value pairs from a context _m_, the following built-in function may be used__: get entries(m).__ For example, the following is true:

____
_get entries(\{key1: "value1 "})[key= "key1 "].value = "value1"_
____

An expression in a context entry may not reference the key of the same context entry, but may reference keys (as QNs) from previous context entries in the same context, as well as other values (as QNs) in scope.

These references SHALL be acyclic and form a partial order. The expressions in a context SHALL be evaluated consistent with this partial order.

===== Ranges

FEEL supports a compact syntax for a range of values, useful in decision table test cells and elsewhere. Ranges can be syntactically represented either:

[loweralpha]
. {blank}
. {blank}

as a comparison operator and a single endpoint (grammar rule 7.a.)or a pair of endpoints and endpoint inclusivity flags that indicate whether one or both endpoints are included in the range (grammar rule 7.b.); on this case, endpoints must be of equivalent types (see section 10.3.2.9.1for the definition of type equivalence) and the endpoints must be ordered such that range start <= range end.Endpoints can be either a literal or a qualified name of the following types: number, string, date, time, date and time, or duration. The following are examples of valid ranges:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

< 10>= date(“2019-03-31”)>= @”2019-03-31”<= duration(“PT01H”)<= @”PT01H”[ 5 .. 10 ]( birthday .. @”2019-01-01” ) Ranges are mapped into the semantic domain as a typed instance of the _range_ type. If the syntax with a single endpoint and an operator is used, then the other endpoint is undefined (represented by a null value) and the inclusivity flag is set to false. E.g.:

[#_Toc87278972 .anchor]##*Table 42: Examples of range properties values*

.[#_Toc87278986 .anchor]##*Table 56: General semantics of addition and subtraction*
[width="100%",cols="22%,19%,20%,19%,20%",options="header",]
|===
a|
____
*range*
____

a|
____
*start included*
____

a|
____
*start*
____

a|
____
*end*
____

a|
____
*end included*
____

a|
____
{empty}[1..10]
____

a|
____
true
____

a|
____
1
____

a|
____
10
____

a|
____
true
____

a|
____
(1..10]
____

a|
____
false
____

a|
____
1
____

a|
____
10
____

a|
____
true
____

a|
____
<= 10
____

a|
____
false
____

a|
____
null
____

a|
____
10
____

a|
____
true
____

a|
____
> 1
____

a|
____
false
____

a|
____
1
____

a|
____
null
____

a|
____
false
____

|===

===== Functions

The FEEL function literal is given by grammar rule 55. Functions can also be specified in *DMN* via Function Definitions (see 6.3.9). The constructed type (__T__1, . . . , _Tn_) → _U_ contains the function values that take arguments of types _T1, . . . , Tn_ and yield results of type _U,_ regardless of the way the function syntax (e.g., FEEL literal or *DMN* Function Definition). In the case of exactly one argument type _T_ → _U_ is a shorthand for (_T_ ) → _U_.

===== Relations between types

Every FEEL expression executed in a certain context has a value in *D*, and every value has a type. The FEEL types are organized as a lattice (see Figure 10‑26), with upper type _Any_ and lower type _Null_. The lattice determines the conformance of the different types to each other. For example, because comparison is defined only between values with conforming types, you cannot compare a number with a boolean or a string.

We define *type(*_e_*)* as the type of the domain element *FEEL(*_e,_ *c),* where _e_ is an expression defined by grammar rule 1. Literals for numbers, strings, booleans, null, date, time, date and time and duration literals are mapped to the corresponding node in lattice *L*. Complex expression such as list, contexts and functions are mapped to the corresponding parameterized nodes in lattice *L*. . For example, see *Table _43_*.

.[#_Toc87278987 .anchor]##*Table 57: Specific semantics of addition and subtraction*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
_e_
____

a|
____
*type(*_e_*)*
____

a|
____
_123_
____

a|
____
number
____

a|
____
_true_
____

a|
____
boolean
____

a|
____
_"abc"_
____

a|
____
string
____

a|
____
_date("2017-01-01 ")_
____

a|
____
date
____

a|
____
_["a", "b", "c"]_
____

a|
____
list<string>
____

a|
____
_["a", true, 123]_
____

a|
____
list<Any>
____

a|
____
[1..10)
____

a|
____
range<number>
____

a|
____
>= @”201 9-01-01”
____

a|
____
range<date>
____

a|
____
e
____

a|
____
type(e)
____

a|
____
\{"name": "Peter", age: 30}
____

a|
____
context<”age”: number, “name”:string>
____

a|
____
function f(x: number, y: number) x + y
____

a|
____
(number, number) → number
____

a|
____
DecisionA

where the typeRef of DecisionA is <itemDefinition name="Employee">

<itemComponent name="id">

<typeRef>number</typeRef>

</itemComponent>

<itemComponentname="name"> <typeRef>string</typeRef> </itemComponent>

</itemDefinition>
____

a|
____
context<”id”:number, “name”:string>
____

a|
____
BkmA

where the encapsulated logic is <encapsulatedLogic>

<formalParameter name="x" typeRef=" number" />

<formalParameter name="y" typeRef=" number" />

<literalExpression typeRef="number"> <text>x + y</text>

</literalExpression>

</encapsulatedLogic>
____

a|
____
(number, number) → number
____

|===

A type expression _e_ defined by grammar rule 54 is mapped to the nodes in the lattice *L* by function *type(*_e_*)* as follows: primitive data type names are mapped to the node with the same name (e.g. _string_ is mapped the *string* node)

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

_Any_ is mapped to the node *Any*_Null_ is mapped to the node *Null*_list< T>_ is mapped to the *list* node with the parameter *type(*_T_*)*_context(k1:T1, ..., k~n~:T~n~> where n≥1_ is mapped to the *context* node with parameters k1: *type(*_T1_*)*, ..., k~n~: *type(*_T~n~_*)*_function< T1, ... T~n~> -> T_ is mapped to the *function* node with signature *type(*_T1_*)*, ..., *type(*_T~n~_*)* -> *type(*_T_**)**Type names defined in the _itemDefinitions_ section are mapped similarly to the context types (see rule above).If none of the above rules can be applied (e.g. type name does not exist in the decision model) the type expression is semantically incorrect.We define two relations between types:

* {blank}
* {blank}

====== Equivalence (T ≡ S): Types T and S are interchangeable in all contexts.Conformance (T <:S): An instance of type T can be substituted at each place where an instance of type S is expected.Type Equivalence

The equivalence relationship (≡) between types is defined as follows:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

Primitive datatypes are equivalent to themselves, e.g., string ≡ string.Two list types _list< T>_ and _list<S>_ are equivalent iff _T_ is equivalent to _S_. For example, the types of [“a”, “b”] and [“c”] are equivalent.Two context types _context<k~1~: T~1~, ..., k~n~: T~n~>_ and _context<l~1~: S ~1~, ..., l~m~: S~m~>_ are equivalent iff n = m and for every _k~i~ :T~i~_ there is a unique _l~j~ :S~j~_ such that _k~i~ = l~j~_ and _T~i~_ ≡ _S~j~_ for i = 1, n. Context types are the types defined via ItemDefinitions or the types associated to FEEL context literals such as \{ “name”: “John”, “age”: 25}.Two function types (_T~1~, ..., T~n~) →U_ and (_S~1~, ..., S~m~) →V_ are equivalent iff n = m, _T~i~_ ≡ _S~j~_ for i = 1, n and _U_ ≡ _V_.Two range types _range< T>_ and _range<S>_ are equivalent iff _T_ is equivalent to _S_. For example, the types of [1..10] and [30..40] are equivalent.Type equivalence is transitive: if _type1_ is equivalent to _type2_, and _type2 is equivalent to type3_, then _type1_ is equivalent to _type3_.

====== Type Conformance

The conformance relation (<:) is defined as follows:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

Conformance includes equivalence. If _T_ ≡ _S_ then _T_ <: __S__For every type _T_, _Null_ <: _T_ <: _Any,_ where _Null_ is the lower type in the lattice and _Any_ the upper type in the lattice.The list type _list< T>_ conforms to _list<S>_ iff _T_ conforms to __S.__The context type _context<k~1~: T~1~, ..., k~n~: T~n~>_ conforms to _context<l~1~: S ~1~, ..., l~m~: S~m~>_ iff n ≥ m and for every _li : S~i~_ there is a unique _~kj:Tj~_ such that _l~i~ = k~j~_ and _T~j~_ <: _S~i~_ for i = 1, mThe function type (_T~1~, ..., T~n~) →U_ conforms to type (_S~1~, ..., S~m~) →V_ iff n = m, _S~i~_ <: _T~i~_ for i = 1, n and _U_ <: _V_. The FEEL functions follow the “contravariant function argument type” and “covariant function return type” principles to provide type safety.The range type _range< T>_ conforms to _range< S>_ iff T conforms to S. Type conformance is transitive: if _type1_ conforms to _type2_, and _type2_ conforms to _type3_ , then _type1_ conforms to _type3_.

____
image:extracted-media/media/image99.png[image,width=644,height=386]
____

[#_Toc87278865 .anchor]##*Figure 10‑26: FEEL lattice type*

====== Examples

Let us consider the following ItemDefinitions:

____
<itemDefinition name="Employee1"> <itemComponent name="id">

<typeRef>number</typeRef> </itemComponent>

<itemComponent name="name"> <typeRef>string</typeRef> </itemComponent>

</itemDefinition>

<itemDefinition name="Employee2"> <itemComponent name="name">

<typeRef>string</typeRef> </itemComponent>

<itemComponent name="id">

<typeRef>number</typeRef>

</itemComponent> </itemDefinition>

<itemDefinition name="Employee3"> <itemComponent name="id">

<typeRef>number</typeRef> </itemComponent>

<itemComponent name="name"> <typeRef>string</typeRef> </itemComponent>

<itemComponent name="age">

<typeRef>number</typeRef> </itemComponent>

</itemDefinition>

<itemDefinition isCollection=”true” name="Employee3List">

<itemComponent name="id">

<typeRef>number</typeRef> </itemComponent>

<itemComponent name="name"> <typeRef>string</typeRef> </itemComponent>

<itemComponent name="age">

<typeRef>number</typeRef> </itemComponent>

</itemDefinition>

and the decisions _Decision1_ , _Decision2, Decision3 and Decision4_ with corresponding _typeRefs Employee1_ , _Employee2,_

_Employee3_ and _Employee3List_.

*Table _44_* provides examples for _equivalence to_ and _conforms to_ relations.
____

.[#_Toc87278988 .anchor]##*Table 58: General semantics of multiplication and division*
[width="100%",cols="27%,24%,24%,25%",options="header",]
|===
a|
____
*type1*
____

a|
____
*type2*
____

a|
____
*equivalent to*
____

a|
____
*conforms to*
____

a|
____
number
____

a|
____
number
____

a|
____
True
____

a|
____
True
____

a|
____
string
____

a|
____
string
____

a|
____
True
____

a|
____
True
____

a|
____
string
____

a|
____
date
____

a|
____
False
____

a|
____
False
____

| | | |
a|
____
date
____

a|
____
date and time
____

a|
____
False
____

a|
____
False
____

a|
____
*type(*_Decision 1_*)*
____

a|
____
*type(*_Decision2_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type(*_Decision1_*)*
____

a|
____
*type(*_Decision3_*)*
____

a|
____
False
____

a|
____
False
____

a|
____
*type(*_Decision3_*)*
____

a|
____
*type(*_Decision1_*)*
____

a|
____
False
____

a|
____
True
____

a|
____
*type(*_Decision 1_*)*
____

a|
____
*type(*_\{"id": 1, "name " :"Peter"}_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type(*_\{"id": 1, "name " :"Peter"}_*)*
____

a|
____
*type(*_Decision3_*)*
____

a|
____
False
____

a|
____
False
____

a|
____
*type(*_\{"id": 1, "name":"Peter", "age": 45}_*)*
____

a|
____
*type(*_Decision1_*)*
____

a|
____
False
____

a|
____
True
____

a|
____
*type(*_\{"id": 1, "name":"Peter", "age": 45}_*)*
____

a|
____
*type(*_Decision3_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type*_([1, 2, 3]*)*_
____

a|
____
*type*_(["1 ", "2", "3"]*)*_
____

a|
____
False
____

a|
____
False
____

a|
____
*type*_([1, 2, 3]*)*_
____

a|
____
*type(*_Decision3_*)*
____

a|
____
False
____

a|
____
False
____

a|
____
*type(*_[\{"id": 1, "name":"Peter", "age": 45}]_*)*
____

a|
____
*type(*_Decision4_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type(*_Decision4_*)*
____

a|
____
*type(*_Decision3_*)*
____

a|
____
False
____

a|
____
False
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
*type(*_function(x:Employee 1 ) →Employee2_*)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type(*_function(x:Employee 1 ) →Employee3_*)*
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
False
____

a|
____
True
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
*type(*_function(x:Employee 1 ) →Employee1_*)*
____

a|
____
False
____

a|
____
False
____

a|
____
*type(* [1..10] *)*
____

a|
____
*type(* (20..100) *)*
____

a|
____
True
____

a|
____
True
____

a|
____
*type1*
____

a|
____
*type2*
____

a|
____
equivalent to
____

a|
____
conforms to
____

a|
____
*type( [1..10] )*
____

a|
____
*type( [“a”..”x”] )*
____

a|
____
False
____

a|
____
False
____

|===

====== Type conversions

The type of a FEEL expression _e_ is determined from the value *e* = FEEL(_e_, *_s_*) in the semantic domain, where *_s_* is a set of variable bindings (see 10.3.2.11and 10.3.2.12). When an expression appears in a certain context it must be compatible with a type expected in that context, called the _target type_. After the type of the expression is deduced, an implicit conversion from the type of the expression to the target type can be performed sometimes. If an implicit conversion is mandatory but it cannot be performed the result is *null*.

There are several possible type conversions:

____
- _to singleton list_:

When the type of the expression is T and the target type is List<T> the expression is converted to a singleton list.
____

- _from singleton list_:

____
When the type of the expression is List<T>, the value of the expression is a singleton list and the target type is T, the expression is converted by unwraping the first element.

- _conforms to:_

When the type of the expression is T~1~, the target type is T~2~, and T~1~ conforms to T~2~ the value of expression remains unchanged. Otherwise the result is *null*.
____

There are several kinds of contexts in which implicit conversions may occur:

____
- Filter context (10.3.2.5) in which a filter expression is present. The expression to be filtered is subject to implicit conversion _to singleton list_.

- Invocation context (*Table _63_*) in which an argument is bound to a formal parameter of a function. The arguments are subject to implicit conversion _from singleton list_.

- Binding contexts in which the value of an expression is bound to a variable with associated type information (e.g. binding actual parameters to formal parameters in an invocation, or binding the result of a decision’s logic to the decision’s output variable). The expression is subject to _conforms to_ conversion.
____

=======  Examples

The table below contains several examples for singleton list conversions.

.[#_Toc87278989 .anchor]##*Table 59: Specific semantics of multiplication and division*
[width="100%",cols="34%,33%,33%",options="header",]
|===
a|
____
*Expression*
____

a|
____
*Conversion*
____

a|
____
*Result*
____

a|
____
_3[item > 2]_
____

a|
____
_3_ is converted to _[3]_ as this a filter context, and an _to singleton list_ is applied
____

a|
____
*[3]*
____

a|
____
_contains(["foobar"], "of")_
____

a|
____
_["foobar"]_ is converted to _"foobar"_, as this is an invocation context and _from singleton list_ is applied
____

a|
____
*false*
____

|===

In the example below, before binding variable _decision_003_ to value _"123"_ the conversion to the target type (number) fails, hence the variable is bound to _null_.

____
<**decision name="decision_003" id="_decision_003"**> <**variable name="decision_003"** *typeRef="number"/>* <**literalExpression**>

<**text**>”_”123_”</**text**>

</**literalExpression**>

</**decision**>
____

===== Decision Table

The normative notation for decision tables is specified in Clause 8. Each input expression SHALL be a textual expression (grammar rule 2). Each list of input values SHALL be an instance of unary tests (grammar rule 15). The value that is tested is the value of the input expression of the containing InputClause. Each list of output values SHALL be an instance of unary tests (grammar rule 15). The value that is tested is the value of a selected output entry of the containing OutputClause. Each input entry SHALL be an instance of unary tests (grammar rule 15). Rule annotations are ignored in the execution semantics.

The decision table components are shown in Figure 8‑5: Rules as rows – schematic layout, and also correspond to the metamodel in clause 8.3 For convenience, Figure 8‑5 is reproduced here.

.[#_Toc87278990 .anchor]##*Table 60: Semantics of exponentiation*
[width="100%",cols="10%,30%,32%,28%",]
|===
a|
____
*information item n**ame*
____

| | |
a|
____
H
____

a|
____
input expression 1
____

a|
____
input expression 2
____

a|
____
Output label
____

| a|
____
input value 1a,

input value 1b
____

a|
____
input value 2a,

input value 2b
____

a|
____
output value 1a,

output value 1b
____

a|
____
1
____

a|
____
input entry 1.1
____

a|
____
input entry 2.1
____

a|
____
output entry 1.1
____

a|
____
2
____

| a|
____
input entry 2.2
____

a|
____
output entry 1.2
____

a|
____
3
____

a|
____
input entry 1.2
____

a|
____
-
____

a|
____
output entry 1.3
____

|===

The semantics of a decision table is specified by first composing its literal expressions and unary tests into Boolean expressions that are mapped to the semantic domain, and composed into rule matches then rule hits. Finally, some of the decision table output expressions are mapped to the semantic domain and comprise the result of the decision table interpretation. Decision table components are detailed in *Table _46_*.

.[#_Toc87278991 .anchor]##*Table 61: Semantics of type-checking*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Component name (* means optional)*
____

a|
____
*Description*
____

a|
____
input expression
____

a|
____
One of the N>=0 input expressions, each a literal expression
____

a|
____
input values*
____

a|
____
One of the N input values, corresponding to the N input expressions. Each is a unary tests literal (see below).
____

a|
____
output values*
____

a|
____
A unary tests literal for the output.

(In the event of M>1 output components (see Figure 8‑12), each output component may have its own output values)
____

a|
____
rules
____

a|
____
a list of R>0 rules. A rule is a list of N input entries followed by M output entries. An input entry is a unary tests literal. An output entry is a literal expression.
____

a|
____
hit policy*
____

a|
____
one of: "U", "A", “P”, “F”, "R", "O", "C", "C+", "C#", "C<", “C>” (default is "U")
____

a|
____
default output value*
____

a|
____
The default output value is one of the output values. If M>1, then default output value is a context with entries composed of output component names and output values.
____

|===

Unary tests (grammar rule 15) are used to represent both input values and input entries. An input expression _e_ is said to _satisfy_ an input entry _t_ (with optional input values _v_), depending on the syntax of _t_, as follows:

* {blank}
* {blank}
* {blank}
* {blank}

grammar rule 1 5.a: FEEL(_e in (t)_)**=true**grammar rule 1 5.b: FEEL(_e in (t)_)**=false**grammar rule 1 5.c when _v_ is not provided: **e != null**grammar rule 1 5.c when _v_ is provided: FEEL(_e in (v)_)**=true**A rule with input entries _t1,t2,...,tN_ is said to _match_ the input expression list _[e1,e2,...,eN]_ (with optional input values list _[v1,v2, ...vN]_) if _ei satisfies ti_ (with optional input values _vi_) for all _i_ in 1 ..N.

A rule is _hit_ if it is matched and the hit policy indicates that the matched rule's output value should be included in the decision table result. Each hit results in one output value (multiple outputs are collected into a single context value). Therefore, multiple hits require aggregation.

The hit policy is specified using the initial letter of one of the following boldface policy names.

Single hit policies:

* {blank}
* {blank}
* {blank}
* {blank}

*Unique* – only a single rule can be matched.*Any* – multiple rules can match, but they all have the same output,*Priority* – multiple rules can match, with different outputs. The output that comes first in the supplied _output values_ list is returned,*First* – return the first match in rule order,Multiple hit policies:

* {blank}
* {blank}
* {blank}

*Collect* – return a list of the outputs in arbitrary order,*Rule order* – return a list of outputs in rule order,*Output order* – return a list of outputs in the order of the _output values_ list The Collect policy may optionally specify an _aggregation_, as follows:

* {blank}
* {blank}
* {blank}
* {blank}

*C+* – return the sum of the outputs**C#** – return the count of the outputs**C<** – return the minimum-valued output *C>* – return the maximum-valued outputThe _aggregation_ is defined using the following built-in functions specified in clause 10.3.4.4: _sum, count, minimum, maximum_. To reduce complexity, decision tables with compound outputs do not support aggregation and support only the following hit policies: _Unique_, _Any_, _Priority, First_, _Collect without operator_, and _Rule order_.

A decision table may have no rule hit for a set of input values. In this case, the result is given by the default output value, or *null* if no default output value is specified. A complete decision table SHALL NOT specify a default output value.

____
The semantics of a decision table invocation *DTI* are as follows:

{empty}1. Every rule in the rule list is matched with the input expression list. Matching is unordered.

{empty}2. If no rules match,
____

[loweralpha]
. {blank}
. {blank}

____
if a default output value _d_ is specified, **DTI=**FEEL(_d_)else *DTI=null*.3. Else let _m_ be the sublist of rules that match the input expression list. If the hit policy is "First" or "Rule order", order _m_ by rule number.
____

[loweralpha]
. {blank}
. {blank}
. {blank}

===== Let _o_ be a list of output expressions, where the expression at index _i_ is the output expression from rule _m[i]_. The output expression of a rule in a single output decision table is simply the rule's output entry. The output expression of a multiple output decision table is a context with entries composed from the output names and the rule's corresponding output entries. If the hit policy is "Output order", the decision table SHALL be single output and _o_ is ordered consistent with the order of the _output values_. Rule annotations are ignored for purposes of determining the expression value of a decision table.If a multiple hit policy is specified, DTI=FEEL(aggregation(o)), where aggregation is one of the built-in functions _sum, count, minimum_ as specified in clause 10.3.4.4.else **DTI=**FEEL(_o[1]_).Scope and context stack

A FEEL expression _e_ is always evaluated in a well-defined set of name bindings that are used to resolve QNs in _e_. This set of name bindings is called the scope of _e_. Scope is modeled as a list of contexts. A scope *s* contains the contexts with entries that are in scope for _e_. The last context in *s* is the _built-in_ context. Next to last in *s* is the _global_ context. The first context in *s* is the context immediately containing _e_ (if any). Next are enclosing contexts of _e_ (if any).

The QN of _e_ is the QN of the first context in *s* appended with .N, where N is the name of entry in the first context of *s* containing _e._ QNs in _e_ are resolved by looking through the contexts in *s* from first to last.

====== Local context

If _e_ denotes the value of a context entry of context *m*, then *m* is the local context for _e_, and *m* is the first element of *s.* Otherwise, _e_ has no local context and the first element of *s* is the global context, or in some cases explained later, the first element of *s* is a special context.

All of the entries of *m* are in-scope for _e_, but the _depends on_ graph SHALL be acyclic. This provides a simple solution to the problem of the confusing definition above: if *m* is the result of evaluating the context expression _m_ that contains _e_, how can we know it in order to evaluate _e_? Simply evaluate the context entries in _depends on_ order.

====== Global context

The global context is a context created before the evaluation of _e_ and contains names and values for the variables defined outside expression _e_ that are accessible in _e_. For example, when _e_ is the body of a decision _D_, the global context contains entries for the information requirements and knowledge requirements of _D_ (_i.e.,_ names and logic of the business knowledge models, decisions and decision services required by _D)_.

====== Built-in context

The built-in context contains all the built-in functions.

======  Special context

Some FEEL expressions are interpreted in a _special_ context that is pushed on the front of *s*. For example, a filter expression is repeatedly executed with special first context containing the name 'item' bound to successive list elements. A function is executed with a special first context containing argument name->value mappings.

Qualified names (QNs) in FEEL expressions are interpreted relative to *s*. The meaning of a FEEL expression _e_ in scope *s* is denoted as *FEEL(*_e,_ *s)*. We can also say that _e_ evaluates to *e* in scope *s*, or *e* = *FEEL(*_e,_ *s)*. Note that *e* and *s* are elements of the FEEL domain. *s* is a list of contexts.

===== Mapping between FEEL and other domains

A FEEL expression _e_ denotes a value *e* in the semantic domain. Some kinds of values can be passed between FEEL and external Java methods, between FEEL and external PMML models, and between FEEL and XML, as summarized in *Table _47_*. An empty cell means that no mapping is defined.

.[#_Toc87278992 .anchor]##*Table 62: Semantics of negative numbers*
[width="100%",cols="20%,26%,22%,32%",options="header",]
|===
a|
____
*_FEEL value_*
____

a|
____
*_Java_*
____

a|
____
*_XML_*
____

a|
____
*_PMML_*
____

a|
____
number
____

a|
____
java.math.BigDecimal
____

a|
____
decimal
____

|decimal, PROB-NUMBER, +
PERCENTAGE-NUMBER
| | a|
____
integer
____

a|
____
integer , INT-NUMBER
____

| | a|
____
double
____

a|
____
double, REAL-NUMBER
____

a|
____
string
____

a|
____
java.lang.String
____

a|
____
string
____

a|
____
string, FIELD-NAME
____

a|
____
date, time, date and time
____

a|
____
javax.xml.datatype. XMLGregorianCalendar
____

a|
____
date, dateTime, time, dateTimestamp
____

a|
____
date, dateTime, time conversion required for dateDaysSince, _et. al._
____

a|
____
duration
____

a|
____
javax.xml.datatype. Duration
____

a|
____
yearMonthDuration, dayTimeDuration
____

|
a|
____
boolean
____

a|
____
java.lang.Boolean
____

a|
____
boolean
____

a|
____
boolean
____

a|
____
list
____

a|
____
java.util.List
____

a|
____
contain multiple child elements
____

a|
____
array (homogeneous)
____

a|
____
context
____

a|
____
java.util.Map
____

a|
____
contain attributes and child elements
____

|
|===

Sometimes we do not want to evaluate a FEEL expression _e_, we just want to know the type of *e*_._ Note that if _e_ has QNs, then a context may be needed for type inference. We write *type(*_e_*)* as the type of the domain element *FEEL(*_e,_ *c)*.

===== Functions Seamantics

FEEL functions can be:

* {blank}
* {blank}
* {blank}

====== built-in, _e.g._, +
_sum_ (see clause 10.3.4.4), oruser-defined, _e.g., +
function(age) age < 21_, orexternally defined, _e.g._, +
_function(angle) external \{ +
java: \{ +
class: “java.lang.Math ”, +
method signature: “cos(double)” +
}}_ Built-in Functions

The built-in functions are described in detail in section 10.3.4. In particular, function signatures and parameter domains are specified. Some functions have more than one signature.

Built-in functions are invoked using the same syntax as other functions (grammar rule 40). The actual parameters must conform to the parameter domains in at least one signature before or after applying implicit conversions, or the result of the invocation is *null*.

====== User-defined functions

User-defined functions (grammar rule 55) have the form

____
_function(X1, ... Xn) body_
____

The terms _X1, ... Xn_ are formal parameters. Each formal parameter has the form _ni_ or _ni_ :_ti_, where the _ni_ are the parameter names and _ti_ are their types. If the type isn’t specified, _Any_ is assumed. The meaning of FEEL(_function(X1, ... X~n~) body_, *s*) is an element in the FEEL semantic domain that we denote as *function(argument list: [*_X1, ... X~n~_*], body:* _body_*, scope: s)* (shortened to *f* below). FEEL functions are lexical closures, _i.e.,_ the _body_ is an expression that references the formal parameters and any other names in scope *s*.

User-defined functions are invoked using the same syntax as other functions (grammar rule 38). The meaning of an invocation _f(n1:e1,_..._,nn:en)_ in scope *s* is FEEL(_f,_ *s*) applied to arguments __n1:__FEEL(_e1,_ *s*)... __,nn:__FEEL(_en,_ *s*). This can also be written as **f(n**1:**e**1... _,_*n*~n~:*e*~n~).

The arguments **n**1:**e**1... _,_*n*~n~:*e*~n~ conform to the argument list *[*_X1, ... X~n~_*]* if **type(e**i**)** conforms to _ti_ before or after applying implicit conversions or _ti_ is not specified in _Xi_, for all _i_ in _1. .n._ The result of applying *f* to the interpreted arguments **n**1:**e**1... _,_*n*~n~:*e*~n~ is determined as follows. If *f* is not a function, or if the arguments do not conform to the argument list, the result of the invocation is *null*. Otherwise, let *c* be a context with entries **n**1:**e**1... _,_*n*~n~:*e*~n~. The result of the invocation is FEEL(_body, *s’*_), where *s'* = insert before(*s*, 1, *c*) (see 10.3.4.4).

Invocable elements (Business Knowledge Models or Decision Services) are invoked using the same syntax as other functions (grammar rule 38). An Invocable is equivalent to a FEEL function whose parameters are the invocable’s inputs (see 10.4)

====== Externally-defined functions

FEEL externally-defined functions have the following form +
_function (X1, ... X~n~) external mapping-information_

Mapping-information is a context that SHALL have one of the following forms:

____
_\{_

_java: \{class: class-name, method signature: method-signature}_

_}_

or

_\{_

_pmml: \{document: IRI, model: model-name}_

_}_
____

The meaning of an externally defined function is an element in the semantic domain that we denote as *function(argument list: [*_X1, ... X~n~_*], external: mapping-information)*.

The _java_ form of the mapping information indicates that the external function is to be accessed as a method on a Java class. The _class-name_ SHALL be the string name of a Java class on the classpath. Classpath configuration is implementation-defined. The _method-signature_ SHALL be a string consisting of the name of a public static method in the named class, followed by an argument list containing only Java argument type names. The argument type information SHOULD be used to resolve overloaded methods and MAY be used to detect out-of-domain errors before runtime.

The _pmml_ form of the mapping information indicates that the external function is to be accessed as a PMML model. The _IRI_ SHALL be the resource identifier for a PMML document. The _model-name_ is optional. If the _model-name_ is specified, it SHALL be the name of a model in the document to which the _IRI_ refers. If no _model-name_ is specified, the external function SHALL be the first model in the document.

When an externally-defined function is invoked, actual argument values and result value are converted when possible using the type mapping table for Java or PMML (see *Table _47_*). When a conversion is not possible, *null* is substituted. If a result cannot be obtained, _e.g._ an exception is thrown, the result of the invocation is *null*. If the externally-defined function is of type PMML, and PMML invocation results in a single predictor output, the result of the externally-defined function is the single predictor output's value.

Passing parameter values to the external method or model requires knowing the expected parameter types. For Java, this information is obtained using reflection. For PMML, this information is obtained from the mining schema and data dictionary elements associated with independent variables of the selected model.

Note that *DMN* does not completely define the semantics of a Decision Model that uses externally-defined functions. Externally-defined functions SHOULD have no side-effects and be deterministic.

====== Function name

To name a function, define it as a context entry. For example:

____
_\{_

_isPositive : function(x) x > 0,_

_isNotNegative : function(x) isPositive(x+ 1), result: isNotNegative(0)_

_}_
____

======  Positional and named parameters

An invocation of any FEEL function (built-in, user-defined, or externally-defined) can use positional parameters or named parameters. If positional, all parameters SHALL be supplied. If named, unsupplied parameters are bound to *null*.

===== For loop expression

The _for loop expression_ iterates over lists of elements or ranges of numbers. The general syntax is:

_for i~1~ in ic~1~ [, i~2~ in ic~2~ [, ...]] return e_

where:

* {blank}
* {blank}
* {blank}

_ic~1~, ic~2~, ..., ic~n~_ are _iteration contextsi~1~, i~2~, ..., i~n~_ are variables bound to each element in the _iteration contexte_ is the *return* expressionAn _iteration context_ may either be an expression that returns a list of elements, or two expressions that return integers connected by “..”. Examples of valid iteration contexts are:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

[ 1, 2, 3]a list1..1050..40x..x+10A _for loop expression_ will iterate over each element in the _iteration context_, binding the element to the corresponding variable _i~n~_ and evaluating the expression _e_ in that scope.

When the _iteration context_ is a range of numbers, the _for loop expression_ will iterate over the range incrementing or decrementing the value of _i~n~_ by 1, depending if the range is ascendant (when the resulting integer from the first expression is lower than the second) or descendant (when the resulting integer from the first expression is higher than the second).

The result of the _for loop expression_ is a list containing the result of the evaluation of the expression _e_ for each individual iteration in order.

The expression _e_ may also reference an implicitly defined variable called “*_partial_*” that is a list containing all the results of the previous iterations of the expression. The variable “*_partial_*” is immutable. E.g.: to calculate the factorial list of numbers, from 0 to N, where N is a non-negative integer, one may write:

____
_for i in 0..N return if i = 0 then 1 else i * partial[-1]_
____

When multiple _iteration contexts_ are defined in the same _for loop expression_, the resulting iteration is a cross-product of the elements of the _iteration contexts_. The iteration order is from the inner _iteration context_ to the outer _iteration context_.

____
E.g., the result of the following _for loop expression_ is:

_for i in [i~1~,i~2~], j in [j~1~j~2~] return e *= [ r~1~, r~2~, r~3~, r~4~ ]*_

Where:

*_r~1~ = FEEL( e, \{ i: i~1~, j: j~1~, partial:[], ... } )_*

*_r~2~ = FEEL( e, \{ i: i~1~, j: j~2~, partial:[r~1~], ... )_*

*_r~3~ = FEEL( e, \{ i: i~2~, j: j~1~, partial:[r~1~,r~2~], ... } )_*
____

*_r~4~ = FEEL( e, \{ i: i~2~, j: j~2~, partial:[r~1~,r~2~,r~3~], ... } )_*

===== Semantic mappings

The meaning of each substantive grammar rule is given below by mapping the syntax to a value in the semantic domain. The value may depend on certain input values, themselves having been mapped to the semantic domain. The input values may have to obey additional constraints. The input domain(s) may be a subset of the semantic domain. Inputs outside of their domain result in a *null* value, unless the implicit conversion _from singleton list_ (10.3.2.9.4) can be applied.

.[#_Toc87278993 .anchor]##*Table 63: Semantics of invocation*
[width="100%",cols="17%,31%,52%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Mapped to Domain*
____

a|
____
55
____

a|
____
_function(n1, ...nN) e_
____

a|
____
*function(argument list: [*_n1, ... nN_*], body:* _e_*, scope: s)*
____

a|
____
55
____

a|
____
_function(n1, ...nN) external e_
____

a|
____
*function(argument list: [*_n1, ... nN_*], external: e)*
____

|===

See 10.3.2.7.

.[#_Toc87278994 .anchor]##*Table 64: General semantics of properties*
[width="100%",cols="17%,31%,52%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Mapped to Domain*
____

a|
____
44
____

a|
____
_for i~1~ in ic~1~, i~2~ in ic~2~, ... return e_
____

a|
____
*[ FEEL(*_e_, *s'), FEEL(*_e_, *si, ... ]*
____

a|
____
45
____

a|
____
_if e1 then e2 else e3_
____

a|
____
*if FEEL(*_e1_*) is true then FEEL(*_e2_*) else FEEL(*_e3_*)*
____

a|
____
46
____

a|
____
_some n1 in e1, n2 in e2, ... satisfies e_
____

a|
____
*false or FEEL(*_e,_ *s') or FEEL(*_e,_ *s") or ...*
____

a|
____
46
____

a|
____
_every n 1 in e 1, n2 in e2, ... satisfies e_
____

a|
____
*true and FEEL(*_e,_ *s') and FEEL(*_e,_ *s") and ...*
____

a|
____
47
____

a|
____
_e1 or e2 or ..._
____

a|
____
*FEEL(*_e1_*) or FEEL(*_e2_*) or* ...
____

a|
____
48
____

a|
____
_e1 and e2 and ..._
____

a|
____
*FEEL(*_e1_*) and FEEL(*_e2_*) and* ...
____

|49.a a|
____
_e = null_
____

a|
____
*FEEL(*_e_*) is null*
____

|49.a a|
____
_null = e_
____

a|
____
*FEEL(*_e_*) is null*
____

|49.a a|
____
_e != null_
____

a|
____
*FEEL(*_e_*) is not null*
____

|49.a a|
____
_null != e_
____

a|
____
*FEEL(e) is not null*
____

|===

Notice that we use bold syntax to denote contexts, lists, conjunctions, disjunctions, conditional expressions, true, false, and null in the FEEL domain.

The meaning of the conjunction *a and b* and the disjunction *a or b* is defined by ternary logic. Because these are total functions, the input can be *true*, *false*, or *otherwise* (meaning any element of *D* other than *true* or *false*).

A conditional *if a then b else c* is equal to *b* if *a* is *true*, and equal to *c* otherwise.

*s'* is the scope *s* with a special first context containing keys n1, n2, etc. bound to the first element of the Cartesian product of FEEL**(**_e1_*) x* FEEL**(**_e2_*) x ..., s"* is *s* with a special first context containing keys bound to the second element of the Cartesian product, _etc_. When the Cartesian product is empty, the _some ... satisfies_ quantifier returns *false* and the _every ... satisfies_ quantifier returns *true*.

.[#_Toc87278995 .anchor]##*Table 65: List of properties per type*
[width="100%",cols="31%,29%,20%,20%",options="header",]
|===
a|
____
*a*
____

a|
____
*b*
____

a|
____
*a and b*
____

a|
____
*a or b*
____

a|
____
true
____

a|
____
true
____

a|
____
true
____

a|
____
true
____

a|
____
true
____

a|
____
false
____

a|
____
false
____

a|
____
true
____

a|
____
true
____

a|
____
otherwise
____

a|
____
null
____

a|
____
true
____

a|
____
false
____

a|
____
true
____

a|
____
false
____

a|
____
true
____

a|
____
false
____

a|
____
false
____

a|
____
false
____

a|
____
false
____

a|
____
false
____

a|
____
otherwise
____

a|
____
false
____

a|
____
null
____

a|
____
otherwise
____

a|
____
true
____

a|
____
null
____

a|
____
true
____

a|
____
otherwise
____

a|
____
false
____

a|
____
false
____

a|
____
null
____

a|
____
otherwise
____

a|
____
otherwise
____

a|
____
null
____

a|
____
null
____

|===

Negation is accomplished using the built-in function *not*. The ternary logic is as shown in *Table _51_*.

.[#_Toc87278996 .anchor]##*Table 66: Specific semantics of date, time and duration properties*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*a*
____

a|
____
*not(a)*
____

a|
____
true
____

a|
____
false
____

a|
____
false
____

a|
____
true
____

a|
____
otherwise
____

a|
____
null
____

|===

Equality and inequality map to several kind- and datatype-specific tests, as shown in *Table _52_*, *Table _53_* and *Table _54_*. By definition, FEEL(_e1 != e2_) is FEEL(_not(e 1= e2)_). The other comparison operators are defined only for the datatypes listed in *Table _54_*. Note that *Table _54_* defines only ‘<’; ‘>’ is similar to ‘<’ and is omitted for brevity; _e1<=e2_ is defined as _e1< e2 or e1= e2._

.[#_Toc87278997 .anchor]##*Table 67: Specific semantics of range properties*
[width="100%",cols="18%,20%,30%,32%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Input Domain*
____

a|
____
*Result*
____

a|
____
49.a
____

a|
____
_e1 = e2_
____

a|
____
*e1 and e2 must both be of the same kind/datatype – both numbers, both strings, etc.*
____

a|
____
_See below_
____

a|
____
49.a
____

a|
____
_e1 < e2_
____

a|
____
*e1* and *e2* must both be of the same kind/datatype – both numbers, both strings, _etc._
____

a|
____
_See below_
____

|===

.[#_Toc87278998 .anchor]##*Table 68: Semantics of lists*
[width="100%",cols="38%,62%",options="header",]
|===
a|
____
*kind/datatype*
____

a|
____
*_e1 = e2_*
____

a|
____
list
____

a|
____
lists must be same length N and *e1[i] = e2[i]* for 1 ≤ *i* ≤ N.
____

a|
____
context
____

a|
____
contexts must have same set of keys K and *e1.k = e2.k* for every k in K
____

a|
____
range
____

a|
____
the ranges must specify the same endpoint(s) and the same comparison operator or endpoint inclusivity flag.
____

a|
____
function
____

a|
____
internal functions must have the same parameters, body, and scope. Externally defined functions must have the same parameters and external mapping information.
____

a|
____
number
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.1. Precision is not considered.
____

a|
____
string
____

a|
____
*e1* is the same sequence of characters as *e2*
____

a|
____
date
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.5
____

a|
____
date and time
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.6
____

a|
____
time
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.4.
____

a|
____
days and time duration
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.7
____

a|
____
years and months duration
____

a|
____
*value(e1) = value(e2)*. Value is defined in 10.3.2.3.8.
____

a|
____
boolean
____

a|
____
*e1* and *e2* must both be *true* or both be *false*
____

|===

.[#_Toc87278999 .anchor]##*Table 69: Semantics of contexts*
[width="100%",cols="37%,63%",options="header",]
|===
a|
____
*datatype*
____

a|
____
*_e1 < e2_*
____

|number a|
____
*value(e1) < value(e2)*. *value* is defined in 10.3.2.3.1. Precision is not considered.
____

|string a|
____
sequence of characters *e1* is lexicographically less than the sequence of characters *e2*. _I.e.,_ the sequences are padded to the same length if needed with _\u0_ characters, stripped of common prefix characters, and then the first character in each sequence is compared.
____

a|
____
date
____

a|
____
e1 < e2 if the year value of e1 < the year value of e2 e1 < e2 if the year values are equal and the month value of e1 < the month value of e2 e1 < e2 if the year and month values are equal and the day value of e1 < the day value of e2
____

a|
____
date and time
____

a|
____
*valuedt(e1) < valuedt(e2)*. *valuedt* is defined in 10.3.2.3.5. If one input has a null timezone offset, that input uses the timezone offset of the other input.
____

a|
____
time
____

a|
____
*valuet(e1) < valuet(e2)*. *valuet* is defined in 10.3.2.3.4. If one input has a null timezone offset, that input uses the timezone offset of the other input.
____

a|
____
days and time duration
____

a|
____
*valuedtd(e1) < valuedtd(e2)*. *valuedtd* is defined in 10.3.2.3.7.
____

a|
____
years and months duration
____

a|
____
*valueymd(e1) < valueymd(e2)*. *valueymd* is defined in 10.3.2.3.8.
____

|===

 +
FEEL supports additional syntactic sugar for comparison. Note that Grammar Rules (clause 10.3.1.2) are used in decision table condition cells. These decision table syntaxes are defined in *Table _55_*.

.[#_Toc87279000 .anchor]##*Table 70: Semantics of XML elements*
[width="100%",cols="16%,24%,31%,29%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Equivalent FEEL Syntax*
____

a|
____
*applicability*
____

|49.b a|
____
_e1 between e2 and e3_
____

a|
____
_e1 >= e2 and e1 <= e3_
____

|
|49.c a|
____
_e1 in [e2,e3, ... ]_
____

a|
____
_e1 = e2 or e1 = e3 or..._
____

a|
____
e2 and e3 are endpoints
____

|49.c a|
____
_e1 in [e2,e3, ... ]_
____

a|
____
_e1 in e2 or e1 in e3 or..._
____

a|
____
e2 and e3 are ranges
____

|49.c a|
____
_e1 in <=e2_
____

a|
____
_e1 <= e2_
____

|
|49.c a|
____
_e1 in <e2_
____

a|
____
_e1 < e2_
____

|
|49.c a|
____
_e1 in >=e2_
____

a|
____
_e1 >= e2_
____

|
|49.c a|
____
_e1 in >e2_
____

a|
____
_e1 > e2_
____

|
|49.c a|
____
_e1 in (e2..e3)_
____

a|
____
_e1 > e2 and e1<e3_
____

|
|49.c a|
____
_e1 in (e2..e3]_
____

a|
____
_e1 > e2 and e1<=e3_
____

|
|49.c a|
____
_e1 in [e2..e3)_
____

a|
____
_e1 >= e2 and e1<e3_
____

|
|49.c a|
____
_e1 in [e2..e3]_
____

a|
____
_e1 >= e2 and e1<=e3_
____

|
|49.c a|
____
_e1 in e2_
____

a|
____
_e1 = e2_
____

a|
____
e2 is a qualified name that does _not_ evaluate to a list
____

|49.c a|
____
_e1 in e2_
____

a|
____
_list contains( e2, e1 )_
____

a|
____
e1 is a simple value that is not a list and e2 is a qualified name that evaluates to a list
____

|49.c a|
____
_e1 in e2_
____

a|
____
_\{ ? : e1, r : e2 }.r_
____

a|
____
e2 is a boolean expression that uses the special variable “?”
____

|===

Addition and subtraction are defined in *Table _56_* and *Table _57_*. Note that if input values are not of the listed types, the result is *null*.

.[#_Toc87279001 .anchor]##*Table 71: Semantics of XML values*
[width="100%",cols="21%,32%,47%",options="header",]
|===
a|
____
*Grammar Rule*
____

|*FEEL* a|
____
*Input Domain and Result*
____

a|
____
19
____

|_e1 + e2_ a|
____
_See below_
____

a|
____
20
____

|_e1 – e2_ a|
____
_See below_
____

|===

.date time string – a string value consisting of a date string value, as specified above, optionally followed by the character "T" followed by a time string value as specified above. +
duration string – a string value in the lexical space of the xs:dayTimeDuration or xs:yearMonthDuration datatypes specified by the XQuery 1.0 and XPath 2.0 Data Model. [#_Toc87279002 .anchor]##*Table 72: Semantics of conversion functions*
[width="100%",cols="17%,14%,53%,16%",options="header",]
|===
a|
____
*type(e1)*
____

a|
____
*type(e2)*
____

a|
____
*_e1 + e2, e1 – e2_*
____

a|
____
*result type*
____

a|
____
number
____

a|
____
number
____

a|
____
Let *e1=(p1,s1)* and *e2=(p2,s2)* as defined in 10.3.2.3.1. If *value(p1,s1) +/- value(p2,s2)* requires a scale outside the range of valid scales, the result is *null*. Else the result is *(p,s)* such that
____

a|
____
number
____

| | a|
* {blank}

|*value(p,s) = value(p1,s1) +/- value(p2,s2) + ε*
| | a|
* {blank}

|*s ≤ max(s1,s2)*
| | a|
* {blank}

|*s* is maximized subject to the limitation that *p* has 34 digits or less
| | a|
* {blank}

|*ε* is a possible rounding error.
a|
____
date and time
____

a|
____
date and time
____

a|
____
Addition is undefined. Subtraction is defined as *valuedtj^1^ (valuedt(e1)-valuedt(e2))*, where *valuedt* is defined in 10.3.2.3.5 and *valuedtj^1^* is defined in
____

a|
____
days and time duration
____

| | a|
____
10.3.2.3.7. In case either value is of type date, it is implicitly converted into a date and time with time of day of UTC midnight ("00:00:00") as defined in
____

|
| | a|
____
10.3.2.3.6. Subtraction requires either both values to have a timezone or both not to have a timezone.
____

|
| | a|
____
Subtraction is undefined for the case where only one of the values has a timezone.
____

|
a|
____
time
____

a|
____
time
____

a|
____
Addition is undefined. Subtraction is defined as *valuedtd^-1^ (valuet(e1)-valuet(e2))* where *valuet* is defined in 10.3.2.3.4 and *valuedtd -1* is defined in 10.3.2.3.7.
____

a|
____
days and time duration
____

a|
____
years and months duration
____

a|
____
years and months duration
____

a|
____
*valueymd^-1^(valueymd(e1) +/- valueymd(e2))* where *valueymd* and *valueymd -1* is defined in 10.3.2.3.8.
____

a|
____
years and months duration
____

a|
____
days and time duration
____

a|
____
days and time duration
____

a|
____
*valuedtd ^-1^(valuedtd(e1) +/- valuedtd(e2))* where *valuedtd* and *valuedtd^-1^* is defined in 10.3.2.3.7.
____

a|
____
days and time duration
____

a|
____
date and time
____

a|
____
years and months duration
____

a|
____
date and time (date(*e1*.year +/– *e2*.years + floor((*e1*.month +/– *e2*.months)/12),

*e1*.month +/– *e2*.months – floor((*e1*.month +/– *e2*.months)/12) * 12, *e1*.day), time(*e1*)),

where the named properties are as defined in *Table _65_* below, and the date, date and time, time and floor functions are as defined in 10.3.4, *valuedt* and *valuedt ^-1^* is defined in 10.3.2.3.5 and *valueymd* is defined in 10.3.2.3.8.
____

a|
____
date and time
____

a|
____
years and months duration
____

a|
____
date and time
____

a|
____
Subtraction is undefined. Addition is commutative and is defined by the previous rule.
____

a|
____
date and time
____

a|
____
date and time
____

a|
____
days and time duration
____

a|
____
*valuedt ^-1^(valuedt(e1) +/- valuedtd(e2))* where *valuedt* and *valuedt ^-1^* is defined in 10.3.2.3.5 and *valuedtd* is defined in 10.3.2.3.7.
____

a|
____
date and time
____

a|
____
days and time duration
____

a|
____
date and time
____

a|
____
Subtraction is undefined. Addition is commutative and is defined by the previous rule.
____

a|
____
date and time
____

a|
____
time
____

a|
____
days and time duration
____

a|
____
*valuet ^-1^(valuet(e1) +/- valuedtd(e2))* where *valuet* and *valuet ^-1^* are defined in 10.3.2.3.4 and *valuedtd* is defined in 10.3.2.3.7.
____

a|
____
time
____

a|
____
days and time duration
____

a|
____
time
____

a|
____
Subtraction is undefined. Addition is commutative and is defined by the previous rule.
____

a|
____
time
____

a|
____
string
____

a|
____
string
____

a|
____
Subtraction is undefined. Addition concatenates the strings. The result is a string containing the sequence of characters in e1 followed by the sequence of characters in e2.
____

a|
____
string
____

a|
____
date
____

a|
____
years and months duration
____

a|
____
*date( e1.year +/– e2.years + floor((e1.month +/– e2.months)/12), e1.month +/– e2.months – floor((e1.month +/– e2.months)/12) * 12, e1.day )*, where the named properties are as defined in *Table _65_* below, and the date and floor functions are as defined in 10.3.4.
____

a|
____
date
____

a|
____
years and months duration
____

a|
____
date
____

a|
____
Subtraction is undefined. Addition is commutative and is defined by the previous rule.
____

a|
____
date
____

a|
____
date
____

a|
____
days and time duration
____

a|
____
date(valuedt^-1^ (valuedt(e1) +/- valuedtd(e2))) where valuedt and valuedt^-1^ is defined in 10.3.2.3.5 and valuedtd is defined in 10.3.2.3.7.
____

a|
____
date
____

a|
____
days and time duration
____

a|
____
date
____

a|
____
Subtraction is undefined. Addition is commutative and is defined by the previous rule.
____

a|
____
date
____

|===

Multiplication and division are defined in *Table _58_* and *Table _59_*. Note that if input values are not of the listed types, the result is *null*.

.[#_Toc87279003 .anchor]##*Table 73: Semantics of Boolean functions*
[width="100%",cols="24%,36%,40%",options="header",]
|===
a|
____
*Grammar Rule*
____

|*FEEL* a|
____
*Input Domain and Result*
____

a|
____
21
____

|_e1 * e2_ a|
____
_See below_
____

a|
____
22
____

|_e1 / e2_ a|
____
_See below_
____

|===

.[#_Toc87279004 .anchor]##*Table 74: Semantics of string functions*
[width="99%",cols="15%,13%,28%,29%,15%",options="header",]
|===
a|
____
*type(e1)*
____

a|
____
*type(e2)*
____

|*_e1 * e2_* |*_e1 / e2_* a|
____
*result type*
____

a|
____
number *e1=(p1,s1)*
____

a|
____
number *e2=(p2,s2)*
____

a|
____
If *value(p1,s1) * value(p2,s2)* requires a scale outside the range of valid scales, the result is *null*. Else the result is *(p,s)* such that
____

* {blank}
* {blank}
* {blank}
* {blank}

a|
____
*value(p,s) = value(p1,s1) * value(p2,s2) + εs ≤ s1+s2s* is maximized subject to the limitation that *p* has 34 digits or less**ε** is a possible rounding errorIf *value(p2,s2)=0* or *value(p1,s1) / value(p2,s2)* requires a scale outside the range of valid scales, the result is *null*. Else the result is *(p,s)* such that
____

* {blank}
* {blank}
* {blank}

*value(p,s) = value(p1,s1) / value(p2,s2) + εs ≤ s1-s2s* is maximized subject to the limitation that *p* has 34 digits or less

* {blank}

a|
____
*ε* is a possible rounding errornumber
____

a|
____
years and months duration
____

a|
____
number
____

a|
____
*valueymd ^-1^(valueymd(e1) * value(e2))* where *valueymd* and *valueymd -1* are defined in 10.3.2.3.8
____

a|
____
If *value(e2)=0*, the result is *null*. Else the result is *valueymd^-^ ^1^(valueymd(e1) / value(e2))* where *valueymd* and *valueymd^-1^* are defined in 10.3.2.3.8.
____

a|
____
years and months +
duration
____

a|
____
number
____

a|
____
years and months duration
____

a|
____
_See above, reversing e1 and e2_
____

a|
____
_Not allowed_
____

a|
____
years and months +
duration
____

a|
____
years and months duration
____

a|
____
years and months duration
____

a|
____
_Not allowed_
____

a|
____
If *valueymd(e2)=0*, the result is *null*. Else the result is *valueymd(e1) / valueymd(e2)* where *valueymd* is defined in 10.3.2.3.8.
____

a|
____
number
____

a|
____
days and time duration
____

a|
____
number
____

a|
____
*valuedtd^-1^(valuedtd(e1) * value(e2))* where *valuedtd* and *valuedtd -1* are defined in 10.3.2.3.7.
____

a|
____
If *value(e2)=0*, the result is *null*.

Else the result is *valuedtd ^1^(valuedtd(e1) * value(e2))* where *valuedtd* and *valuedtd -1* are

defined in 10.3.2.3.7.
____

a|
____
days and time duration
____

a|
____
number
____

a|
____
days and time duration
____

a|
____
_See above, reversing e1 and e2_
____

a|
____
_Not allowed_
____

a|
____
days and time duration
____

a|
____
days and time duration
____

a|
____
days and time

duration
____

a|
____
_Not allowed_
____

a|
____
If *valuedtd(e2)=0*, the result is *null*. Else the result is *valuedtd(e1) / valuedtd(e2)* where *~valuedtd~* is defined in 10.3.2.3.7.
____

a|
____
number
____

|===

.[#_Toc87279005 .anchor]##*Table 75: Semantics of list functions*
[width="100%",cols="15%,12%,33%,40%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Input Domain*
____

a|
____
*Result*
____

a|
____
23
____

|_e1 ** e2_ a|
____
*type(e1)* is number. *value(e2)* is a number in the range

[-999,999,999..999,999,999].
____

a|
____
If *value(e1)value(e2 )* requires a scale that is out of range, the result is *null*. Else the result is *(p,s)* such that
____

* {blank}
* {blank}
* {blank}

|===

*value(p,s)= value(e1)^value(e^2^)^ + εp* is limited to 34 digits**ε** is rounding error

Type-checking is defined in *Table _61_*. Note that _type_ is not mapped to the domain, and *null* is the only value in the Null type (see 10.3.2.1).

Before evaluating the _instance of_ operator both operands are mapped to the type lattice *L* (see 10.3.2.9).

.[#_Toc87279006 .anchor]##*Table 76: Semantics of numeric functions*
[width="100%",cols="13%,18%,29%,40%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Mapped to Domain*
____

a|
____
*Examples*
____

a|
____
51
____

a|
____
_e1 instance of e2_
____

a|
____
**If _e~2~_ cannot be mapped to a node in the lattice L, the result is null. +
**If *e~1~* is *null* and *type(*_e~2~_*)* is _Null_, the result is *true*.** +
**If *type(*_e~1~_*)* conforms to *type(*_e~2~_*)* (see section 10.3.2.9) and *e~1~* is** +
**not *null,* the result is *true*. Otherwise the result is *false*.
____

a|
____
_[123] instance of list<number>_ is *true* _"abc" instance of string_ is *true*

_123 instance of string_ is *false*

_123 instance of list_ is *null* as a list type requires parameters (see rule 54).
____

|===

Negative numbers are defined in *Table _62_*.

.[#_Toc87279007 .anchor]##*Table 77: Semantics of date and time functions*
[width="100%",cols="24%,36%,40%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Equivalent FEEL Syntax*
____

a|
____
24
____

a|
____
_-e_
____

a|
____
_0-e_
____

|===

Invocation is defined in *Table _63_*. An invocation can use positional arguments or named arguments. If positional, all arguments must be supplied. If named, unsupplied arguments are bound to *null*. Note that *e* can be a user-defined function, a user-defined external function, or a built-in function. The arguments are subject to implicit conversions (10.3.2.9.4). If the argument types before or after conversion do not conform to the corresponding parameter types, the result of the invocation is *null*.

.[#_Toc87279008 .anchor]##*Table 78: Semantics of range functions*
[width="100%",cols="7%,3%,3%,5%,26%,28%,28%",options="header",]
|===
a|
____
*Grammar Rule*
____

| | | a|
____
*FEEL*
____

a|
____
*Mapped to Domain*
____

a|
____
*Applicability*
____

a|
____
38,
____

|39, |42 | a|
____
_e(e1,..)_
____

a|
____
*e(e1*,...*)*
____

a|
____
*e* is a function with matching arity and conforming parameter types
____

a|
____
38,
____

|39, |40, |41 a|
____
_e(n1:e1,...)_
____

a|
____
*e(*_n1_*:e1,...)*
____

a|
____
*e* is a function with matching parameter names and conforming parameter types
____

|===

Properties are defined in *Table _64_* and *Table _65_*. If *type(*_e_*)* is date and time, time, or duration, and *name* is a property name, then the meaning is given by *Table _65_* and *Table _66_*. For example, FEEL(_date and time("2012-03-07Z").year_) = *2012*.

.[#_Toc87279009 .anchor]##*Table 79: Temporal built-in functions*
[width="100%",cols="18%,26%,28%,28%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL*
____

a|
____
*Mapped to Domain*
____

a|
____
*Applicability*
____

a|
____
18
____

a|
____
_e.name_
____

a|
____
*e."name"*
____

a|
____
*type(e)* is a context
____

a|
____
18
____

a|
____
_e.name_
____

a|
____
_see below_
____

a|
____
*type(e)* is a date/time/duration
____

|===

.[#_Toc87279010 .anchor]##*Table 80: Semantics of sort functions*
[width="100%",cols="22%,47%,31%",options="header",]
|===
a|
____
*type(_e_)*
____

a|
____
*_e ._ name*
____

a|
____
*name =*
____

a|
____
date
____

a|
____
result is the **name**d component of the date object *e*. Valid names are shown to the right.
____

a|
____
year, month, day, weekday
____

a|
____
date and time
____

a|
____
result is the **name**d component of the date and time object *e*. Valid names are shown to the right.
____

a|
____
year, month, day, weekday, hour, minute, second, time offset, timezone
____

a|
____
time
____

a|
____
result is the **name**d component of the time object *e*. Valid names are shown to the right
____

a|
____
hour, minute, second, time offset, timezone
____

a|
____
years and months duration
____

a|
____
result is the **name**d component of the years and months duration object *e*. Valid names are shown to the right.
____

a|
____
years, months
____

a|
____
days and time duration
____

a|
____
result is the **name**d component of the days and time duration object *e*. Valid names are shown to the right.
____

a|
____
days, hours, minutes, seconds
____

a|
____
range
____

a|
____
result is the **name**d component of the range object *e*. Valid names are shown to the right.
____

a|
____
start, end, start included, end included
____

|===

.[#_Toc87279011 .anchor]##*Table 81: Semantics of Context functions*
[width="100%",cols="22%,20%,58%",options="header",]
|===
a|
____
*name*
____

a|
____
*_type_(name)*
____

a|
____
*description*
____

a|
____
year
____

a|
____
number
____

a|
____
The year number as an integer in the interval [-999,999,999 .. 999,999,999]
____

a|
____
month
____

a|
____
number
____

a|
____
The month number as an integer in the interval [1..12], where 1 is January and 12 is December
____

a|
____
day
____

a|
____
number
____

a|
____
The day of the month as an integer in the interval [1 ..31]
____

a|
____
weekday
____

a|
____
number
____

a|
____
The day of the week as an integer in the interval [1. .7] where 1 is Monday and 7 is Sunday (compliant with the definition in ISO 8601)
____

a|
____
hour
____

a|
____
number
____

a|
____
The hour of the day as an integer in the interval [0..23]
____

a|
____
minute
____

a|
____
number
____

a|
____
The minute of the hour as an integer in the interval [0..59]
____

a|
____
second
____

a|
____
number
____

a|
____
The second of the minute as a decimal in the interval [0. .60)
____

a|
____
time offset
____

a|
____
days and time duration
____

a|
____
The duration offset corresponding to the timezone the date or date and time value represents. The time offset duration must be in the interval *[duration(“-PT14H”)..duration(“PT14H”)]* as per the XML Schema Part 2 dateTime datatype. The *time offset* property returns null when the object does not have a time offset set.
____

a|
____
timezone
____

a|
____
string
____

a|
____
The timezone identifier as defined in the IANA Time Zones database. The *timezone* property returns null when the object does not have an IANA timezone defined.
____

a|
____
name
____

a|
____
type(name)
____

a|
____
description
____

a|
____
years
____

a|
____
number
____

a|
____
The normalized years component of a years and months duration value as an integer. This property returns null when invoked on a days and time duration value.
____

a|
____
months
____

a|
____
number
____

a|
____
The normalized months component of a years and months duration value. Since the value is normalized, this property must return an integer in the interval [0.. 11]. This property returns null when invoked on a days and time duration value.
____

a|
____
days
____

a|
____
number
____

a|
____
The normalized days component of a days and time duration value as an integer. This property returns null when invoked on a years and months duration value.
____

a|
____
Hours
____

a|
____
number
____

a|
____
The normalized hours component of a days and time duration value. Since the value is normalized, this property must return an integer in the interval [0..23]. This property returns null when invoked on a years and months duration value.
____

a|
____
minutes
____

a|
____
number
____

a|
____
The normalized minutes component of a days and time duration value. Since the value is normalized, this property must return an integer in the interval [0..59]. This property returns null when invoked on a years and months duration value.
____

a|
____
seconds
____

a|
____
number
____

a|
____
The normalized minutes component of a days and time duration value. Since the value is normalized, this property must return a decimal in the interval [0..60). This property returns null when invoked on a years and months duration value.
____

|===

.[#_Toc87279012 .anchor]##*Table* *82: Miscellaneous functions*
[width="100%",cols="34%,33%,33%",options="header",]
|===
a|
____
*name*
____

a|
____
*type(name)*
____

a|
____
*description*
____

a|
____
start
____

a|
____
Type of the start endpoint of the range
____

a|
____
the start endpoint of the range
____

a|
____
end
____

a|
____
Type of the end endpoint of the range
____

a|
____
the end endpoint of the range
____

a|
____
start included
____

a|
____
boolean
____

a|
____
true if the start endpoint is included in the range
____

a|
____
end included
____

a|
____
boolean
____

a|
____
true if the end endpoint is included in the range
____

|===

Lists are defined in *Table _68_*.

.[#_Toc87279013 .anchor]##*Table 83: Context attributes and model association*
[width="100%",cols="15%,12%,36%,37%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Mapped to Domain (scope s)*
____

a|
____
*Applicability*
____

a|
____
54
____

a|
____
_e1[e2]_
____

a|
____
*e1[e2]*
____

a|
____
*e1* is a list and *e2* is an integer (0 scale number)
____

a|
____
54
____

a|
____
_e1[e2]_
____

a|
____
*e 1*
____

a|
____
*e1* is not a list and not *null* and *value(e2)* = *1*
____

a|
____
54
____

a|
____
_e1[e2]_
____

a|
____
list of items *e* such that *i* is in *e* iff *i* is in *e1* and FEEL(_e2,_ *s'*) is *true*, where *s'* is the scope *s* with a special first context containing the context entry ("*item*", *i*) and if *i* is a context, the special context also contains all the context entries of *i*.
____

a|
____
*e1* is a list and **type(**FEEL(_e2,_ *s'*)*)* is boolean
____

a|
____
54
____

a|
____
_e1[e2]_
____

a|
____
*[e1]* if FEEL(_e2,_ *s'*) is *true*, where *s'* is the scope *s* with a special first context containing the context entry ("*item*", *e1*) and if *e1* is a context, the special context also contains all the context entries of *e1*. Else *[]*.
____

a|
____
*e1* is not a list and not *null* and **type(**FEEL(_e2,_ *s'*)*)* is boolean
____

|===

Contexts are defined in *Table _69_*.

.[#_Toc87279014 .anchor]##*Table 84: ContextEntry attributes and model associations*
[width="100%",cols="18%,30%,52%",options="header",]
|===
a|
____
*Grammar Rule*
____

a|
____
*FEEL Syntax*
____

a|
____
*Mapped to Domain (scope s)*
____

| a|
____
_\{ n1 : e1, n2 : e2, ...}_
____

a|
____
*\{* "*n1*"*:* FEEL(_e1_, *s1*)*,* "*n2*"*:* FEEL(_e2_, *s2*)*, ...}* such that the *si* are all *s* with a special first context *ci* containing a
____

| a|
____
_\{ "n1" : e1, "n2" : e2, ...}_
____

|
a|
____
57
____

| |subset of the entries of this result context. If *ci* contains +
the entry for *nj*, then *cj* does not contain the entry for *ni*.
a|
____
54
____

a|
____
_[e1, e2, ...]_
____

a|
____
*[* FEEL(_e1_)*,* FEEL(_e2_)*, ...]*
____

|===

=====  Error Handling

When a built-in function encounters input that is outside its defined domain, the function SHOULD report or log diagnostic information if appropriate, and SHALL return *null*.

====  XML Data

FEEL supports XML Data in the FEEL context by mapping XML Data into the FEEL Semantic Domain. Let XE(_e_, *p*) be a function mapping an XML element _e_ and a parent FEEL context *p* to a FEEL context , as defined in the following tables. XE makes use of another mapping function, XV(_v_), that maps an XML value _v_ to the FEEL semantic domain.

XML namespace semantics are not supported by the mappings. For example, given the namespace prefix declarations _xmlns:p1= "http://example.org/foobar[[.underline]#http://example.org/foobar#]"_ and _xmlns:p2= "http://example.org/foobar[[.underline]#http://example. org/foobar#]"_, the tags _p1:myElement_ and _p2:myElement_ are the same element using XML namespace semantics but are different using XML without namespace semantics.

===== Semantic mapping for XML elements (XE)

*Table _70_*, _e_ is the name of an XML element, _a_ is the name of one of its attributes, _c_ is a child element, and _v_ is a value. The parent context *p* is initially empty.

.[#_Toc87279015 .anchor]##*Table 85: FunctionDefinition attributes and model associations*
[width="100%",cols="36%,33%,31%",options="header",]
|===
a|
____
*XML*
____

a|
____
*context entry in p*
____

a|
____
*Remark*
____

a|
____
_<e />_
____

a|
____
"*e*" *: null*
____

a|
____
empty element → *null*-valued entry in *p*
____

a|
____
_<q:e />_
____

a|
____
"*e*" *: null*
____

a|
____
namespaces are ignored.
____

a|
____
_<e>v</e>_
____

a|
____
"*e*"**:**XV(_v_)
____

a|
____
unrepeated element without attributes
____

a|
____
_<e>v1</e> <e>v2</e>_
____

a|
____
"*e*"*: [* XV(_v1_)*,* XV(_v2_) *]*
____

a|
____
repeating element without attributes
____

a|
____
_<e a="v"/>_
____

_<c1>v1</c1>_

____
_<cn>v2</cn><cn>v3</cn> </e>_
____

a|
____
*"e": \{ "a":* XV(_v_),

*"c1":* XV(_v1_),

*"cn": [* XV(_v2_), XV(_v3_) ]

*}*
____

a|
____
An element containing attributes or child elements → context
____

a|
____
_<e a="v1">v2</e>_
____

a|
____
"*e*"*: \{* "*@a*"*:* XV(_v1_), "*$content*"*:* XV(_v2_) *}*
____

a|
____
_v2_ is contained in a generated $content entry
____

|===

An entry in the *context entry in p* column such as *"e" : null* indicates a context entry with string key *"e"* and value *null*. The context entries are contained by context *p* that corresponds to the containing XML element, or to the XML document itself.

The mapping does not replace namespace prefixes with the namespace IRIs. FEEL requires only that keys within a context be distinct, and the namespace prefixes are sufficient.

===== Semantic mapping for XML values (XV)

If an XML document was parsed with a schema, then some atomic values may have a datatype other than string. **Table _71_**defines how a typed XML value _v_ is mapped to FEEL.

.[#_Toc87279016 .anchor]##*Table 86: List attributes and model associations*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Type of _v_*
____

a|
____
*FEEL Semantic Domain*
____

a|
____
number
____

a|
____
FEEL(_v_)
____

a|
____
string
____

a|
____
FEEL(_"v"_)
____

a|
____
date
____

a|
____
FEEL(_date("v")_)
____

a|
____
dateTime
____

a|
____
FEEL(_date and time("v")_)
____

a|
____
time
____

a|
____
FEEL(_time("v")_)
____

a|
____
duration
____

a|
____
FEEL(duration("v"))
____

a|
____
list, e.g. "v1 v2"
____

a|
____
{empty}[ XV(v1), XV(v2) ]
____

a|
____
element
____

a|
____
XE(v)
____

|===

===== XML example

The following schema and instance are equivalent to the following FEEL:

====== schema

____
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema[[.underline]#http://www.w3.org/2001/XMLSchema#]" xmlns="http://www.example.org/[[.underline]#http://www.example.org#]"

ta rgetNa mespace=" http://www.example.org/[[.underline]#http://www.example.org#]"

elementFormDefault="qualified">

<xsd:element name="Context">

<xsd :complexType> <xsd:sequence>

<xsd:element name="Employee">

<xsd:complexType> <xsd:sequence>

<xsd :element na me="sala ry" type="xsd :deci ma l"/>

</xsd :seq uence> </xsd :complexType> </xsd:element>

<xsd:element name="Customer" maxOccurs="unbounded">

<xsd:complexType> <xsd:sequence>

<xsd :element na me="loya lty_level" type="xsd :stri ng"/>

<xsd :element na me="credit_li mit" type="xsd :decima l"/>

</xsd :seq uence>

</xsd :complexType>

</xsd:element>

</xsd:sequence> </xsd :complexType> </xsd:element>

</xsd:schema>
____

====== instance

<Context xmlns:tns="http://www.example.org/[[.underline]#http://www.example.org#]" +
xmlns="http://www.example.org/[[.underline]#http://www.example.org#]">

____
<tns:Employee>

<tns:salary>13000</tns:salary>

</tns:Employee>

<Customer>

<loyalty_level>gold</loyalty_level>

<credit_limit>10000</credit_limit>

</Customer>

<Customer>

<loyalty_level>gold</loyalty_level>

<credit_limit>20000</credit_limit>

</Customer> <Customer> <loya lty_level>si lver</loya lty_level>

<credit_limit>5000</credit_limit>

</Customer>

</Context>
____

====== equivalent FEEL boxed context

.[#_Toc87279017 .anchor]##*Table 87: Relation attributes and model associations*
[width="99%",cols="39%,32%,29%",options="header",]
|===
a|
____
*Context*
____

| |
a|
____
Employee
____

a|
____
salary
____

a|
____
13000
____

a|
____
Customer
____

a|
____
loyalty_level
____

a|
____
credit_limit
____

| a|
____
_gold_
____

|10000
| a|
____
_gold_
____

|20000
| a|
____
_silver_
____

|5000
|===

When a decision model is evaluated, its input data described by an item definition such as an XML Schema element (clause 7.3.2) is bound to case data mapped to the FEEL domain. The case data can be in various formats, such as XML. We can notate case data as an equivalent boxed context, as above. Decision logic can reference entries in the context using expressions such as _Context.tns$Employee.tns$salary_, which has a value of 13000.

====  Built-in functions

To promote interoperability, FEEL includes a library of built-in functions. The syntax and semantics of the built-ins are required for a conformant FEEL implementation.

In all of the tables in this section, a superscript refers to an additional domain constraint stated in the corresponding footnote to the table. Whenever a parameter is outside its domain, the result of the built-in is *null*.

===== Conversion functions

FEEL supports many conversions between values of different types. Of particular importance is the conversion from strings to dates, times, and durations. There is no literal representation for date, time, or duration. Also, formatted numbers such as _1,000.00_ must be converted from a string by specifying the grouping separator and the decimal separator.

Built-ins are summarized in *Table _72_*. The first column shows the name and parameters. A question mark (_?_) denotes an optional parameter. The second column specifies the domain for the parameters. The parameter domain is specified as one of:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

____
a type, _e.g.,_ number, stringany – any element from the semantic domain, including **null**not null – any element from the semantic domain, excluding **null**date string – a string value in the lexical space of the date datatype specified by XML Schema Part 2 Datatypes time string – eithera string value in the lexical space of the time datatype specified by XML Schema Part 2 Datatypes; or +
a string value that is the extended form of a local time representation as specified by ISO 8601, followed by the character "@", followed by a string value that is a time zone identifier in the IANA Time Zones Database (http://www.iana.org/time-zones)[[.underline]#http://www.iana.org/time-zones)#]
____

* {blank}
* {blank}

.[#_Toc87279018 .anchor]##*Table* *88: Conditional attributes and model associations*
[width="100%",cols="25%,21%,18%,36%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
date(_from_)
____

a|
____
date string
____

a|
____
convert _from_ to a date
____

a|
____
_date("2012-12-25") – date("2012-12-24") = duration("P1D ")_
____

a|
____
date(_from_)
____

a|
____
date and time
____

a|
____
convert _from_ to a date (set time components to null)
____

a|
____
_date( +
date and time("2012-12-25T1 1:00:00Z")) = date("2012-12-25")_
____

a|
____
date(_year_, _month_, _day_)
____

a|
____
_year_, _month_, _day_ are numbers
____

a|
____
creates a date from year, month, day component values
____

a|
____
_date (2012, 12, 25) = date("2012-12-25")_
____

a|
____
date and time(_date_, _time_)
____

a|
____
_date_ is a date or date time; _time_ is a time
____

a|
____
creates a date time from the given date (ignoring any time component) and the given time
____

a|
____
_date and time ("2012-12-24T23:59:00") = date and time (date("2012-12-24”), +
time (“23:59:00"))_
____

a|
____
date and time(_from_)
____

a|
____
date time string
____

a|
____
convert _from_ to a date and time
____

a|
____
_date and time("2012-12-24T23:59:00") + duration("PT1M") = date and time("2012- 12-25T00:00:00")_
____

a|
____
time(_from_)
____

a|
____
time string
____

a|
____
convert _from_ to time
____

a|
____
_time("23:59:00z") + duration("PT2M") = time("00:01:00@Etc/UTC")_
____

a|
____
time(_from_)
____

a|
____
time, date and time
____

a|
____
convert _from_ to time (ignoring date components)
____

a|
____
_time( +
date and time("2012-12-25T1 1:00:00Z")) = time("1 1:00:00Z")_
____

a|
____
time(_hour_, _minute_, _second_, _offset?_)
____

a|
____
_hour_, _minute_, _second_, are numbers, _offset_ is a days and time duration, or null
____

a|
____
creates a time from the given component values
____

a|
____
_time (“23:59:00z") = +
time (23, 59, 0, duration(“PT0H”))_
____

a|
____
number(_from, grouping separator, decimal separator_)
____

a|
____
string^1^, string, string
____

a|
____
convert _from_ to a number
____

a|
____
_number("1 000,0", " ", ",") = +
number("1,000.0", " ,", ".")_
____

a|
____
string(from)
____

a|
____
non-null
____

a|
____
convert from to a string
____

a|
____
_string(1.1) = "1.1" string(null) = null_
____

a|
____
duration(from)
____

a|
____
duration string
____

a|
____
convert from to a days and time or years and months duration
____

a|
____
_date and time("2012-12-24T23:59:00") - date and time("2012-12-22T03:45:00") = duration("P2DT20H14M")_

_duration("P2Y2M") = duration("P26M")_
____

a|
____
years and months duration(from, to)
____

a|
____
both are date or both are date and time
____

a|
____
return years and months duration between from and to
____

a|
____
_years and months duration (date("201 1-12-22"), date("2013-08-24") ) = duration("P1Y8M")_
____

|===

____
{empty}1. _grouping_ SHALL be one of space (' '), comma (','), period ('.'), or null. +
_decimal_ SHALL be one of period, comma, or null, but SHALL NOT be the same as the grouping separator unless both are null. +
_from_ SHALL conform to grammar rule 37, after removing all occurrences of the grouping separator, if any, and after changing the decimal separator, if present, to a period.
____

===== Boolean function

*Table _73_* defines Boolean functions.

.[#_Toc87279019 .anchor]##*Table* *89: ChildExpression attributes and model associations*
[width="100%",cols="25%,17%,22%,36%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
not(_negand_)
____

a|
____
boolean
____

a|
____
logical negation
____

a|
____
_not(true) = false not(null) = null_
____

|===

===== String functions

*Table _74_* defines string functions.

.[#_Toc87279020 .anchor]##*Table* *90: Filter attributes and model associations*
[width="100%",cols="22%,17%,21%,40%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
substring(_string, start position, length?_)
____

a|
____
string, number^1^
____

a|
____
return _length_ (or all) characters in _string_, starting at _start position_. 1st position is 1, last position is -1
____

a|
____
_substring("foobar",3) = "obar" substring("foobar",3,3) = "oba" substring("foobar", -2, 1) = "a"_

_substring("\U01F40Eab", 2) = "ab" where "\U01F40Eab" is the representation of 🐎**ab**_
____

a|
____
string length(string)
____

a|
____
string
____

a|
____
return number of characters (or code points) in string.
____

a|
____
_string length("foo") = 3 +
string length("\U01F40Eab") = 3_
____

a|
____
upper case(string)
____

a|
____
string
____

a|
____
return uppercased string
____

a|
____
_upper case("aBc4") = "ABC4"_
____

a|
____
lower case(string)
____

a|
____
string
____

a|
____
return lowercased string
____

a|
____
_lower case("aBc4") = "abc4"_
____

a|
____
substring before (string, match)
____

a|
____
string, string
____

a|
____
return substring of string before the match in string
____

a|
____
_Substring before("foobar","bar") = "foo" substring before("foobar","xyz") = ""_
____

a|
____
substring after +
(string, match)
____

a|
____
string, string
____

a|
____
return substring of string after the match in string
____

a|
____
_substring after("foobar", "ob") = "ar" substring after("", "a") = ""_
____

a|
____
replace(input, pattern, replacement, flags?)
____

a|
____
string2
____

a|
____
regular expression pattern matching and replacement
____

a|
____
_replace("banana","a","o") = "bonono"_

_replace("abcd",_ _"(ab)|(a)", "[1=$1][2=$2]") = "[1=ab][2=]cd"_
____

a|
____
contains(string, match)
____

a|
____
string
____

a|
____
does the string contain the match?
____

a|
____
_contains("foobar", "of") = false_
____

a|
____
starts with(string, match)
____

a|
____
string
____

a|
____
does the string start with the match?
____

a|
____
_starts with("foobar", "fo") = true_
____

a|
____
ends with( string, match)
____

a|
____
string
____

a|
____
does the string end with the match?
____

a|
____
_ends with("foobar", "r") = true_
____

a|
____
matches(input, pattern, flags?)
____

a|
____
string2
____

a|
____
does the input match the regexp pattern?
____

a|
____
_matches("foobar", "^fo*b") = true_
____

a|
____
split( string, delimiter )
____

a|
____
_string_ is a string, _delimiter_ is a pattern2
____

a|
____
Splits the string into a list of substrings, breaking at each occurrence of the delimiter pattern.
____

a|
____
_split( “John Doe”, “\\s” ) = [“John”, “Doe”] split( “a;b;c;;”, “;” ) = [“a”,”b”,”c”,””,””]_
____

a|
____
string join(list, delimiter)
____

a|
____
_list_ is a list of strings, _delimiter_ is a string
____

a|
____
return a string which is composed by joining all the string elements from the list parameter, separated by the delimiter. +
The delimiter can be an empty string. +
Null elements in the list parameter are ignored. +
If *_list_* is empty, the result is the empty string. +
If *_delimiter_* is null, the string elements are joined without a separator.
____

a|
____
_string join(["a","b","c"], "_and_") = "a_and_b_and_c"_

_string join(["a","b","c"], "") = "abc"_

_string join(["a","b","c"], null) = "abc"_

_string join(["a"], "X") = "a"_

_string join(["a",null,"c"], "X") = "aXc"_

_string join([], "X") = ""_
____

a|
____
string join(list)
____

a|
____
_list_ is a list of strings
____

a|
____
return a string which is composed by joining all the string elements from the list parameter +
Null elements in the list parameter are ignored. +
If *_list_* is empty, the result is the empty string.
____

a|
____
_string join(["a","b","c"]) = "abc"_

_string join(["a",null,"c"]) = "ac"_

_string join([]) = ""_
____

|===

[arabic]
. {blank}
. {blank}

_start position_ must be a non-zero integer (0 scale number) in the range [-L..L], where L is the length of the string. _length_ must be in the range [1 ..E], where E is L – _start position_ + 1 if _start position_ is positive, and _–start position_ otherwise._pattern_, _replacement_, and _flags_ SHALL conform to the syntax and constraints specified in clause 7.6 of XQuery 1.0 and XPath 2.0 Functions and Operators. Note that where XPath specifies an error result, FEEL specifies a null result.

===== List functions

*Table _75_* defines list functions.

.[#_Toc87279021 .anchor]##*Table* *91: Iterator attributes and model associations*
[width="100%",cols="25%,17%,31%,27%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
list contains(_list, element_)
____

a|
____
list, any element of the semantic domain including *null*
____

a|
____
does the _list_ contain the _element_?
____

a|
____
_list contains([1,2,3], 2) = true_
____

a|
____
count(_list_)
____

a|
____
list
____

a|
____
return size of _list_, or zero if _list_ is empty
____

a|
____
_count([1,2,3]) = 3 count([]) = 0 count([1,[2,3]]) = 2_
____

a|
____
min(_list_) +
min(_c1,..., cN_), _N_ >0 max(_list_) +
max(_c1,..., cN_), _N_ >0
____

a|
____
non-empy list of comparable items or argument list of one or more comparable items
____

a|
____
return minimum(maximum) item, or *null* if _list_ is empty
____

a|
____
_min([1,2,3]) = 1 +
max(1,2,3) = 3 +
min(1) = min([1]) = 1 max([]) = null_
____

a|
____
sum(_list_) +
sum(_n1,..., nN_), _N_ >0
____

a|
____
list of 0 or more numbers or argument list of one or more numbers
____

a|
____
return sum of numbers, or *null* if _list_ is empty
____

a|
____
_sum([1,2,3]) = 6 sum(1,2,3) = 6 sum(1) = 1 +
sum([]) = *null*_
____

a|
____
mean(_list_) +
mean(_n1,..., nN_), _N_ >0
____

a|
____
non-empty list of numbers or argument list of one or more numbers
____

a|
____
return arithmetic mean (average) of numbers
____

a|
____
_mean ([1,2,3]) = 2 mean(1,2,3) = 2 mean(1) = 1 mean([]) = null_
____

a|
____
all(_list_) +
all(_b1,..., bN_), _N_ >0
____

a|
____
list of Boolean items or argument list of one or more Boolean items
____

a|
____
return _false_ if any item is _false_, else _true_ if empty or all items are _true_, else _null_
____

|_all([false,null,true]) = false +
all(true) = all([true]) = true +
all([]) = true +
all(0) = null_
a|
____
any(_list_) +
any(_b1,..., bN_), _N_ >0
____

a|
____
list of Boolean items or argument list of one or more Boolean items
____

a|
____
return _true_ if any item is _true_, else _false_ if empty or all items are _false_, else _null_
____

a|
____
_any([false,null,true]) = true any(false) = false +
any([]) = false +
any(0) = null_
____

a|
____
sublist(_list, start position, length?_)
____

a|
____
list, number^1^, number^2^
____

a|
____
return list of _length_ (or all) elements of _list,_ starting with _list[start position]_. 1st position is 1, last position is -1
____

a|
____
_sublist([4,5,6], 1, 2) = [4,5]_
____

a|
____
append(_list, item..._)
____

a|
____
list, any element including *null*
____

a|
____
return new _list_ with __item__s appended
____

a|
____
_append([1], 2, 3) = [1,2,3]_
____

a|
____
concatenate(_list..._)
____

a|
____
list
____

a|
____
return new _list_ that is a concatenation of the arguments
____

a|
____
_concatenate([1,2],[3]) = [1,2,3]_
____

a|
____
insert before(_list, position, newItem_)
____

a|
____
list, number^1^, any element including *null*
____

a|
____
return new _list_ with _newItem_ inserted at _position_
____

a|
____
_insert before ([1 ,3], 1,2) = [2,1,3]_
____

a|
____
remove(_list, position_)
____

a|
____
list, number^1^
____

a|
____
_list_ with item at _position_ removed
____

a|
____
_remove ([1 ,2,3], 2) = [1,3]_
____

a|
____
reverse(_list_)
____

a|
____
list
____

a|
____
reverse the _list_
____

a|
____
_reverse ([1 ,2,3]) = [3,2,1]_
____

a|
____
index of(_list, match_)
____

a|
____
list, any element including *null*
____

a|
____
return ascending list of _list_ positions containing _match_
____

a|
____
_index of([1,2,3,2],2) = [2,4]_
____

a|
____
union(_list..._)
____

a|
____
list
____

a|
____
concatenate with duplicate removal
____

a|
____
_union ([1,2],[2,3]) = [1,2,3]_
____

a|
____
distinct values(_list_)
____

a|
____
list
____

a|
____
duplicate removal
____

a|
____
_distinct values([1,2,3,2, 1]) = [1,2,3]_
____

a|
____
flatten(_list_)
____

a|
____
list
____

a|
____
flatten nested lists
____

a|
____
_flatten ([[1 ,2],[[3]], 4]) = [1,2,3,4]_
____

a|
____
product( _list_ ) product( _n~1~, ..., n~n~_)
____

a|
____
_list_ is a list of numbers. _n~1~ ... n~n~_ are numbers.
____

a|
____
Returns the product of the numbers
____

a|
____
_product([2, 3, 4]) = 24_

_product([]) = null_

_product(2, 3, 4) = 24_
____

a|
____
median( _list_ ) median( _n~1~, ..., n~n~_ )
____

a|
____
_list_ is a list of number. _n~1~ ... n~n~_ are numbers.
____

a|
____
Returns the median element of the list of numbers. I.e., after sorting the list, if the list has an odd number of elements, it returns the middle element. If the list has an even number of elements, returns the average of the two middle elements. If the list is empty, returns null.
____

a|
____
_median( 8, 2, 5, 3, 4 ) = 4 median( [6, 1, 2, 3] ) = 2.5 median( [ ] ) = null_
____

a|
____
stddev( _list_ ) stddev( _n~1~, ..., n~n~_ )
____

a|
____
_list_ is a list of number. _n~1~ ... n~n~_ are numbers.
____

a|
____
Returns the *sample standard deviation* of the list of numbers. If the _list_ is empty or if the _list_ contains only one element, the function returns null.
____

a|
____
_stddev( 2, 4, 7, 5 ) = 2.08166599946613273528229 7706979931 +
stddev( [ 47 ] ) = null +
stddev( 47 ) = null_

_stddev( [ ] ) = null_
____

a|
____
mode( _list_ ) mode( _n~1~, ..., n~n~_ )
____

a|
____
_list_ is a list of number. _n~1~ ... n~n~_ are numbers.
____

a|
____
Returns the mode of the list of numbers. If the result contains multiple elements, they are returned in ascending order. If the list is empty, an empty list is returned.
____

a|
____
_mode( 6, 3, 9, 6, 6 ) = [ 6 ] mode( [6, 1, 9, 6, 1] ) = [ 1, 6 ] mode( [ ] ) = [ ]_
____

|===

[arabic]
. {blank}
. {blank}

_position_ must be a non-zero integer (0 scale number) in the range [-L..L], where L is the length of the list__length__ must be in the range [1 ..E], where E is L – _start position_ + 1 if _start position_ is positive, and _–start position_ otherwise.

===== Numeric functions

*Table _76_* defines numeric functions.

.[#_Toc87279022 .anchor]##*Table* *92: For attributes and model associations*
[width="99%",cols="20%,25%,26%,29%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
decimal(_n, scale_)
____

a|
____
number, number^1^
____

a|
____
return _n_ with given _scale_
____

a|
____
_decimal(1/3, 2) = .33 +
decimal(1.5, 0) = 2 +
decimal(2. 5, 0) = 2_
____

| | | |
| | | |
a|
____
floor(_n_)

floor(_n_, _scale_)
____

a|
____
number

number, number1
____

a|
____
Return n with given scale and rounding mode flooring.

If at least one of n or scale is *null* the result is *null*.

For floor(n) the scale is 0
____

|_floor(1.5) = 1 +
floor(-1.56, 1) = -1.6_
a|
____
ceiling(_n_)

ceiling(_n_, _scale_)
____

a|
____
number

number, number1
____

a|
____
Return n with given scale and rounding mode ceiling.

If at least one of n or scale is *null* the result is *null*.

For ceiling(n) the scale is 0
____

|_ceiling(1.5) = 2 +
ceiling(-1.56, 1) = -1.5_
a|
____
round up(_n_, _scale_)
____

a|
____
number, number1
____

a|
____
Return n with given scale and rounding mode round up.

If at least one of n or scale is *null* the result is *null*.
____

|_round up(5.5, 0) = 6_ _ +
round up(-5.5, 0) = -6_ _ +
round up(1.121, 2) = 1.13 +
round up(-1.126, 2) = -1.13_
a|
____
round down(_n_, _scale_)
____

a|
____
number, number1
____

a|
____
Return n with given scale and rounding mode round down.

If at least one of n or scale is *null* the result is *null*.
____

|_round down(5.5, 0) = 5_ _ +
round down (-5.5, 0) = -5_ _ +
round down (1.121, 2) = 1.12 +
round down (-1.126, 2) = -1.12_
a|
____
round half up(_n_, _scale_)
____

a|
____
number, number1
____

a|
____
Return n with given scale and rounding mode round half up.

If at least one of n or scale is *null* the result is *null*.
____

|_round half up(5.5, 0) = 6_ _ +
round half up(-5.5, 0) = -6_ _ +
round half up(1.121, 2) = 1.12 +
round half up(-1.126, 2) = -1.13_
a|
____
round half down(_n_, _scale_)
____

a|
____
number, number1
____

a|
____
Return n with given scale and rounding mode round up.

If at least one of n or scale is *null* the result is *null*.
____

|_round half down (5.5, 0) = 5_ _ +
round half down (-5.5, 0) = -5_ _ +
round half down (1.121, 2) = 1.12 +
round half down (-1.126, 2) = -1.13_
a|
____
abs( _n_ )
____

a|
____
__n i__s a number, a days and time duration or a year and month duration
____

a|
____
Returns the absolute value of _n_.
____

a|
____
_abs( 10 ) = 10 +
abs( -10 ) = 10 +
abs(@”PT5H”) = @”PT5H” +
abs(@”-PT5H”) = @”PT5H”_
____

a|
____
modulo( _dividend_, _divisor_ )
____

a|
____
_dividend_ and _divisor_ are numbers, where _divisor_ must not be 0 (zero). Returns the remainder of the division of _dividend_ by _divisor_. In case either _dividend_ or _divisor_ is negative, the result has the same sign of the _divisor_. The modulo function can be expressed as follows:

modulo (dividend, divisor) = dividend - divisor*floor (dividen d/divisor).
____

a|
____
Returns the remainder of the division of dividend by divisor.
____

a|
____
_modulo( 12, 5 ) = 2 +
modulo(-12,5)= 3 +
modulo(12,-5)= -3 +
modulo(-12,-5)= -2 modulo(10. 1, 4.5)= 1.1 modulo(-10.1, 4.5)= 3.4 modulo(10.1, -4.5)= -3.4 modulo(-10.1, -4.5)= -1.1_
____

a|
____
sqrt( _number_ )
____

a|
____
_number_ is a number.
____

a|
____
Returns the square root of the given number. If _number_ is negative it returns null.
____

a|
____
_sqrt( 16 ) = 4_
____

a|
____
log( _number_ )
____

a|
____
_number_ is a number
____

a|
____
Returns the natural logarithm (base _e_) of the _number_ parameter.
____

a|
____
_log( 10 ) = 2.30258509299_
____

a|
____
exp( _number_ )
____

a|
____
_number_ is a number
____

a|
____
Returns the Euler’s number _e_ raised to the power of _number_.
____

a|
____
_exp( 5 ) = 148.413159102577_
____

a|
____
odd( _number_ )
____

a|
____
_number_ is a number
____

a|
____
Returns true if _number_ is odd, false if it is even.
____

a|
____
__odd( 5 ) = true +
__odd( 2 ) = _false_
____

a|
____
even( _number_ )
____

a|
____
_number_ is a number
____

a|
____
Returns true if _number_ is even, false if it is odd.
____

|__even( 5 ) = false +
__even ( 2 ) = _true_
|===

{empty}1. Scale is in the range [−6111 ..6176]

===== Date and time functions

*Table _77_* defines date and time functions.

.[#_Toc87279023 .anchor]##*Table* *93: Quantified attributes and model associations*
[width="100%",cols="27%,24%,24%,25%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
is(_value1_, _value2_)
____

a|
____
Both are elements of the *D*
____

a|
____
Returns *true* if both values are the same element in the FEEL semantic domain *D* (see 10.3.2.2)
____

a|
____
_is(date("2012-12-25"), time("23:00:50”))_ is *false*

_is(date("2012-12-25"), date("2012-12-25"))_ is *true*

_is(time("23:00:50z"), time("23:00:50”))_ is *false*

_is(time("23:00:50z"), time("23:00:50+00:00”))_ is *true*
____

|===

===== Range Functions

The following set of functions establish relationships between single scalar values and ranges of such values. All functions in this list take two arguments and return True if the relationship between the argument holds, or False otherwise.

The specification of these functions is heavily inspired by the equivalent functions in the HL7 CQL (Clinical Quality Language) standard version 1.4.

The following table intuitively depicts the relationships defined by the functions in this chapter, but the full semantics of the functions are listed in

*Table _78_*.

image:extracted-media/media/image100.png[image,width=615,height=392]

.[#_Toc87279024 .anchor]##*Table 94: DMNDI attributes*
[width="100%",cols="34%,33%,33%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Evaluates to true if and only if (for each signature, respectively)*
____

a|
____
*Example*
____

a|
____
{empty}(a) before(_point1_, _point2_)
____

a|
____
{empty}(a) +
point1 < point2
____

a|
____
before( 1, 10 ) = true +
before( 10, 1 ) = false
____

a|
____
{empty}(b) before(_point_, _range_)
____

a|
____
{empty}(b) +
point < range.start +
or +
(point = range.start +
and +
not(range.start included) )
____

a|
____
before( 1, [1.. 10] ) = false +
before( 1, (1..10] ) = true +
before( 1, [5.. 10] ) = true
____

a|
____
{empty}(c) before(_range_, _point_)
____

a|
____
{empty}(c) +
range.end < point +
or +
(range.end = point +
and +
not(range.end included) )
____

a|
____
before( [1..10], 10 ) = false +
before( [1..10), 10 ) = true +
before( [1..10], 15 ) = true
____

a|
____
{empty}(d) before(_range1_,_range2_)
____

a|
____
{empty}(d) +
range 1 .end < range2.start +
or +
(( not(range1 .end included) +
or +
not(range2.start included)) +
and +
range 1 .end = range2.start)
____

a|
____
before( [1..10], [15..20] ) = true +
before( [1..10], [10..20] ) = false +
before( [1..10), [10..20] ) = true +
before( [1..10], (10..20] ) = true
____

a|
____
{empty}(a) after(_point1_, _point2_)
____

a|
____
{empty}(a) +
point1 > point2
____

a|
____
after( 10, 5 ) = true +
after( 5, 10 ) = false
____

a|
____
{empty}(b) after(_point_, _range_)
____

a|
____
{empty}(b) +
point > range.end +
or +
(point = range.end +
and +
not(range.end included) )
____

a|
____
after( 12, [1..10] ) = true +
after( 10, [1..10) ) = true +
after( 10, [1..10] ) = false
____

a|
____
{empty}(c) after(range, point)
____

a|
____
{empty}(c) +
range.start > point +
or +
(range.start = point +
and +
not(range.start included) )
____

a|
____
after( [11..20], 12 ) = false +
after( [11 ..20], 10 ) = true +
after( (11..20], 11 ) = true +
after( [11 ..20], 11 ) = false
____

a|
____
{empty}(d) after(_range1_, _range2_)
____

a|
____
{empty}(d) +
range 1 .start > range2.end +
or +
(( not(range1 .start included) +
or +
not(range2.end included) ) +
and +
range 1 .start = range2.end)
____

a|
____
after( [11..20], [1..10] ) = true +
after( [1 ..1 0], [11 ..20] ) = false +
after( [11 ..20], [1.. 11) ) = true +
after( (11..20], [1..11] ) = true
____

a|
____
{empty}(a) meets(_range1_, _range2_)
____

a|
____
(a)

range1.end included

and

range2.start included

and

range 1 .end = range2.start
____

a|
____
meets( [1..5], [5..10] ) = true meets( [1..5), [5..10] ) = false meets( [1..5], (5..10] ) = false meets( [1..5], [6..10] ) = false
____

a|
____
{empty}(a) met by(_range1_, _range2_)
____

a|
____
(a)

range1.start included

and

range2.end included

and

range 1 .start = range2.end
____

a|
____
met by( [5..10], [1..5] ) = true met by( [5..10], [1..5) ) = false met by( (5..10], [1..5] ) = false met by( [6..10], [1..5] ) = false
____

a|
____
{empty}(a) overlaps(_range1_, _range2_)
____

a|
____
(a)

(range1.end > range2.start

or

(range1.end = range2.start

and

range1.end included

and

range2.start included))

and

(range1.start < range2.end

or

(range1.start = range2.end

and

range1.start included

and

range2.end included))
____

a|
____
overlaps( [1..5], [3..8] ) = true overlaps( [3..8], [1 ..5] ) = true overlaps( [1 ..8], [3..5] ) = true overlaps( [3..5], [1 ..8] ) = true overlaps( [1 ..5], [6..8] ) = false overlaps( [6..8], [1 ..5] ) = false overlaps( [1 ..5], [5..8] ) = true overlaps( [1 ..5], (5..8] ) = false overlaps( [1 ..5), [5..8] ) = false overlaps( [1 ..5), (5. .8] ) = false overlaps( [5..8], [1 ..5] ) = true overlaps( (5..8], [1 ..5] ) = false overlaps( [5..8], [1 ..5) ) = false overlaps( (5..8], [1 ..5) ) = false
____

a|
____
{empty}(a) overlaps before(_range1_, _range2_)
____

a|
____
(a)
____

(range1.start < range2.start

or

(range1.start = range2.start

and

range1.start included

and

not(range2.start included)))

and

(range1.end > range2.start

or

(range1.end = range2.start

and

range1.end included

and

range2.start included))

and

(range1.end < range2.end

or

(range1.end = range2.end

and

(not(range1.end included)

or

range2.end included )))

a|
____
overlaps before( [1 ..5], [3..8] ) = true overlaps before( [1 ..5], [6..8] ) = false overlaps before( [1 ..5], [5..8] ) = true overlaps before( [1 ..5], (5..8] ) = false overlaps before( [1 ..5), [5..8] ) = false overlaps before( [1 ..5), (1. .5] ) = true overlaps before( [1 ..5], (1 ..5] ) = true +
overlaps before( [1 ..5), [1 ..5] ) = false +
overlaps before( [1 ..5], [1 ..5] ) = false
____

|(a) overlaps after(_range1_, _range2_) a|
____
{empty}(a) +
(range2.start < range1.start +
or +
(range2.start = range1.start +
and +
range2.start included +
and +
not( range 1.start included))) +
and +
(range2.end > range 1.start +
or +
(range2.end = range 1.start +
and +
range2.end included +
and +
range 1.start included )) +
and +
(range2.end < range1.end +
or +
(range2.end = range1.end +
and +
(not(range2.end included) +
or +
range1.end included)))
____

a|
____
overlaps after( [3..8], [1 ..5]) = true +
overlaps after( [6..8], [1 ..5]) = false +
overlaps after( [5..8], [1 ..5]) = true +
overlaps after( (5..8], [1 ..5]) = false +
overlaps after( [5..8], [1 ..5)) = false +
overlaps after( (1 ..5], [1 ..5) ) = true +
overlaps after( (1 ..5], [1 ..5] ) = true +
overlaps after( [1 ..5], [1 ..5) ) = false +
overlaps after( [1 ..5], [1 ..5] ) = false
____

a|
____
{empty}(a) finishes(_point, range_)
____

a|
____
{empty}(a) +
range.end included +
and +
range.end = point
____

a|
____
finishes( 10, [1..10] ) = true +
finishes( 10, [1..10) ) = false
____

a|
____
{empty}(b) finishes(_range1_, _range2_)
____

a|
____
{empty}(b) +
range1.end included = range2.end included +
and +
range1.end = range2.end +
and +
(range1.start > range2.start +
or +
(range1.start = range2.start +
and +
(not(range1.start included) +
or +
range2.start included)))
____

a|
____
finishes( [5..10], [1..10] ) = true +
finishes( [5..10), [1..10] ) = false +
finishes( [5..10), [1..10) ) = true +
finishes( [1..10], [1..10] ) = true +
finishes( (1..10], [1..10] ) = true
____

a|
____
{empty}(a) finished by(_range, point_)
____

a|
____
{empty}(a) +
range.end included +
and +
range.end = point
____

a|
____
finished by( [1..10], 10 ) = true +
finished by( [1..10), 10 ) = false
____

a|
____
{empty}(b) finished by(_range1_, _range2_)
____

a|
____
{empty}(b) +
range1.end included = range2.end included +
and +
range1.end = range2.end +
and +
(range1.start < range2.start +
or +
(range1.start = range2.start +
and +
(range1.start included +
or +
not(range2.start included))))
____

a|
____
finished by( [1..10], [5..10] ) = true +
finished by( [1..10], [5..10) ) = false +
finished by( [1..10), [5..10) ) = true +
finished by( [1..10], [1..10] ) = true +
finished by( [1..10], (1..10] ) = true
____

a|
____
{empty}(a) includes(_range_, _point_)
____

a|
____
{empty}(a) +
(range.start < point and range.end > point) +
or +
(range.start = point and range.start included) +
or +
(range.end = point and range.end included)
____

a|
____
includes( [1..10], 5 ) = true +
includes( [1..10], 12 ) = false +
includes( [1..10], 1 ) = true +
includes( [1..10], 10 ) = true +
includes( (1..10], 1 ) = false +
includes( [1..10), 10 ) = false
____

a|
____
{empty}(b) includes(_range1_, _range2_)
____

a|
____
{empty}(b) +
(range1.start < range2.start +
or +
(range1.start = range2.start +
and +
(range1.start included +
or +
not(range2.start included)))) +
and +
(range1.end > range2.end +
or +
(range1.end = range2.end +
and +
(range1.end included +
or +
not(range2.end included))))
____

a|
____
includes( [1..10], [4..6] ) = true +
includes( [1..10], [1..5] ) = true +
includes( (1..10], (1..5] ) = true +
includes( [1..10], (1..10) ) = true +
includes( [1..10), [5..10) ) = true +
includes( [1..10], [1..10) ) = true +
includes( [1..10], (1..10] ) = true +
includes( [1..10], [1..10] ) = true
____

a|
____
{empty}(a) during(_point_, _range_)
____

a|
____
{empty}(a) +
(range.start < point and range.end > point) +
or +
(range.start = point and range.start included) +
or +
(range.end = point and range.end included)
____

a|
____
during( 5, [1..10] ) = true +
during( 12, [1..10] ) = false +
during( 1, [1..10] ) = true +
during( 10, [1..10] ) = true +
during( 1, (1..10] ) = false +
during( 10, [1..10) ) = false
____

a|
____
{empty}(b) during(_range1_, _range2_)
____

a|
____
{empty}(b) +
(range2.start < range1.start +
or +
(range2.start = range1.start +
and +
(range2.start included +
or +
not(range1.start included)))) +
and +
(range2.end > range1.end +
or +
(range2.end = range1.end +
and +
(range2.end included +
or +
not(range1.end included))))
____

a|
____
during( [4..6], [1..10] ) = true +
during( [1..5], [1..10] ) = true +
during( (1..5], (1..10] ) = true +
during( (1..10), [1..10] ) = true +
during( [5..10), [1..10) ) = true +
during( [1..10), [1..10] ) = true +
during( (1..10], [1..10] ) = true +
during( [1..10], [1..10] ) = true
____

a|
____
{empty}(a) starts(_point_, _range_)
____

a|
____
{empty}(a) +
range.start = point +
and +
range.start included
____

a|
____
starts( 1, [1..10] ) = true +
starts( 1, (1..10] ) = false +
starts( 2, [1..10] ) = false
____

a|
____
{empty}(b) starts(_range1_, _range2_)
____

a|
____
{empty}(b) +
range1.start = range2.start +
and +
range1.start included = range2.start included +
and +
(range1.end < range2.end +
or +
(range1.end = range2.end +
and +
(not(range1.end included) +
or +
range2.end included)))
____

a|
____
starts( [1..5], [1..10] ) = true +
starts( (1..5], (1..10] ) = true +
starts( (1..5], [1..10] ) = false +
starts( [1..5], (1..10] ) = false +
starts( [1..10], [1..10] ) = true +
starts( [1..10), [1..10] ) = true +
starts( (1..10), (1..10) ) = true
____

a|
____
{empty}(a) started by(_range_, _point_)
____

a|
____
{empty}(a) +
range.start = point +
and +
range.start included
____

a|
____
started by( [1..10], 1 ) = true +
started by( (1..10], 1 ) = false +
started by( [1..10], 2 ) = false
____

a|
____
{empty}(b) started by(_range1_, _range2_)
____

a|
____
{empty}(b) +
range1.start = range2.start +
and +
range1.start included = range2.start included +
and +
(range2.end < range1.end +
or +
(range2.end = range1.end +
and +
(not(range2.end included) +
or +
range1.end included)))
____

a|
____
started by( [1..10], [1..5] ) = true +
started by( (1..10], (1..5] ) = true +
started by( [1..10], (1..5] ) = false +
started by( (1..10], [1..5] ) = false +
started by( [1..10], [1..10] ) = true +
started by( [1..10], [1..10) ) = true +
started by( (1..10), (1..10) ) = true
____

a|
____
{empty}(a) coincides(_point1_, _point2_)
____

a|
____
{empty}(a) point1 = point2
____

a|
____
coincides( 5, 5 ) = true +
coincides( 3, 4 ) = false
____

a|
____
{empty}(b) coincides(_range1_, _range2_)
____

a|
____
{empty}(b) range1.start = range2.start +
and +
range1.start included = range2.start included +
and +
range1.end = range2.end +
and +
range1.end included = range2.end included
____

a|
____
coincides( [1..5], [1..5] ) = true +
coincides( (1..5), [1..5] ) = false +
coincides( [1..5], [2..6] ) = false
____

|===

===== Temporal built-in functions

The following set of functions provide common support utilities when dealing with date or date and time values; listed in *Table _1_*.

.[#_Toc87279025 .anchor]##*Table 95: DMNDiagram attributes*
[width="100%",cols="3%,24%,24%,24%,25%",options="header",]
|===
| a|
____
*Name(parameters)*
____

a|
____
*Parameter Domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

| a|
____
day of year( date )
____

a|
____
date or

date and time
____

a|
____
returns the Gregorian number of the day within the year
____

a|
____
day of year( date(2019, 9, 17) ) = 260
____

| a|
____
day of week( date )
____

a|
____
date or date and time
____

a|
____
returns the day of the week according to the Gregorian calendar enumeration: “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”, “Sunday”
____

a|
____
day of week( date(2019, 9, 17) ) = "Tuesday"
____

|month of year( date ) | a|
____
date or date and time
____

a|
____
returns the month of the year according to the Gregorian calendar enumeration: “January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December”
____

a|
____
month of year( date(2019, 9, 17) ) = "September"
____

|week of year( date ) | a|
____
date or date and time
____

a|
____
returns the Gregorian number of the week within the year, accordingly to ISO 8601
____

a|
____
week of year( date(2019, 9, 17) ) = 38 +
week of year( date(2003, 12, 29) ) = 1 +
week of year( date(2004, 1, 4) ) = 1 +
week of year( date(2005, 1, 1) ) = 53 +
week of year( date(2005, 1, 3) ) = 1 +
week of year( date(2005, 1, 9) ) = 1
____

|===

===== Sort

____
Sort a list using an ordering function. For example,

sort(list: [3,1,4,5,2], precedes: function(x,y) x < y) = [1,2,3,4,5]
____

.[#_Toc87279026 .anchor]##*Table 96: DMNDiagramElement attributes*
[width="100%",cols="45%,55%",options="header",]
|===
a|
____
*Parameter name* (* means optional)
____

a|
____
*Domain*
____

a|
____
list
____

a|
____
list of any element, be careful with nulls
____

a|
____
precedes
____

a|
____
boolean function of 2 arguments defined on every pair of list elements
____

|===

=====  Context function

*Table _81_* defines Context functions

.[#_Toc87279027 .anchor]##*Table 97: DMNShape attributes*
[width="100%",cols="27%,24%,24%,25%",options="header",]
|===
a|
____
*Name(parameters)*
____

a|
____
*Parameter domain*
____

a|
____
*Description*
____

a|
____
*Example*
____

a|
____
get value(m, key)
____

a|
____
context, string
____

a|
____
select the value of the entry named key from context m
____

a|
____
_get value (\{key1 : "value1"}, "key1 ") = "value1" +
get value (\{key1 : "value 1"}, "unexistent-key") = null_
____

a|
____
get entries(m)
____

a|
____
context
____

a|
____
produces a list of key,value pairs from a context m
____

a|
____
_get entries(\{key1 : "value 1 ", key2 : "value2"}) = [ \{ key : "key1 ", value : "value 1" }, \{key : "key2", value :_

_"value2"} ]_
____

a|
____
context(entries)
____

a|
____
_entries_ is a list of contexts, each context item SHALL have two entries having keys: "key" and "value", respectively.
____

a|
____
Returns a new context that includes all specified entries.

If a context item contains additional entries beyond the required "key" and "value" entries, the additional entries are ignored.

If a context item is missing the required "key" and "value" entries, the final result is null.

See also: _get entries()_ built-in function.
____

a|
____
_context([\{key:"a", value:1}, \{key:"b", value:2}]) = \{a:1, b:2}_

_context([\{key:"a", value:1}, \{key:"b", value:2, something: "else"}]) = \{a:1, b:2}_

_context([\{key:"a", value:1}, \{key:"b"}]) = null_
____

a|
____
{empty}(a) context put(context, key, value)
____

a|
____
(a)

_context_ is a context,

_key_ is a string,

_value_ is Any type
____

a|
____
{empty}(a) Returns a new context that includes the new entry, or overriding the existing value if an entry for the same key already exists in the supplied context parameter.

A new entry is added as the last entry of the new context. If overriding an existing entry, the order of the keys maintains the same order as in the original context.
____

a|
____
_context put(\{x:1}, "y", 2) = \{x:1, y:2}_

_context put(\{x:1, y:0}, "y", 2) = \{x:1, y:2}_

_context put(\{x:1, y:0, z:0}, "y", 2) = \{x:1, y:2, z:0}_

_context put(\{x:1}, ["y"], 2) = context put(\{x:1}, "y", 2) = \{x:1, y:2}_
____

a|
____
{empty}(b) context put(context, keys, value)
____

a|
____
(b)

_context_ is a context,

_keys_ is a list of string,

_value_ is Any type
____

a|
____
{empty}(b) Returns the composite of nested invocations to _context put()_ for each item in _keys_ hierarchy in _context_. +
 +
If keys is a list of 1 element, this is equivalent to _context put(context, key', value)_, where _key'_ is the only element in the list _keys_. +
 +
If keys is a list of 2 or more elements, this is equivalent of calling _context put(context, key', value')_, with: +
_key'_ is the head element in the list _keys_, +
_value'_ is the result of invocation of _context put(context', keys', value)_, where: +
_context'_ is the result of context.key', +
_keys'_ is the remainder of the list _keys_ without the head element _key'_. +
 +
If keys is an empty list or null, the result is null.
____

a|
____
_context put(\{x:1, y: \{a: 0} }, ["y", "a"], 2)_

_= context put(\{x:1, y: \{a: 0} }, "y", context put(\{a: 0}, ["a"], 2))_

_= \{x:1, y: \{a: 2} }_

_context put(\{x:1, y: \{a: 0} }, [], 2) = null_
____

a|
____
context merge(contexts)
____

a|
____
_contexts_ is a list of contexts
____

a|
____
Returns a new context that includes all entries from the given contexts; if some of the keys are equal, the entries are overriden. +
 +
The entries are overridden in the same order as specified by the supplied parameter, with new entries added as the last entry in the new context.
____

a|
____
_context merge([\{x:1}, \{y:2}]) = \{x:1, y:2}_

_context merge([\{x:1, y:0}, \{y:2}]) = \{x:1, y:2}_
____

|===

===== Miscellaneous functions

The following set of functions provide support utilities for several miscellaneous use-cases. For example, when a decision depends on the current date, like deciding the support SLA over the weekends, additional charges for weekend delivery, etc.

It is important to note that the functions in this section are intended to be side-effect-free, but they are not deterministic and not idempotent from the perspective of an external observer.

Vendors are encouraged to guide end-users in ensuring deterministic behavior of the DMN model during testing, for example, through specific configuration.

Users are encouraged to isolate decision logic that uses these functions in specific DRG elements, such as Decisions. This encapsulation enables them to be overridden with synthetic values that remain constant across executions of the DMN model's test cases.

.[#_Toc87279028 .anchor]##*Table 98: DMNEdge attributes*
[width="100%",cols="34%,33%,33%",options="header",]
|===
|*Name(parameters)* |*Parameter domain* |*Description*
|now() |(none) |returns current date and time
|today() |(none) |returns current date
|===

===  Execution Semantics of Decision Services

FEEL gives execution semantics to decision services defined in decision models where FEEL is the expression language. A decision service is semantically equivalent to a FEEL function whose parameters are the decision service inputs, and whose logic is a context assembled from the decision service's decisions and knowledge requirements.

Decision service implementations SHALL return a result as described above, and MAY return additional information such as intermediate results, log records, debugging information, error messages, rule annotations, etc. The format of any additional information is left unspecified.

Every FEEL expression in a decision model has execution semantics. LiteralExpression (FEEL text) semantics is defined in 10.3. Boxed expressions described in 10.2.2 can be mapped to FEEL text and thus also have execution semantics.

Recall that a DecisionService is defined by four lists: inputData, inputDecisions, outputDecisions, and encapsulatedDecisions. The lists are not independent and thus not all required to be specified, e.g., each required decision (direct and indirect) of the outputDecisions must be an encapsulatedDecision, an inputDecision, or required by an inputDecision. For simplicity in the following, we assume that all four lists are correctly and completely specified.

A DecisionService is given execution semantics by mapping it to a FEEL function _F_. Let S be a DecisionService with input data _id1_, _id2_, ..., input decisions _di1_, _di2_, ..., encapsulated decisions _de1_, _de2_, ..., and output decisions _do1_, _do2_, .... Each input data _idi_ has a qualified name _nidi_. Each decision _di_ has a qualified name _ndi_ and a decision logic expression _ed_. The decisions may have knowledge requirements. In particular the decisions may require BusinessKnowledgeModels _bkm1_, _bkm2_, ... and DecisionServices _s1_, _s2_, .... BusinessKnowledgeModels have qualified names _nbkmi_ and encapsulatedLogic _f~bkmi~_. DecisionServices have qualified names _nsi_ and equivalent logic _fsi_, where the equivalent logic is defined recursively, binding _si_ to S.

The syntax for FEEL function _F_ is _funcion(nid1, nid2, ..., ndi1, ndi2, ... ) C.result_, where _C_ is the context _\{_

____
_ns1 : fs1, ns2 : fs2, ...,_

_nbkm1 : fbkm1, nbkm2 : fbkm2, ...,_

_nde1 : ede1, nde2 : ede2, ...,_

_result: \{ ndo1 : edo1, ndo2 : edo2, . ..}_
____

such that _si_, _bkmi_, _dei_ and _doi_ are partially ordered by requirements (e.g., the context entry for a required decision comes before a decision that requires it).

The qualified name of an element named E (decision, input data, decision service, or BKM) that is defined in the same decision model as S is simply E. Otherwise, the qualified name is I.E, where I is the name of the import element that refers to the model where E is defined.

The execution semantics of S is FEEL(_F_): a function that when invoked with values from the FEEL semantic domain bound to the parameters representing input data and input decisions, returns:

* {blank}
* {blank}

____
In the case of a single output decision(s), the single decision's output value.In the case of multiple output decisions, a context consisting of all the output decisions' output values.XML elements SHALL map to the FEEL semantic domain as specified in section 10.3.3. Otherwise, details of the syntax of input/output data values and mapping to/from FEEL are undefined.
____

===  Metamodel

image:extracted-media/media/image101.png[image,width=650,height=484]

[#_Toc87278866 .anchor]##*Figure 10‑27: Expression class diagram*

The class Expression is extended to support the four new kinds of boxed expressions introduced by FEEL, namely: Context, FunctionDefinition, Relation and List.

Boxed expressions are Expressions that have a standard diagrammatic representation (see clauses 7.2.1 and 10.2.1). FEEL _contexts_, _function definitions_, _relations_ and _lists_ SHOULD be modeled as Context, FunctionDefinition, Relation and List elements, respectively, and represented as a boxed expression whenever possible; that is, when they are top-level expressions, since an instance of LiteralExpression cannot contain another Expression element.

==== Context metamodel

A Context is composed of any number of contextEntrys, which are instances of ContextEntry.

A Context element is represented diagrammatically as a *boxed context* (clause 10.2.1.4). A FEEL _context_ (grammar rule 57 and clause 10.3.2.6) SHOULD be modeled as a Context element whenever possible.

Context inherits all the attributes and model associations from Expression. *Table _83_* presents the additional attributes and model associations of the Context element.

.[#_Toc87279029 .anchor]##*Table 99: DMNLabel attributes*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*contextEntry*: ContextEntry [*]
____

a|
____
This attributes lists the instances of ContextEntry that compose this Context.
____

|===

====  ContextEntry metamodel

The class ContextEntry is used to model FEEL _context entries_ when a _context_ is modeled as a Context element. ContextEntry is a specialization of DMNElement, from which it inherits the optional id, description, and label attributes.

An instance of ContextEntry is composed of an optional variable, which is an InformationItem element whose name is the _key_ in the _context entry_, and of a value, which is the instance of Expression that models the _expression_ in the _context entry_.

*Table _84_* presents the attributes and model associations of the ContextEntry element.

.[#_Toc87279030 .anchor]##*Table 100: DMNStyle attributes*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*variable*: InformationItem [0..1]
____

a|
____
The instance of InformationItem that is contained in this ContextEntry, and whose name is the _key_ in the modeled _context_ _entry_
____

a|
____
*value*: Expression
____

a|
____
The instance of Expression that is the _expression_ in this ContextEntry
____

|===

====  FunctionDefinition metamodel

A FunctionDefinition has formalParameters and a body. A FunctionDefinition element is represented diagrammatically as a *boxed function*, as described in clause. A FEEL _function definition_ (grammar rule 55 and clause 10.3.2.15) SHOULD be modeled as a FunctionDefinition element whenever possible.

FunctionDefinition inherits all the attributes and model associations from Expression. *Table _85_* presents the additional attributes and model associations of the Function Definition element.

.[#_Toc87279031 .anchor]##*Table 101: Depiction Resolution for Decision*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*FormalParameter*: InformationItem [*]
____

a|
____
This attributes lists the instances of InformationItem that are the parameters of this Context.
____

a|
____
*body*: Expression [0..1]
____

a|
____
The instance of Expression that is the body in this FunctionDefinition
____

a|
____
*kind*: FunctionKind = FEEL \{ FEEL | Java | PMML }
____

a|
____
The kind attribute defines the type of the FunctionDefinition. The default value is FEEL. Supported values also include Java and PMML
____

|===

====  List metamodel

A List is simply a list of element, which are instances of Expressions. A List element is represented diagrammatically as a *boxed list*, as described in clause 10.2.1.5. A FEEL _list_ (grammar rule 54 and clause 10.3.2.15) SHOULD be modeled as a List element whenever possible.

List inherits all the attributes and model associations from Expression. *Table _86_* presents the additional attributes and model associations of the List element.

.[#_Toc87279032 .anchor]##*Table 102: Depiction Resolution for Business Knowledge Model*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*element*: Expression [*]
____

a|
____
This attributes lists the instances of Expression that are the elements in this List.
____

|===

====  Relation metamodel

A Relation is convenient shorthand for a list of similar contexts. A Relation has a column instead of repeated ContextEntrys, and a List is used for every row, with one of the List’s expression for each column value.

Relation inherits all the attributes and model associations from Expression. *Table _87_* presents the additional attributes and model associations of the Relation element.

.[#_Toc87279033 .anchor]##*Table 103: Depiction Resolution for Input Data*
[width="100%",cols="43%,57%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*row*: List [*]
____

a|
____
This attributes lists the instances of List that compose the rows of this Relation.
____

a|
____
*column*: InformationItem [*]
____

a|
____
This attributes lists the instances of InformationItem that define the columns in this Relation.
____

|===

==== Conditional metamodel

A Conditional is a visual way to express an if statement.

Conditional inherits all the attributes and model associations from Expression. Table 88 presents the additional attributes and model associations of the Conditional element.

.[#_Toc87279034 .anchor]##*Table 104: Depiction Resolution for Knowledge Source*
[width="100%",cols="32%,68%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|===

.[#_Toc87279035 .anchor]##*Table 105: Depiction Resolution of Artifacts*
[width="100%",cols="33%,67%",options="header",]
|===
|*if*: ChildExpression |This attribute holds the expression that is evaluate by the conditional expression.
|*then*: ChildExpression |This attribute holds the expression that will be evaluated when the condition in the if statement evaluates to *true*.
|*else*: ChildExpression |This attribute holds the expression that will be evaluated when the condition in the if statement evaluates to *false*.
|===

==== ChildExpression metamodel

A ChildExpression is used to hold an expression inside a node. Table 89 presents the attributes of a ChildExpression.

.[#_Toc87279036 .anchor]##*Table 106: Depiction Resolution of Decision Service*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|*id*: ID[0..1] |Optional identifier for this element. SHALL be unique within its containing Definitions element.
|*value*: Expression |The instance of Expression that is the expression in this ChildExpression
|===

==== Filter metamodel

A Filter is a visual way to express list filtering.

Filter inherits all the attributes and model associations from Expression. Table XX presents the additional attributes and model associations of the Filter element.

.[#_Toc87279037 .anchor]##*Table 107: Depiction Resolution of Information Requirement*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|*in*: ChildExpression |This attribute holds the expression that is evaluate as the collection to be filtered.
|*match*: ChildExpression |This attribute holds the expression that is used to filter the collection.
|===

==== Iterator metamodel

An Iterator is the abstract class for all boxed iteration.

Iterator inherits all the attributes and model associations from Expression. Table 91 presents the additional attributes and model associations of the Iterator element.

.[#_Toc87279038 .anchor]##*Table 108: Depiction Resolution of Knowledge Requirement*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|*iteratorVariable*: String |This attribute holds name of the iterator variable that will be populated at each iteration.
|*in*: TypedChildExpression |This attribute holds the expression that is evaluated as the collection to be processed.
|===

==== For metamodel

A For is a representation of a loop.

For inherits all the attributes and model associations from Iterator. Table 92 presents the additional attributes and model associations of the For element.

.[#_Toc87279039 .anchor]##*Table 109: Depiction Resolution of Authority Requirement*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|*return*: ChildExpression |This attribute holds the expression that is evaluated to create the new collection that will be returned.
|===

==== Quantified metamodel

A Quantified is an abstraction of an expression that is evaluated on each item of a collection.

Quantified inherits all the attributes and model associations from Iterator. Table XX presents the additional attributes and model associations of Quantified.

.[#_Toc87279040 .anchor]##*Table 110: Depiction Resolution of Association*
[width="100%",cols="50%,50%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

|*satisfies*: ChildExpression |This attribute holds the expression that is evaluated to determine if the current item satisfies a condition.
|===

==== Every metamodel

Every is an expression where all “satisfies” needs to be true for it to return true.

Every inherits all the attributes and model associations of Quantified.

==== Some metamodel

Some is an expression where at least one of the “satisfies” needs to be true for it to return true.

Some inherits all the attributes and model associations of Quantified.

=== Examples

A good way to get a quick overview of FEEL is by example.

FEEL expressions may reference other FEEL expressions by name. Named expressions are contained in a context. Expressions are evaluated in a scope, which is a list of contexts in which to resolve names. The result of the evaluation is an element in the FEEL semantic domain.

====  Context

Figure 10‑28 shows the boxed context used for the examples. Such a context could arise in several ways. It could be part of the decision logic for a single, complex decision. Or, it could be a context that is equivalent to part of a DRG as defined in clause 10.4, where _applicant, requested product,_ and _credit history_ are input data instances, _monthly income_ and _monthly outgoings_ are the results of other decisions linked through information requirements, and _PMT_ is a business knowledge model.

.[#_Toc87279041 .anchor]##*Table 111: BPMN tasks relevant to DMN*
[width="100%",cols="31%,25%,,11%,5%,9%,19%",options="header",]
|===
a|
____
applicant
____

a|
____
age
____

|51 | | | |
| a|
____
maritalStatus
____

|"M" | | | |
| a|
____
existingCustomer
____

|false | | | |
| a|
____
monthly
____

a|
____
income
____

| | |10000 |
| | a|
____
repayments
____

| | |2500 |
| | a|
____
expenses
____

| | |3000 |
a|
____
requested product
____

a|
____
product type
____

| | |"STANDARD LOAN" | |
| a|
____
rate
____

| | |0.25 | |
| a|
____
term
____

| | |36 | |
| a|
____
amount
____

| | |100000.00 | |
a|
____
monthly income
____

|applicant.monthly.income | | | | |
a|
____
monthly outgoings
____

|applicant.monthly.repayments, applicant.monthly.expenses | | | | |
a|
____
credit history
____

|record date | a|
____
event
____

| | |weight
| |date("2008-03-12") | |"home mortgage" | | |100
| |date("2011-04-01") | |"foreclosure warning" | | |150
a|
____
PMT
____

|(rate, term, amount) | | | | |
| |(amount *rate/12) / (1 - (1 + rate/12)**-term) | | | | |
|===

[#_Toc87278867 .anchor]##*Figure 10‑28: Example context*

Notice that there are 6 top-level context entries, represented by the six rows of the table. The value of the context entry named 'applicant' is itself a context, and the value of the context entry named 'monthly' is itself a context. The value of the context entry named 'monthly outgoings' is a list, the value of the context entry named 'credit history' is a relation, _i.e._ a list of two contexts, one context per row. The value of the context entry named 'PMT' is a function with parameters 'rate', 'term', and 'amount'.

The following examples use the above context. Each example has a pair of equivalent FEEL expressions separated by a horizontal line. Both expressions denote the same element in the semantic domain. The second expression, the ‘answer’, is a literal value.

====  Calculation

[.underline]#monthly income * 12 +
#120000

The context defines _monthly income_ as _applicant.monthly.income_, which is also defined in the context as 10,000. Twelve times the _monthly income_ is 120,000.

====  If, In

[.underline]#if applicant.maritalStatus in (“M”, “S”) then “valid” else “not valid” +
#“valid”

The _in_ test determines if the left-hand side expression satisfies the list of values or ranges on the right-hand side. If satisfied, the _if_ expression returns the value of the _then_ expression. Otherwise, the value of the _else_ expression is returned.

====  Sum entries of a list

[.underline]#sum (monthly outgoings) +
#5500

_Monthly outgoings_ is computed in the context as the list [_applicant.monthly.repayments, applicant.monthly.expenses_], or [2500, 3000]. The square brackets are not required to be written in the boxed context.

==== Invocation of user-defined PMT function

The PMT function defined in the context computes the monthly payments for a given interest rate, number of months, and loan amount.

PMT (requested product . rate, +
requested product . term, +
______[.underline]#requested product . amount)_____________________________ +
#3975.982590125552338278440100112431

A function is invoked textually using a parenthesized argument list after the function name. The arguments are defined in the context, and are 0.25, 36, and 100,000, respectively.

====  Sum weights of a recent credit history

sum (credit history[record date > date (“2011-01-01”)].weight +
[.underline]#150______________________________________________________________#

This is a complex "one-liner" that will be useful to expand into constituent sub-expressions:

____
. built-in: _sum_

o path expression ending in _.weight_

 filter: _[record date > date("2011-01-01 ")]_

. name resolved in context: _credit history_
____

An expression in square brackets following a list expression filters the list. _Credit history_ is defined in the context as a relation, that is, a list of similar contexts. Only the last item in the relation satisfies the filter. The first item is too old. The path expression ending in _.weight_ selects the value of the _weight_ entry from the context or list of contexts satisfied by the filter. The _weight_ of the last item in the credit history is 150. This is the only item that satisfies the filter, so the sum is 150 as well.

==== Determine if credit history contain a bankruptcy event

[.underline]#Some ch in credit history satisfies ch.event = “bankruptcy” +
#false

The _some_ expression determines if at least one element in a list or relation satisfies a test. There are no bankruptcy events in the credit history in the context.

== 

=== DMN Examples Example 1: Originations

====  Introduction

In this clause we present an example of the use of *DMN* to model and execute decision-making in a simple business process modeled in *BPMN*, including decisions to be automated in decision services called from the business process management system.

====  The business process model

Figure 11‑1 shows a simple process for loan originations, modeled in *BPMN 2.0*. The process handles as application for a loan, obtaining data from a credit bureau only if required for the case, and automatically deciding whether the application should be accepted, declined, or referred for human review. If referred, documents are collected from the applicant and a credit officer adjudicates the case. It consists of the following components:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

The *Collect application data* task collects data describing the Requested product and the Applicant (e.g., through an on-line application form).The Decide *bureau Strategy* task calls a decision service, passing Requested product and Applicant data. The service returns two decisions: Strategy and Bureau call type.A *gateway* uses the value of Strategy to route the case to Decline application, Collect bureau data or Decide routing.The *Collect bureau data* task collects data from a credit bureau according to the Bureau call type decision, then the case is passed to Decide routing.The *Decide routing* task calls a decision service, passing Requested product, Applicant data and Bureau data (if the Collect bureau data task was not performed, the Bureau data are set to null). The service returns a single decision: Routing.A *gateway* uses the value of Routing to route the case to Accept application, Review application or Decline application.The *Collect documents* task requests and uploads documents from the applicant in support of their application.The *Review application* task allows a credit officer to review the case and decide whether it should be accepted or declined.A *gateway* uses the credit officer’s Adjudication to route the case to Accept application or Decline application.The *Accept application* task informs the applicant that their application is accepted and initiates the product.The *Decline application* task informs the applicant that their application is declined.Note that in this example two decision points (automated as calls to decision services) are represented in *BPMN 2.0* as business rule tasks; the third decision point (which is human decision-making) is represented as a user task.

image:extracted-media/media/image104.png[image,width=611,height=698]

[#_Toc87278868 .anchor]##*Figure 11‑1: Example business process*

==== The decision requirements level

The examples in this chapter were developed using a software that adds icons to the elements. Although adding these icons is allowable by this document it is not normative.

===== Decision Requirements Diagrams

Figure 11‑2 shows a DRD of all the decision-making in this business process. There are four sources of input data for the decision-making (Requested product, Applicant data, Bureau data and Supporting documents), and four decisions whose results are used in the business process (Strategy, Bureau call type, Routing and Adjudication). Between the two are intermediate decisions: evaluations of risk, affordability and eligibility. Notable features of this DRD include:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

It covers both automated and human decision-making.Some decisions (e.g., Pre-bureau risk category) and input data (e.g., Applicant data) are required by multiple decisions, i.e., the information requirements network is not a tree.Business knowledge models (see Affordability calculation) may be invoked by multiple decisions.Business knowledge models (see Credit contingency factor) may be invoked by other business knowledge models.Some decisions do not have associated business knowledge models.Knowledge sources may provide authority for multiple decisions and/or business knowledge models.

image:extracted-media/media/image105.png[image,width=650,height=489]

[#_Toc87278869 .anchor]##*Figure 11‑2: DRD of all automated decision-making*

It might be considered more convenient to draw separate (but overlapping) DRDs for the three decision points:

* {blank}
* {blank}

____
Figure 11‑3 shows the DRD of the decisions required for the Decide bureau strategy decision point, i.e., the requirements subgraph of the Strategy and Bureau call type decisions. These are decisions to be automated through encapsulation in a decision service called at this point, and therefore need their logic to be specified completely.Figure 11‑4 shows the DRD for the Decide routing decision point, i.e. the requirements subgraph of the Routing decision. These are also decisions automated with a decision service, and therefore need their logic to be specified completely. Note that some elements appear in both Figure 11‑3 and Figure 11‑4.
____

* {blank}
* {blank}

Figure 11‑5 shows the DRD for the Review application decision point, i.e. the requirements subgraph of the Adjudication decision. This is a human decision and has no associated specification of decision logic, but the DRD indicates that the Credit officer takes into account the results of the automated Routing decision along with the case data, including the Supporting documents. (The requirements subgraph of the Routing decision has been hidden in this DRD as shown by the ellipsis (...) marker.)Figure 11‑6 shows an additional DRD for the Credit Risk Analytics Knowledge Source i.e. the requirements linking this Knowledge Source to other elements. DRDs can be used to provide views other than for a specific decision.All four DRDs – Figure 11‑2, Figure 11‑3, Figure 11‑4, Figure 11‑5 and Figure 11‑6 – are views of the same DRG.

image:extracted-media/media/image106.png[image,width=650,height=649]

[#_Toc87278870 .anchor]##*Figure 11‑3: DRD for Decide bureau strategy decision point*

image:extracted-media/media/image107.png[image,width=650,height=446]

[#_Toc87278871 .anchor]##*Figure 11‑4: DRD for Decide routing decision point*

image:extracted-media/media/image108.png[image,width=442,height=296]

[#_Toc87278872 .anchor]##*Figure 11‑5: DRD for Review application decision point*

image:extracted-media/media/image109.png[image,width=582,height=337]

[#_Toc87278873 .anchor]##*Figure 11‑6: DRD for Credit Risk Analytics Knowledge Source*

===== DRG Elements

====== Decisions

The DRG depicted in these DRDs shows dependencies between the following decisions:

* {blank}

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

The *Strategy* decision, requiring the Bureau call type and Pre-bureau eligibility decisions, invokes the Strategy table shown in Figure 11‑9 (without that table being encapsulated in a business knowledge model).The *Bureau call type* decision, requiring the Pre-bureau risk category decision, invokes the Bureau call type table shown in Figure 11‑11.The *Eligibility* decision, requiring Applicant data and the Pre-bureau risk category and Pre-bureau affordability decisions, invokes the Eligibility rules shown in Figure 11‑13.The *Pre-bureau affordability* decision, requiring Applicant data and the Pre-bureau risk category and Required monthly installment decisions, invokes the Affordability calculation boxed expression shown in Figure 11‑24, which in turn invokes the Credit contingency factor table shown in Figure 11‑25.The *Pre-bureau risk category* decision, requiring Applicant data and the Application risk score decision, invokes the Pre-bureau risk category table shown in Figure 11‑15.The *Application risk score* decision, requiring Applicant data, invokes the Application risk score model shown in Figure 11‑17.The *Routing* decision, requiring Bureau data and the Post-bureau affordability and Post-bureau risk category decisions, invokes the Routing rules shown in Figure 11‑19.The *Post-bureau affordability* decision, requiring Applicant data and the Post-bureau risk score and Required monthly installment decisions, invokes the Affordability calculation boxed expression shown in Figure 11‑24, which in turn invokes the Credit contingency factor table shown in Figure 11‑25.The *Post-bureau risk category* decision, requiring Applicant and Bureau data and the Application risk score decision, invokes the Post-bureau risk category table shown in Figure 11‑21.The *Required monthly installment* decision, requiring Requested product data, invokes the Installment calculation boxed expression shown in Figure 11‑27.The *Adjudication* decision, requiring Applicant data, Bureau data, Supporting documents, and the Routing decision, has no associated decision logic.Questions and allowed answers are specified for these decisions. These are typically used when modeling decisions for which no logic will be specified and for other decisions before it is appropriate to describe the decision logic in detail. The description and Question/Allowed Answers for each decision follow.

*Adjudication*

Question: Should this application that has been referred for adjudication be accepted? Allowed Answers: Yes/No

Description: Determine if an application requiring adjudication should be accepted or declined given the available application data and supporting documents.

*Application risk score*

Question: What is the risk score for this applicant?

Allowed Answers: A number greater than 70 and less than 150

Description: The *Application Risk Score* decision logic invokes the Application risk score model business knowledge model, passing Applicant data.Age as the Age parameter, Applicant data.MaritalStatus as the Marital Status parameter and Applicant data.EmploymentStatus as the Employment Status parameter.

*Bureau call type*

Question: How much data should be requested from the credit bureau for this application? Allowed Answers: A value from the explicit list "Full", "Mini", "None"

Description: The *Bureau call type* decision logic invokes the Bureau call type table, passing the output of the Pre-bureau risk category decision as the Pre-Bureau Risk Category parameter.

*Eligibility*

Question: Does this applicant appear eligible for the loan they applied for given only their application data? Allowed Answers: Value from the explicit list "Eligible", "Not Eligible"

Description: The *Eligibility* decision logic invokes the Eligibility rules business knowledge model, passing Applicant data.Age as the Age parameter, the output of the Pre-bureau risk category decision as the Pre-Bureau Risk Category parameter, and the output of the Pre-bureau affordability decision as the Pre-Bureau Affordability parameter.

*Pre-bureau affordability*

Question: Can the applicant afford the loan they applied for given only their application data?

Allowed Answers: Yes/No

Description: The *Pre-bureau affordability* decision logic invokes the Affordability calculation business knowledge model, passing Applicant data.Monthly.Income as the Monthly Income parameter, Applicant data.Monthly.Repayments as the Monthly Repayments parameter, Applicant data.Monthly.Expenses as the Monthly Expenses parameter, the output of the Pre-bureau risk category decision as the Risk Category parameter, and the output of the Required monthly installment decision as the Required Monthly Installment parameter.

*Post-bureau affordability*

Question: Can the applicant afford the loan they applied for given all available data?

Allowed Answers: Yes/No

Description: The *Post-bureau affordability* decision logic invokes the Affordability calculation business knowledge model, passing Applicant data.Monthly.Income as the Monthly Income parameter, Applicant data.Monthly.Repayments as the Monthly Repayments parameter, Applicant data.Monthly.Expenses as the Monthly Expenses parameter, the output of the Post-bureau risk category decision as the Risk Category parameter, and the output of the Required monthly installment decision as the Required Monthly Installment parameter.

*Pre-bureau risk category*

Question: Which risk category is most appropriate for this applicant given only their application data?

Allowed Answers: Value from explicit list "Decline", "High Risk", "Medium Risk", "Low Risk", "Very Low Risk"

Description: The Pre-Bureau Risk Category decision logic invokes the Pre-bureau risk category table business knowledge model, passing Applicant data.ExistingCustomer as the Existing Customer parameter and the output of the Application risk score decision as the Application Risk Score parameter.

*Post-bureau risk category*

Question: Which risk category is most appropriate for this applicant given all available data?

Allowed Answers: A value from the explicit list "Decline", "High Risk", "Medium Risk", "Low Risk", "Very Low Risk"

Description: The *Post-bureau risk category* decision logic invokes the Post-bureau risk category business knowledge model, passing Applicant data.ExistingCustomer as the Existing Customer parameter, Bureau data.CreditScore as the Credit Score parameter, and the output of the Application risk score decision as the Application Risk Score parameter. Note that if Bureau data is null (due to the THROUGH strategy bypassing the Collect bureau data task) the Credit Score parameter will be null.

*Required monthly installment*

Question: What is the minimum monthly installment payment required for this loan product? Allowed Answers: A dollar amount greater than zero

Description: The *Required monthly installment* decision logic invokes the Installment calculation business knowledge model, passing Requested product.ProductType as the Product Type parameter, Requested product.Rate as the Rate parameter, Requested product.Term as the Term parameter, and Requested product.Amount as the Amount parameter.

*Routing*

Question: How this should this applicant be routed given all available data?

Allowed Answers: A value from the explicit list "Decline", "Refer for Adjudication", "Accept without Review"

Description: The *Routing* decision logic invokes the Routing rules business knowledge model, passing Bureau data. Bankrupt as the Bankrupt parameter, Bureau data. Credit Score as the Credit Score parameter, the output of the Post- bureau risk category decision as the Post-Bureau Risk Category parameter, and the output of the Post-bureau affordability decision as the Post-Bureau Affordability parameter. Note that if Bureau data is null (due to the THROUGH strategy bypassing the Collect bureau data task) the Bankrupt and Credit Score parameters will be null.

*Strategy*

Question: What is the appropriate handling strategy for this application? +
Allowed Answers: A value from the explicit list "Decline","Bureau”,“Through" +
Description: The *Strategy* decision logic defines a complete, unique-hit decision table deriving Strategy from Eligibility and Bureau call type.

====== Knowledge Sources

The DRG contains the following Knowledge Sources:

*Affordability spreadsheet*

Description: Internal spreadsheet showing the relationship of income, payments, expenses, risk and affordability.

Type: Policy

*Credit officer experience*

Description: The collected wisdom of the credit officers as collected in their best practice wiki.

Type: Expertise

*Credit risk analytics*

Description: Credit risk scorecard analysis to determine the relevant factors for application risk scoring

Type: Analytic Insight

*Product specification*

Description: Definitions of the products, their cost structure and eligibility criteria.

Type: Policy

*Risk management strategy*

Description: Overall risk management approach for the financial institution including its approach to application risk, credit contingencies and credit risk scoring.

Type: Policy

====== Input Data

The DRG contains the following Input Data:

*Applicant data*

Description: Information about the applicant including personal information, marital status and household income/expenses.

*Bureau data*

Description: External credit score and bankruptcy information provided by a bureau.

*Loan default data*

Description: Information about historical loan defaults.

*Requested product*

Description: Details of the loan the applicant has applied for.

*Supporting documents*

Description: Documents associated with a loan that are not processed electronically but are available for manual adjudication.

====== Business Knowledge Models

Finally, the DRG contains the following Business Knowledge Models:

*Eligibility rules*

Description: The Eligibility rules decision logic defines a complete, priority-ordered single hit decision table deriving Eligibility from Pre-Bureau Risk Category, Pre-Bureau Affordability and Age.

*Routing rules*

Description: The Routing Rules decision logic defines a complete, priority-ordered single hit decision table deriving Routing from Post-Bureau Risk Category, Post-Bureau Affordability, Bankrupt and Credit Score.

*Bureau call type table*

Description: The Bureau call type table decision logic defines a complete, unique-hit decision table deriving Bureau Call Type from Pre-Bureau Risk Category.

*Credit contingency factor table*

Description: The Credit contingency factor table decision logic defines a complete, unique-hit decision table deriving Credit contingency factor from Risk Category.

*Affordability calculation*

Description: The Affordability calculation decision logic defines a boxed function deriving Affordability from Monthly Income, Monthly Repayments, Monthly Expenses and Required Monthly Installment. One step in this calculation derives Credit contingency factor by invoking the Credit contingency factor table business.

*Pre-bureau risk category table*

Description: The Pre-bureau risk category table decision logic defines a complete, unique-hit decision table deriving Pre- bureau risk category from Existing Customer and Application Risk Score.

*Post-bureau risk category table*

Description: The Post-bureau risk category table decision logic defines a complete, unique-hit decision table deriving Post-Bureau Risk Category from Existing Customer, Application Risk Score and Credit Score.

*Application risk score model*

Description: The Application risk score model decision logic defines a complete, no-order multiple-hit table with aggregation, deriving Application risk score from Age, Marital Status and Employment Status, as the sum of the Partial scores of all matching rows (this is therefore a predictive scorecard represented as a decision table).

*Installment calculation*

Description: The Installment calculation decision logic defines a boxed function deriving monthly installment from Product Type, Rate, Term and Amount.

*Financial.PMT*

Description: Standard calculation of monthly installment from Rate, Term and Amount.

===== Business Context

In addition to the information represented in the DRD, the business context of the decision-making can be specified. The Performance Indicators used to track the effectiveness of decision-making, Objectives the organization seeks to meet through its decision-making approach, and the Organizational Units that make decisions or own the decision-making approach may all be specified. Decisions are cross-referenced to the performance indicators and objectives they impact and to the organizational units that either make the decision or own the definition of how the decision should be made.

*Performance indicators*

[width="100%",cols="32%,68%",options="header",]
|===
a|
____
Monthly bureau costs
____

|The total cost charged by the bureau for all Bureau Data requested while originating Loans in a calendar month.
a|
____
Monthly loan accept rate
____

a|
____
The percentage of loans accepted in a calendar month.
____

a|
____
Monthly auto-adjudication rate
____

|The percentage of loans that did not require a credit officer to review the case in a calendar month.
a|
____
Monthly value of loans written
____

|The total value of Loans written in a calendar month
a|
____
Auto adjudication rate 90%
____

|By end of the current year, have an auto-adjudication rate of at least 90 percent
|===

Decisions are mapped to the Performance Indicators and Goals that they impact as follows:

[width="100%",cols="26%,14%,14%,16%,16%,14%",options="header",]
|===
| |*Monthly Loan Accept Rate* a|
*Monthly Value*

*of Loans WrittenCosts*

|*Monthly Bureau* |*Auto-adjudication rate 90%* |*Monthly Auto- adjudication Rate*
a|
____
*Adjudication*
____

|Yes |Yes | | |
a|
____
*Application risk score*
____

| | |Yes | |
a|
____
*Bureau Call Type*
____

| | |Yes | |
a|
____
*Routing*
____

|Yes |Yes | |Yes |Yes
a|
____
*Strategy*
____

|Yes |Yes | |Yes |Yes
|===

*Organizations*

[width="100%",cols="23%,77%",options="header",]
|===
a|
____
Credit officers
____

a|
____
Individuals in the Retail Banking Organization responsible for manual adjudication of loans.
____

a|
____
Product management
____

|Organization responsible for defining loan and other banking products, how those products are priced, sold and tracked for profitability.
a|
____
Credit risk analytics group
____

|Organization responsible for credit risk models and the use of data to predict credit risk for customers and loan applicants.
a|
____
Retail banking
____

a|
____
Overall Organization focused on banking products for consumers.
____

a|
____
Credit risk
____

|Organization within the bank responsible for defining credit risk strategies and policies and providing tools for managing against these.
|===

Credit officers are likely to be part of the Retail Banking organization, Credit risk analytic and Risk management are part of the Credit risk organization, although these relationships are not managed in DMN.

These organizations own decisions, make decisions and own knowledge sources as follows:

[width="100%",cols="24%,23%,24%,29%",options="header",]
|===
| |*Owns Decisions* |*Makes Decisions* |*Knowledge Sources*
a|
____
*Credit officers*
____

| |Adjudication a|
____
Credit officer experience
____

a|
____
*Credit risk analytics group*
____

|Application risk score | a|
____
Credit risk analytics
____

a|
____
*Credit risk*
____

a|
Adjudication

Bureau call type

Eligibility

Pre-bureau risk category Post-bureau risk category Routing

Strategy

| a|
____
Risk management strategy
____

|===

===== Decision Services

The two decision services required by the business process model are defined against the decision model. The *Bureau Strategy Decision Service*, called by the *Decide bureau strategy* task, has output decisions \{Bureau call type, Strategy}, and is shown in Figure 11‑7. The *Routing Decision Service*, called by the *Decide routing* task, has output decisions \{Routing}, and is shown in Figure 11‑8.

image:extracted-media/media/image110.png[image,width=484,height=595]

[#_Toc87278874 .anchor]##*Figure 11‑7: Bureau Strategy Decision Service*

image:extracted-media/media/image111.png[image,width=448,height=442]

[#_Toc87278875 .anchor]##*Figure 11‑8: Routing Decision Service*

==== The decision logic level

The DRG in Figure 11‑2 is defined in more detail in the following specifications of the value expressions associated with decisions and business knowledge models:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

The *Strategy* decision logic (Figure 11‑9) defines a complete, unique-hit decision table deriving Strategy from Eligibility and Bureau call type.The *Bureau call type* decision logic (shown as a boxed invocation in Figure 11‑10) invokes the Bureau call type table, passing the output of the Pre-bureau risk category decision as the Pre-Bureau Risk Category parameter.The *Bureau call type table* decision logic (Figure 11‑11) defines a complete, unique-hit decision table deriving Bureau Call Type from Pre-Bureau Risk Category.The *Eligibility* decision logic (shown as a boxed invocation in Figure 11‑12) invokes the Eligibility rules business knowledge model, passing Applicant data. Age as the Age parameter, the output of the Pre-bureau risk category decision as the Pre-Bureau Risk Category parameter, and the output of the Pre-bureau affordability decision as the Pre-Bureau Affordability parameter.The *Eligibility rules* decision logic (Figure 11‑13) defines a complete, priority-ordered single hit decision table deriving Eligibility from Pre-Bureau Risk Category, Pre-Bureau Affordability and Age.The *Pre-bureau risk category* decision logic (shown as a boxed invocation in Figure 11‑14) invokes the Pre- bureau risk category table business knowledge model, passing Applicant data. ExistingCustomer as the Existing Customer parameter and the output of the Application risk score decision as the Application Risk Score parameter.The *Pre-bureau risk category table* decision logic (Figure 11‑15) defines a complete, unique-hit decision table deriving Pre-Bureau Risk Category from Existing Customer and Application Risk Score.The *Application risk score* decision logic (shown as a boxed invocation in Figure 11‑16) invokes theApplication risk score model business knowledge model, passing Applicant data. Age as the Age parameter, Applicant data. MaritalStatus as the Marital Status parameter and Applicant data. EmploymentStatus as the Employment Status parameter.

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

____
The *Application Risk Score Model* decision logic (Figure 11‑17) defines a complete, no-order multiple-hit table with aggregation, deriving Application risk score from Age, Marital Status and Employment Status, as the sum of the Partial scores of all matching rows (this is therefore a predictive scorecard represented as a decision table).The *Routing* decision logic (shown as a boxed invocation in Figure 11‑18) invokes the Routing rules business knowledge model, passing Bureau data. Bankrupt as the Bankrupt parameter, Bureau data. CreditScore as the Credit Score parameter, the output of the Post-bureau risk category decision as the Post-Bureau Risk Category parameter, and the output of the Post-bureau affordability decision as the Post-Bureau Affordability parameter. Note that if Bureau data is null (due to the THROUGH strategy bypassing the Collect bureau data task) the Bankrupt and Credit Score parameters will be null.The *Routing rules* decision logic (Figure 11‑19) defines a complete, priority-ordered single hit decision table deriving Routing from Post-Bureau Risk Category, Post-Bureau Affordability, Bankrupt and Credit Score.The *Post-bureau risk category* decision logic (shown as a boxed invocation in Figure 11‑20) invokes the Post- bureau risk category business knowledge model, passing Applicant data . ExistingCustomer as the Existing Customer parameter, Bureau data . CreditScore as the Credit Score parameter, and the output of the Application risk score decision as the Application Risk Score parameter. Note that if Bureau data is null (due to the THROUGH strategy bypassing the Collect bureau data task) the Credit Score parameter will be null.The *Post-bureau risk category table* decision logic (Figure 11‑21) defines a complete, unique-hit decision table deriving Post-Bureau Risk Category from Existing Customer, Application Risk Score and Credit Score.The *Pre-bureau affordability* decision logic (shown as a boxed invocation in Figure 11‑22) invokes the Affordability calculation business knowledge model, passing Applicant data . Monthly . Income as the Monthly Income parameter, Applicant data . Monthly . Repayments as the Monthly Repayments parameter, Applicant data . Monthly . Expenses as the Monthly Expenses parameter, the output of the Pre-bureau risk category decision as the Risk Category parameter, and the output of the Required monthly installment decision as the Required Monthly Installment parameter.The *Post-bureau affordability* decision logic (shown as a boxed invocation in Figure 11‑23) invokes the Affordability calculation business knowledge model, passing Applicant data . Monthly . Income as the Monthly Income parameter, Applicant data . Monthly . Repayments as the Monthly Repayments parameter, Applicant data . Monthly . Expenses as the Monthly Expenses parameter, the output of the Post-bureau risk category decision as the Risk Category parameter, and the output of the Required monthly installment decision as the Required Monthly Installment parameter.The *Affordability calculation* decision logic (Figure 11‑24) defines a boxed function deriving Affordability from Monthly Income, Monthly Repayments, Monthly Expenses and Required Monthly Installment. One step in this calculation derives Credit contingency factor by invoking the Credit contingency factor table business knowledge model, passing the output of the Risk category decision as the Risk Category parameter.The *Credit contingency factor table* decision logic (Figure 11‑25) defines a complete, unique-hit decision table deriving Credit contingency factor from Risk Category.The *Required monthly installment* decision logic (shown as a boxed invocation in Figure 11‑26) invokes the Installment calculation business knowledge model, passing Requested product . ProductType as the Product Type parameter, Requested product . Rate as the Rate parameter, Requested product . Term as the Term parameter, and Requested product . Amount as the Amount parameter.The *Installment calculation* decision logic (Figure 11‑27) defines a boxed function deriving monthly installment from Product Type, Rate, Term and Amount. One step in this calculation invokes an external function PMT, imported from a DMN XML file as “Financial”. Figure 11‑28 shows the decision logic of PMT function.
____

image:extracted-media/media/image112.png[image,width=515,height=292]

[#_Toc87278876 .anchor]##*Figure 11‑9: Strategy decision logic*

image:extracted-media/media/image113.png[image,width=460,height=144]

[#_Toc87278877 .anchor]##*Figure 11‑10: Bureau call type decision logic*

image:extracted-media/media/image114.png[image,width=456,height=278]

[#_Toc87278878 .anchor]##*Figure 11‑11: Bureau call type table decision logic*

image:extracted-media/media/image115.png[image,width=434,height=228]

[#_Toc87278879 .anchor]##*Figure 11‑12: Eligibility decision logic*

image:extracted-media/media/image116.png[image,width=581,height=280]

[#_Toc87278880 .anchor]##*Figure 11‑13: Eligibility rules decision logic*

image:extracted-media/media/image117.png[image,width=436,height=181]

[#_Toc87278881 .anchor]##*Figure 11‑14: Pre-bureau risk category decision logic*

image:extracted-media/media/image118.png[image,width=554,height=482]

[#_Toc87278882 .anchor]##*Figure 11‑15: Pre-bureau risk category table decision logic*

image:extracted-media/media/image119.png[image,width=467,height=244]

[#_Toc87278883 .anchor]##*Figure 11‑16: Application risk score decision logic*

image:extracted-media/media/image120.png[image,width=640,height=710]

[#_Toc87278884 .anchor]##*Figure 11‑17: Application risk score model decision logic*

image:extracted-media/media/image121.png[image,width=461,height=294]

[#_Toc87278885 .anchor]##*Figure 11‑18: Routing decision logic*

image:extracted-media/media/image122.png[image,width=612,height=283]

[#_Toc87278886 .anchor]##*Figure 11‑19: Routing rules decision logic*

image:extracted-media/media/image123.png[image,width=465,height=243]

[#_Toc87278887 .anchor]##*Figure 11‑20: Post-bureau risk category decision logic*

image:extracted-media/media/image124.png[image,width=650,height=754]

[#_Toc87278888 .anchor]##*Figure 11‑21: Post-bureau risk category table decision logic*

image:extracted-media/media/image125.png[image,width=475,height=340]

[#_Toc87278889 .anchor]##*Figure 11‑22: Pre-bureau affordability decision logic*

image:extracted-media/media/image126.png[image,width=476,height=340]

[#_Toc87278890 .anchor]##*Figure 11‑23: Post-bureau affordability decision logic*

image:extracted-media/media/image127.png[image,width=650,height=322]

[#_Toc87278891 .anchor]##*Figure 11‑24: Affordability calculation decision logic*

image:extracted-media/media/image128.png[image,width=532,height=294]

[#_Toc87278892 .anchor]##*Figure 11‑25: Credit contingency factor table decision logic*

image:extracted-media/media/image129.png[image,width=460,height=292]

[#_Toc87278893 .anchor]##*Figure 11‑26: Required monthly installment decision logic*

image:extracted-media/media/image130.png[image,width=503,height=320]

[#_Toc87278894 .anchor]##*Figure 11‑27: Installment calculation decision logic*

image:extracted-media/media/image131.png[image,width=462,height=164]

[#_Toc87278895 .anchor]##*Figure 11‑28: Financial.PMT decision logic*

====  Executing the Decision Model

In order to execute a decision model (in this case, by calling two decision services), case data must be bound to the input data, much as an invocation binds arguments to function parameters. The binding of case data to input data, however, is not part of the decision model, unlike the invocation that specifies how a decision’s requirement inputs bind to the parameters of that decision’s required knowledge.

FEEL allows contexts and other expressions to be used to represent case data (see also clauses 10.3.3.3 and 10.6.1). Input data is associated with an item definition (clause 7.3.2) and the case data must have the same type and other constraints specified by the item definition. Case data must be mapped to the FEEL domain. For example, XML instance data is mapped to the FEEL domain as described in clause 10.3.3.

For convenience, we will specify case data using boxed expressions instead of XML. Figure 11‑29, Figure 11‑30 and Figure 11‑31 show boxed contexts defining case data for Applicant data, Requested product and Bureau data.

image:extracted-media/media/image132.png[image,width=363,height=389]

[#_Toc87278896 .anchor]##*Figure 11‑29: Applicant data input data sample*

image:extracted-media/media/image133.png[image,width=375,height=145]

[#_Toc87278897 .anchor]##*Figure 11‑30: Requested Product input data sample*

image:extracted-media/media/image134.png[image,width=373,height=95]

[#_Toc87278898 .anchor]##*Figure 11‑31: Bureau Data input data sample*

When the Bureau Strategy Decision Service is called with the Applicant data and Requested product case data, it returns the context shown in Figure 11‑32:

image:extracted-media/media/image135.png[image,width=373,height=46]

[#_Toc87278899 .anchor]##*Figure 11‑32: Output of the Bureau Strategy Decision Service*

When the Routing Decision Service is called with the Applicant data, Requested product and Bureau data case data, it returns the context shown in Figure 11‑33.

image:extracted-media/media/image136.png[image,width=375,height=243]

[#_Toc87278900 .anchor]##*Figure 11‑33: Output of the Routing decision Service*

===  Example 2: Ranked Loan Products

The second example considers eligibility for various mortgage loan products based on the Borrower’s income, assets, liabilities, and credit score, and ranks them based on specified sort criteria. It illustrates the wide variety of DMN expression types, including context, invocation, relation, and function definition, as well as some of the newer FEEL functions and operators, including import, service invocation, enhanced iteration, generalized unary tests, and Java binding. The logic represented here is just one of many different ways to model the scenario.

The DRD for the decision model is shown in Figure 11‑34.

image:extracted-media/media/image137.png[Diagram Description automatically generated,width=650,height=351]

[#_Toc87278901 .anchor]##*Figure 11‑34: DRD for Recommended Loan Products*

The input data elements include:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

*Credit Score*, a number from 300 to 850 inclusive**Down Payment**, a number**Property**, a structure of type _tProperty_ (Figure 11‑35)*Borrower*, a structure of type _tBorrower_ (Figure 11‑37), and**Lender Ratings,** a structure of type _tLenderRatings_ (Figure 11‑38) +
The boxed expression format for the datatype definitions in Figure 11‑35, Figure 11‑37, and 1Figure 11‑38 is non- normative. Figure 11‑35, for example, is a visualization of the XML representation of Figure 11‑36.

image:extracted-media/media/image139.png[image,width=468,height=310]

[#_Toc87278902 .anchor]##*Figure 11‑35: Type tProperty (non-normative representation)*

image:extracted-media/media/image140.wmf[image,width=650,height=469]

[#_Toc87278903 .anchor]##*Figure 11‑36: Type tProperty (XML representation)*

image:extracted-media/media/image141.png[image,width=650,height=447]

[#_Toc87278904 .anchor]##*Figure 11‑37: Type tBorrower*

image:extracted-media/media/image142.png[image,width=364,height=75]

[#_Toc87278905 .anchor]##*Figure 11‑38: Type tLenderRatings, a collection of +
tLenderRating*

In addition, the zero-input decision Loan Products, a structure of type tLoanProducts, is a relation (Figure 11‑39). Cells in a relation are FEEL expressions but often contain literal values as a way to embed static data tables inside a decision model. In this case it represents a list of mortgage loan products available from various lenders, specifying the best interest rate offered to lowest risk borrowers and loan origination costs specified as “points”, a percentage of the loan amount, and “fees”, a constant value.

image:extracted-media/media/image143.png[image,width=650,height=310]

[#_Toc87278906 .anchor]##*Figure 11‑39: Loan Products*

image:extracted-media/media/image144.png[image,width=650,height=276]

[#_Toc87278907 .anchor]##*Figure 11‑40: Type tLoanProducts, a collection of tLoanProduct*

The *Recommended Loan Products* model imports another decision model *Loan Info*, with the DRD shown in Figure 11‑41, defining a decision service *Loan Info Service*. Imported models are assigned a modeler-chosen prefix, here _Services_, to distinguish its namespace from that of the importing model. In the importing DRD (Figure 11‑34), the imported service *Services.Loan Info Service* is depicted with the non-normative lock icon, indicating that its logic may not be edited within the importing model. The service parameters are the input data shown in Figure 11‑41: *Credit Score, Property, Loan Product,* and *Down Payment*, with types identical to those defined in the importing model.

*Services*.*Loan Info Service* populates a row of the decision *Loan Info Table*, a collection of type *tLoanInfoRow* (Figure 11‑39), calculating the details of the selected loan product for the given property value (purchase price) and down payment.

image:extracted-media/media/image145.png[image,width=629,height=309]

[#_Toc87278908 .anchor]##*Figure 11‑41: DRD of imported Loan Info Service*

image:extracted-media/media/image146.png[image,width=625,height=497]

[#_Toc87278909 .anchor]##*Figure 11‑42: Type tLoanInfoTable, a collection of tLoanInfoRow*

image:extracted-media/media/image147.png[image,width=650,height=734]

[#_Toc87278910 .anchor]##*Figure 11‑43: Loan Data*

Within the service, *Loan Data* performs calculations used in the presentation decision, *Loan Info*. It is modeled as a context with no final result box, meaning every context entry creates a component of the result. (The text “Result” in the final result box is a tool artifact not in the spec, overwritten by a literal expression if the context has a final result box value.) A few things to note about the logic shown in Figure 11‑43:

* {blank}
* {blank}
* {blank}
* {blank}
* {blank}

FEEL arithmetic can create values with many digits following the decimal point. The function decimal(x, 2) rounds value x to 2 decimal places.Context entry Interest Rate Percent invokes the BKM *Rate Adjustment* (Figure 11‑44), a function of the borrower’s *Credit Score* and the loan-to-value ratio *LTV*. This increments the Loan Product’s interest rate by a small amount based on the loan risk.*Credit Score* values less than 620 are ineligible for a loan. In that case, *Rate Adjustment* could return null, but then all expressions using *Rate Adjustment* would also be null, complicating the logic. To simplify the downstream logic, it is better in this case to return a number, since ultimately the loan will not be approved if the *Credit Score* is less than 620.For loans with variable interest rate, the debt-to-income ratio uses a _Qualifying Payment_ amount based on an interest rate 2 percent higher than the rate used in the initial _Monthly Payment_._Monthly Payment_ and _Qualifying Payment_ are modeled as boxed invocations of the BKM *payment*, the amortization formula (Figure 11‑45). The parameters of payment are the loan amount _p_, the interest rate _r_, and the term in months, _n_.The decision *Loan Info* (Figure 11‑46), the output of *Services.Loan Info*, returns a row of *Loan Info Table*. It is also modeled as a context with no final result box, meaning each context entry represents a column of *Loan Info Table.*

image:extracted-media/media/image148.png[image,width=385,height=736]

[#_Toc87278911 .anchor]##*Figure 11‑44: BKM Rate Adjustment*

image:extracted-media/media/image149.png[image,width=288,height=149]

[#_Toc87278912 .anchor]##*Figure 11‑45: BKM payment*

image:extracted-media/media/image150.png[image,width=456,height=748]

[#_Toc87278913 .anchor]##*Figure 11‑46: Loan Info*

In the importing model, the decision *Loan Info Table* (Figure 11‑47) iterates invocation of *Loan Info* over rows of *Loan Products.* It is modeled as a literal expression using the FEEL _for. . in. .return_ operator. Here _x_ is a range variable meaning one item in a list – one *Loan Product* in *Loan Products* – producing an argument of the function call.

image:extracted-media/media/image151.png[image,width=596,height=120]

[#_Toc87278914 .anchor]##*Figure 11‑47: Loan Info Table*

*Loan Info Table* now provides values for each *Loan Product* used to determine whether the Borrower’s income, assets, liabilities, and credit score qualify for loan approval.

At the heart of the logic for determining eligibility for a particular loan is the BKM *Min Credit Score* (Figure 11‑48), a decision table that calculates the minimum credit score required based on three parameters: _DTI_, the borrower’s debt-to­income ratio; _LTV,_ the loan-to-value ratio; and _Reserves_, a measure of the Borrower’s liquid assets after closing in units of monthly _Housing Costs_. The table is modeled as hit policy _Collect_ with aggregation _Minimum_, meaning when multiple rules match the lowest value output is returned. When _DTI_ is greater than 95%, the loan is automatically ineligible. In that case, no rule matches and *Min Credit Score* returns the value null. Downstream logic referencing this variable must account for the possibility of null value.

image:extracted-media/media/image152.png[image,width=399,height=571]

[#_Toc87278915 .anchor]##*Figure 11‑48: Min Credit Score*

*Min Credit Score* is called by the BKM *Eligibility,* which in turn calls the BKM *Eligibility Parameters* (Figure 11‑49). *Eligibility Parameters* calculates the two key parameters of *Min Credit Score*, the debt-to-income ratio _DTI Pct_, and the liquid assets after closing, called _Reserves_. Note that context entry _Housing Expense_, which sums the loan payment, tax and insurance payments, and homeowner association/condo fee, must account for the possibility that the latter is left blank, i.e., null, in the input data *Property*, since adding null to a number gives null. To prevent this, instead of the + operator we use the _sum()_ function on a list filtered by the condition _item != null._ We use this technique also on context entry _Income_.

image:extracted-media/media/image153.png[image,width=650,height=552]

[#_Toc87278916 .anchor]##*Figure 11‑49: Eligibility Parameters*

For legibility, the BKM *Eligibility* is shown in two pieces (Figure 11‑50 and Figure 11‑51). This BKM creates a row of type _tTableRow_ for the decision *Eligibility Table*. It is modeled as a context, where the first four context entries (Figure 11‑50) call BKMs to determine values to populate the _Table Row_ components.

* {blank}
* {blank}
* {blank}

_Params_ calls the BKM *Eligibility Parameters* for a given *Loan Product*._Required Credit Score_ uses Params to call the BKM *Min Credit Score*, returning the minimum credit score required by that *Loan Product* for the Borrower to be eligible._Eligible_ is a Boolean comparing the Borrower’s credit score to *Min Credit Score.* _Recommendation_ uses the input data *Lender Ratings* in combination with *Eligible* to return a recommendation value for the *Loan Product*. _Recommendation_ illustrates an alternative decision table syntax introduced in DMN 1.2 called generalized unary test. With generalized unary tests, a decision table input entry may be any FEEL expression, substituting ? for the input expression. For example, in the first column of this decision table the rules filter the *Lender Ratings* table for an item with _Lender Name_ matching that of the *Loan Product* and _Customer Rating_ in a specified range, returning true if that filter returns any values.

image:extracted-media/media/image154.png[image,width=650,height=489]

[#_Toc87278917 .anchor]##*Figure 11‑50: Eligibility (top)*

The rest of *Eligibility* is shown in Figure 11‑51.

* {blank}
* {blank}

_Table Row_ is a nested context with no final result box value. Each context entry represents a column in the row.The DMN spec allows the final result box to be a context, but in this example, we use a context entry to create the result value, and return it in the result box. Here context entry _Table Row_ creates the row structure, and the final result box simply selects this context entry.

image:extracted-media/media/image155.png[image,width=650,height=528]

[#_Toc87278918 .anchor]##*Figure 11‑51: Eligibility (bottom)*

The decision *Eligibility Table* (Figure 11‑52) uses an alternative form of the _for. .in..return_ operator to iterate over an index rather than iterate over list item values. This alterative format allows the returned expression to involve corresponding items in multiple lists, in this case *Loan Products* and *Loan Info Table*.

image:extracted-media/media/image156.png[image,width=650,height=118]

[#_Toc87278919 .anchor]##*Figure 11‑52: Eligibility Table*

The top-level decision *Recommended Loan Products* (Figure 11‑53) first sorts *Eligibility Table* based on _Recommendation_ and _Monthly Payment_, and then calls a Java method to format number values as strings for final presentation.

image:extracted-media/media/image157.png[image,width=629,height=322]

[#_Toc87278920 .anchor]##*Figure 11‑53: Recommended Loan Products*

* {blank}
* {blank}

____
The first context entry _precedes_ is a function definition used by the FEEL _sort()_ function. The second parameter of _sort()_, called the _precedes function_, is a Boolean function with two arguments representing list items. It returns true if the first argument precedes the second in the sorted list.The context entry _Sorted Table_ performs the sort. With simple sort criteria, the precedes function is typically defined inline as an anonymous function using the keyword _function_, as insort(myTable, function(x, y) x.Amount < y.Amount)

which sorts the rows of _myTable_ in ascending order of the column _Amount_. However, in *Recommended Loan Products* we instead use a named precedes function, the context entry _precedes_. In that case, the name of the function provides the second argument of _sort()._
____

* {blank}

The final result box iterates a call to the BKM *Format Row*, which executes a static Java method to format number values in _Sorted Table_ as strings with a currency symbol and two digits following the decimal point.*Format Row* (Figure 11‑54) operates on a single row of _Sorted Table_. It is modeled as a context.

* {blank}
* {blank}
* {blank}

The first context entry _string format_ is a Java function definition, indicated by the code J. DMN specifies such a function definition as a context with two context entries, _class_ and _method signature_. This example applies a mask string to a number, returning a formatted number string.The second context entry _formatted row_ generates a row of *Recommended Loan Products* in final presentation format, calling _string format_ to format amount and percent values.The final result box returns _formatted row_.

image:extracted-media/media/image158.png[image,width=650,height=602]

[#_Toc87278921 .anchor]##*Figure 11‑54: Format Row*

Figure 11‑55 shows the output of *Recommended Loan Products* based on the Test Case input data of Figure 11‑56.

image:extracted-media/media/image159.png[image,width=531,height=526]

[#_Toc87278922 .anchor]##*Figure 11‑55: Test Case output of Recommended Loan Products*

[width="100%",cols="39%,61%",options="header",]
|===
|image:extracted-media/media/image160.png[image,width=190,height=793] a|
image:extracted-media/media/image161.png[image,width=385,height=270]

image:extracted-media/media/image162.png[image,width=386,height=358]

|===

[#_Toc87278923 .anchor]##*Figure 11‑56: Test Case Input Data (partial)*

== 

===  Exchange formats Interchanging Incomplete Models

It is common for *DMN* models to be interchanged before they are complete. This occurs frequently when doing iterative modeling, where one user (such as a knowledge source expert or business user) first defines a high-level model and then passes it on to another person to complete or refine the model.

Such "incomplete" models are ones in which not all of the mandatory model attributes have been filled in yet or the cardinality of the lower bound of attributes and associations has not been satisfied.

XMI allows for the interchange of such incomplete models. In *DMN*, we extend this capability to interchange of XML files based on the *DMN* XML-Schema. In such XML files, implementers are expected to support this interchange by:

* {blank}
* {blank}

=== Disregarding missing attributes that are marked as "required" in the *DMN* XML-Schema.Reducing the lower bound of elements with "minOccurs" greater than 0. +
Machine Readable Files

All machine-readable files, including XSD, XMI and XML files, can be found in OMG Document dtc/1 5-11-12, which is a flat zip file.

* {blank}
* {blank}
* {blank}

=== For the *DMN* XMI Model, the main file is DMN.xmi.For the *DMN* XSD Interchange (supporting Conformance Levels 1, 2 and 3), the main file is DMN.xsd.A serialization of the example in clause 11 is provided in ch11example. +
XSD

==== Document Structure

A domain-specific set of model elements is interchanged in one or more *DMN* files. The root element of each file SHALL be <DMN**:** Definitions>. The set of files SHALL be self-contained, i.e., all definitions that are used in a file SHALL be imported directly or indirectly using the <DMN**:** Import> element.

Each file SHALL declare a “name space” that MAY differ between multiple files of one model.

*DMN* files MAY import non-*DMN* files (such as XSDs and PMMLs) if the contained elements use external definitions.

====  References within the DMN XSD

Many *DMN* elements that may need to be referenced contain IDs and within the *BPMN* XSD, references to elements are expressed via these IDs. The XSD IDREF type is the traditional mechanism for referencing by IDs, however it can only reference an element within the same file. *DMN* elements of type DMNElementReference support referencing by ID, across files, by utilizing an href attribute whose value must be a valid URI reference [RFC 3986] where the path components may be absolute or relative, the reference has no query component, and the fragment consists of the value of the id of the referenced *DMN* element.

For example, consider the following Decision:

<decision name="Pre-Bureau Risk Category" id="prebureauriskDec01">...</decision>

When this Decision is referenced, e.g. by an InformationRequirement in a Decision that is defined in another file, the reference could take the following form:

<requiredDecision +
href=”http: //http://www.example.org/Definitions01[[.underline]#www. example. org/Definitions01#] . xml#prebureauriskDec01”/>where “http: //http://www.example.org/Definitions01[[.underline]#www. example. org/Definitions01#] . xml” is an URI reference to the XML document in which the “Pre-Bureau Risk Category” Decision is defined (e.g. the value of the locationURI attribute in the corresponding Import element), and “prebureauriskDec01” is the value of the id attribute for the Decision.

If the path component in the URI reference is relative, the base URI against which the relative reference is applied is determined as specified in [RFC 3986]. According to that specification, “_if no base URI is embedded and the representation is not encapsulated within some other entity, then, if a URI was used to retrieve the representation, that URI shall be considered the base URI_” ([RFC 3986], section 5.1.3). That is, if the reference is not in the scope of an xml:base attribute [XBASE], a value of the href attribute that contains only a fragment and no path component references a *DMN* element that is defined in the same instance of XML file as the referencing element. In the example below, assuming that the requiredDecision element is not in the scope of an xml:base attribute, the *DMN* element whose id is “prebureauriskDec01” must be defined in the same XML document:

<requiredDecision href=”#prebureauriskDec01” />

Notice that the *BPMN* processes and tasks that use a decision are referenced using the href attribute as well: indeed, it is compatible with the system to reference external Process and Task instances in *BPMN 2.0* Definitions, which is also based on IDs.

Attribute typeRef references ItemDefinitions and built-in types by name not ID. In order to support imported types, typeRef uses the namespace-qualified name syntax [qualifer].[local-name], where qualifier is specified by the name attribute of the Import element for the imported type. If the referenced type is not imported, the prefix SHALL be omitted.

== 

===  DMN Diagram Interchange (DMN DI)Scope

This chapter specifies the meta-model and schema for *DMN* Diagram Interchange (*DMN DI*). The *DMN DI* is meant to facilitate the interchange of *DMN* diagrams between tools rather than being used for internal diagram representation by the tools. The simplest interchange approach to ensure the unambiguous rendering of a *DMN* diagram was chosen for *DMN DI*. As such, *DMN DI* does not aim to preserve or interchange any “tool smarts” between the source and target tools (e.g., layout smarts, efficient styling, etc.).

*DMN DI* does not ascertain that the *DMN* diagram is syntactically or semantically correct.

This version of DMN DI focuses on the interchange of Decision Requirements Diagrams (DRDs). Diagram Interchange for boxed expressions and decision tables might be added in future versions.

===  Diagram Definition and Interchange

The *DMN DI* meta-model, similar to the DMN abstract syntax meta-model, is defined as a MOF-based meta-model. As such, its instances can be serialized and interchanged using XMI. DMN DI is also defined by an XML schema. Thus, its instances can also be serialized and interchanged using XML.

Both, DMN DI meta-model and schema are harmonized with the OMG Diagram Definition (DD) standard version 1.1. The referenced DD contains two main parts: the Diagram Commons (DC) and the Diagram Interchange (DI). The DC defines common types like bounds and points, while the DI provides a framework for defining domain-specific diagram models. As a domain-specific DI, DMN DI defines a few new meta-model classes that derive from the abstract classes from DI.

The focus of DMN DI is the interchange of laid out shapes and edges that constitute a *DMN* diagram. Each shape and edge reference a particular *DMN* model element. The referenced *DMN* model elements are all part of the actual *DMN* model. As such, DMN DI is meant to only contain information that is neither present nor derivable, from the *DMN* model whenever possible. Simply put, to render a *DMN* diagram both the DMN DI instance(s) and the referenced *DMN* model are REQUIRED.

From the DMN DI perspective, a DMN diagram is a particular snapshot of a *DMN* model at a certain point in time. Multiple *DMN* diagrams can be exchanged referencing model elements from the same *DMN* model. Each diagram may provide an incomplete or partial depiction of the content of the *DMN* model. As described in clause 12, a *DMN* model package consists of one or more files. Each file may contain any number of *DMN* diagrams. The exporting tool is free to decide how many diagrams are exported and the importing tool is free to decide if and how to present the contained diagrams to the user.

===  How to read this chapter

Clause 13.4 describes in details the meta-model used to keep the layout and the look of *DMN* Diagrams. Clause 13.5 presents in tables a library of the *DMN* element depictions and an unambiguous resolution between a referenced *DMN* model element and its depiction.

===  DMN Diagram Interchange Meta-Model

==== Overview

The DMN DI is an instance of the OMG DI meta-model. The basic concept of DMN DI, as with DI in general, is that serializing a diagram [DMNDiagram] for interchange requires the specification of a collection of shapes [DMNShape] and edges [DMNEdge].

The DMN DI classes only define the visual properties used for depiction. All other properties that are REQUIRED for the unambiguous depiction of the *DMN* element are derived from the referenced *DMN* element [dmnElementRef].

*DMN* diagrams may be an incomplete or partial depiction of the content of the *DMN* model. Some *DMN* elements from a *DMN* model may not be present in any of the diagram instances being interchanged.

DMN DI does not directly provide for any containment concept. The DMNDiagram is an ordered collection of mixed DMNShape(s) and DMNEdge(s). The order of the DMNShape(s) and DMNEdge(s) inside a DMNDiagram determines their Z-order (i.e., what is in front of what). DMNShape(s) and DMNEdge(s) that are meant to be depicted “on top” of other DMNShape(s) and DMNEdge(s) MUST appear after them in the DMNDiagram. Thus, the exporting tool MUST order all DMNShape(s) and DMNEdge(s) such that the desired depiction can be rendered.Measurement UnitAs per OMG DD, all coordinates and lengths defined by DMN DI are assumed to be in user units, except when specified otherwise. A user unit is a value in the user coordinate system, which initially (before any transformation is applied) aligns with the device’s coordinate system (for example, a pixel grid of a display). A user unit, therefore, represents a logical rather than physical measurement unit. Since some applications might specify a physical dimension for a diagram as well (mainly for printing purposes), a mapping from a user unit to a physical unit can be specified as a diagram’s resolution. Inch is chosen in this specification to avoid variability but tools can easily convert from/to other preferred physical units. Resolution specifies how many user units fit within one physical unit (for example, a resolution of 300 specifies that 300 user units fit within 1 inch on the device).

====  DMNDI [Class]

image:extracted-media/media/image163.wmf[image,width=379,height=253]

[#_Toc87278924 .anchor]##*Figure 13‑1: DMNDI*

The class DMNDI is a container for the shared DMNStyle and all the DMNDiagram defined in a Definitions.

[width="100%",cols="36%,64%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*styles*: DMNStyle [0..*]
____

a|
____
A list of shared DMNStyle that can be referenced by all DMNDiagram and DMNDiagramElement.
____

a|
____
*diagrams*: DMNDiagram [0..*]
____

a|
____
A list of DMNDiagram.
____

|===

==== DMNDiagram [Class]

image:extracted-media/media/image164.wmf[image,width=643,height=437]

[#_Toc87278925 .anchor]##*Figure 13‑2: DMNDiagram*

The class DMNDiagram specializes DI::Diagram. It is a kind of Diagram that represents a depiction of all or part of a *DMN* model.

DMNDiagram is the container of DMNDiagramElement (DMNShape(s) and DMNEdge(s)). DMNDiagram cannot include other DMNDiagram.

A DMNDiagram can define a DMNStyle locally and/or it can refer to a shared one defined in the DMNDI. Properties defined in the local style overrides the one in the referenced shared style. That combined style (shared and local) is the default style for all the DMNDiagramElement contained in this DMNDiagram.

The DMNDiagram class represents a two-dimensional surface with an origin of (0, 0) at the top left corner. This means that the x and y axes have increasing coordinates to the right and bottom. Only positive coordinates are allowed for diagram elements that are nested in a DMNDiagram.

The DMNDiagram has the following attributes.

[width="100%",cols="37%,63%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*name*: String
____

a|
____
The name of the diagram. Default is empty String.
____

a|
____
*documentation*: String
____

a|
____
The documentation of the diagram. Default is empty String.
____

a|
____
*resolution*: Real
____

a|
____
The resolution of the diagram expressed in user units per inch. Default is 300
____

a|
____
*diagramElements*: DMNDiagramElement [0..*]
____

a|
____
A list of DMNDiagramElement (DMNShape and DMNEdge) that are depicted in this diagram.
____

a|
____
*sharedStyle*: DMNStyle[0.. 1]
____

a|
____
A reference to a DMNStyle defined in the DMNDI that serves as the default styling of the DMNDiagramElement in this DMNDiagram.
____

a|
____
*localStyle*: DMNStyle [0..1]
____

a|
____
A DMNStyle that defines the default styling for this diagram. Properties defined in that style override the ones in the sharedStyle.
____

a|
____
*size*: DC::Dimens ion [0..1]
____

a|
____
The size of this diagram. If not specified, the DMNDiagram is unbounded.
____

|===

====  DMNDiagramElement [Class]

image:extracted-media/media/image165.wmf[image,width=611,height=302]

[#_Toc87278926 .anchor]##*Figure 13‑3: DMNDiagramElement*

The DMNDiagramElement class is contained by the DMNDiagram and is the base class for DMNShape and DMNEdge.

DMNDiagramElement inherits its styling from its parent DMNDiagram. In addition, it can refer to one of the shared DMNStyle defined in the DMNDI and/or it can define a local style. See clause 13.4.9 for more details on styling.

DMNDiagramElement MAY also contain a DMNLabel when it has a visible text label. If no DMNLabel is defined, the DMNDiagramElement should be depicted without a label.

DMNDiagramElement has the following attributes:

[width="100%",cols="37%,63%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*dmnElementRef*: DMNElement [1]
____

a|
____
A reference to the DMNElement that is being depicted.
____

a|
____
*sharedStyle*: DMNStyle [0..1]
____

a|
____
A reference to a DMNStyle defined in the DMNDI.
____

a|
____
*localStyle*: DMNStyle [0..1]
____

a|
____
A DMNStyle that defines the styling for this element.
____

a|
____
*label*: DMNLabel [0.. 1]
____

a|
____
An optional label when this DMNElement has a visible text label.
____

|===

==== DMNShape [Class]

image:extracted-media/media/image166.png[image,width=644,height=242]

[#_Toc87278927 .anchor]##*Figure 13‑4: DMNShape*

The DMNShape class specializes DI::Shape and DMNDiagramElement. It is a kind of Shape that depicts a DMNElement from the DMN model.

DMNShape represents a Decision, a Business Knowledge Model, an Input Data element, a Knowledge Source, a Decision Service or a Text Annotation that is depicted on the diagram.

DMNShape has three additional properties (isListedInputData, isCollapsed and decisionServiceDividerLine) that are used to further specify the appearance of some shapes that cannot be deduced from the DMN model.

DMNShape extends DI::Shape and DMNDiagramElement and has the following attributes:

[width="100%",cols="44%,56%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*bounds*: DC::Bounds [1]
____

a|
____
The Bounds of the shape relative to the origin of its parent DMNDiagram. The Bounds MUST be specified.
____

a|
____
*dmnElementRef*: DMNElement [1]
____

a|
____
A reference to a Decision, a Business Knowledge Model, an Input Data element, a Knowledge Source, a Decision Service, a Group or a Text Annotation MUST be specified.
____

a|
____
*isListedInputData*: Boolean [0..1]
____

a|
____
If the DMNShape depicts an Input Data element then this attribute is used to determine if the Input Data is listed on the Decision element (true) or drawn as separate notational elements in the DRD (false).
____

a|
____
*decisionServiceDividerLine*: DMNDecisionServiceDividerLine [0..1]
____

a|
____
If the DMNShape depicts a Decision Service, this attribute references a DMNDecisionServiceDividerLine which is a DI::Edge that defines s where the DMNShape is divided into two parts by a straight solid line. This can be the case when a DMNShape depicts a Decision Service, where the set of output decisions is smaller than the set of encapsulated decisions. The start and end waypoints of the decisionServiceDividerLine MUST be on the border of the DMNShape.
____

a|
____
*isCollapsed* Boolean [0..1] = false
____

a|
____
If the DMNShape depicts a DecisionService, this attribute indicates if it should be depicted expanded (false) or collapsed (true). Default is false.
____

|===

====  DMNEdge [Class]

image:extracted-media/media/image167.png[image,width=650,height=203]

[#_Toc87278928 .anchor]##*Figure 13‑5: DMNEdge*

The DMNEdge class specializes DI::Edge and DMNDiagramElement. It is a kind of Edge that can depict a relationship between two *DMN* model elements.

DMNEdge are used to depict Requirements or Associations in the *DMN* model. Since DMNDiagramElement might be depicted more than once, sourceElement and targetElement attributes allow to determine to which depiction a DMNEdge is connected. When DMNEdge has a source, its sourceModelElement MUST refer to the DMNDiagramElement it starts from. That DMNDiagramElement MUST resolved to the DMNElement that is the actual source of the Requirement or Association. For Requirement, this is the required DMNElement. When it has a target, its targetModelElement MUST refer to the DMNDiagramElement where it ends. That DMNDiagramElement MUST resolved to the DMNElement that is the actual target of the Requirement or Association. For Requirement, this is the DMNElement holding it.

DMNEdge extends DI::Edge and has the following properties:

[width="100%",cols="39%,61%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*wayPoints*: DC::Point [2..*]
____

a|
____
A list of points relative to the origin of its parent DMNDiagram that specifies the connected line segments of the edge. At least two (2) waypoints MUST be specified.
____

a|
____
*dmnElementRef*: DMNElement [1]
____

a|
____
A reference to an InformationRequirement, KnowledgeRequirement, AuthorityRequirement or Association.
____

a|
____
*sourceElement*: DMNDiagramElement[0.. 1]
____

a|
____
The actual DMNDiagramElement this DMNEdge is connecting from. MUST be specified when the DMNEdge has a source.
____

a|
____
*targetElement*: DMNDiagramElement[0.. 1]
____

a|
____
The actual DMNDiagramElement this DMNEdge is connecting to. MUST be specified when the DMNEdge has a target.
____

|===

==== DMNLabel [Class]

image:extracted-media/media/image168.png[image,width=379,height=275]

[#_Toc87278929 .anchor]##*Figure 13‑6: DMNLabel*

DMNLabel represents the depiction of some textual information about a DMN element.

A DMN label is not a top-level element but is always nested inside either a DMNShape or a DMNEdge. It does not have its own reference to a *DMN* element but rather inherits that reference from its parent DMNShape or DMNEdge. The textual information depicted by the label is derived from the name attribute of the referenced DMNElement.

DMNLabel extends DI::Shape and has the following properties:

[width="100%",cols="33%,67%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*bounds*: Bounds [0..1]
____

a|
____
The bounds of the DMNLabel. When not specified, the label is positioned at its default position as determined in clause 13.5
____

a|
____
*text*: String[0..1]
____

a|
____
An optional pretty printed text that MUST be displayed instead of the DMNElement’s name if it is present.
____

|===

==== DMNStyle [Class]

image:extracted-media/media/image169.png[image,width=635,height=453]

[#_Toc87278930 .anchor]##*Figure 13‑7: DMNStyle*

DMNStyle specializes DC::Style. It is a kind of Style that provides appearance options for a DMNDiagramElement.

DMNStyle is used to keep some non-normative visual attributes such as colors and font. DMN doesn’t give any semantic to color and font styling, but tools can decide to use them and interchange them.

DMNDiagramElement style is calculated by percolating up DMNStyle attributes defined at a different level of the hierarchy. Each attribute is considered independently (meaning that a DMNStyle attribute can be individually overloaded). The precedence rules are as follow:

* {blank}
* {blank}
* {blank}
* {blank}

The DMNStyle defined by the localStyle attribute of the DMNDiagramElementThe DMNStyle referenced by the sharedStyle attribute of the DMNDiagramElementThe DMNStyle defined by the localStyle attribute of the parent DMNDiagramThe DMNStyle referenced by the sharedStyle attribute of the parent DMNDiagram +
The default attribute value defined in *Table _100_* (DMNStyle attributes).

For example, let’s say we have the following:

* {blank}
* {blank}

DMNDiagramElement has a local DMNStyle that specifies the fillColor and strokeColorIts parent DMNDiagram defines a local DMNStyle that specifies the fillColor and fontColor

Then the resulting DMNDiagramElement should use:

* {blank}
* {blank}
* {blank}

The fillColor and strokeColor defined at the DMNDiagramElement level (as they are defined locally).The fontColor defined at the DMNDiagram level (as the fillColor was overloaded locally).All other DMNStyle attributes would have their default values. +
DMNStyle extends DC::Style and has the following properties:

[width="100%",cols="40%,60%",options="header",]
|===
a|
____
*Attribute*
____

a|
____
*Description*
____

a|
____
*id*: String [0..1]
____

a|
____
A unique id for this style so it can be referenced. Only styles defined in the DMNDI can be referenced by DMNDiagramElement and DMNDiagram.
____

a|
____
*fillColor*: DC::Color [0..1]
____

a|
____
The color use to fill the shape. Doesn’t apply to DMNEdge. Default is white.
____

a|
____
*strokeColor*: DC::Color [0..1]
____

a|
____
The color use to draw the shape borders. Default is black.
____

a|
____
*fontColor*: DC::Color [0..1]
____

a|
____
The color use to write the label. Default is black.
____

a|
____
*fontFamily*: String [0..1]
____

a|
____
A comma-separated list of Font Name that can be used to display the text. Default is Arial.
____

a|
____
*fontSize*: Real [0..1]
____

a|
____
The size in points of the font to use to display the text. Default is 8.
____

a|
____
*fontItalic*: Boolean [0..1]
____

a|
____
If the text should be displayed in Italic. Default is false.
____

a|
____
*fontBold*: Boolean [0..1]
____

a|
____
If the text should be displayed in Bold. Default is false.
____

a|
____
*fontUnderline*: Boolean [0..1]
____

a|
____
If the text should be underlined. Default is false.
____

a|
____
*fontStrikeThrough*: Boolean [0..1]
____

a|
____
If the text should be stroke through. Default is false.
____

a|
____
*labelHorizontalAlignment*: AlignmentKind [0..1]
____

a|
____
How text should be positioned horizontally within the Label bounds. Default depends of the DMNDiagramElement the label is attached to (see 13.5).
____

a|
____
*label VerticalAlignment*: AlignmentKind [0..1]
____

a|
____
How the text should be positioned vertically inside the Label bounds. Default depends of the DMNDiagramElement the label is attached to (see 13.5). Start means “top” and end means “bottom”.
____

|===

===  Notation Depiction Library and Abstract Element Resolutions

As a notation, *DMN* specifies the depiction for each of the *DMN* elements.

Serializing a *DMN* diagram for interchange requires the specification of a collection of DMNShape(s) (see 13.4.6) and DMNEdge(s) (see 13.4.7) in the DMNDiagram (see 13.4.4). The DMNShape(s) and DMNEdge(s) attributes must be populated in such a way as to allow the unambiguous rendering of the DMN diagram by the receiving party. More specifically, the DMNShape(s) and DMNEdge(s) MUST reference *DMN* model elements. If no DMNElement is referenced or if the reference is invalid, it is expected that this shape or edge should not be depicted.

When rendering a *DMN* diagram, the correct depiction of a DMNShape or DMNEdge depends mainly on the referenced *DMN* model element and its particular attributes and/or references. The purpose of this clause is to: provide a library of the *DMN* element depictions, and to provide an unambiguous resolution between the referenced *DMN* model element [DMNElement] and their depiction. Depiction resolution tables are provided below for both DMNShape (see 13.5.2) and DMNEdge (see 13.5.3).

====  Labels

Both DMNShape and DMNEdge may have labels (its name attribute) placed on the shape/edge, or above or below the shape/edge, in any direction or location, depending on the preference of the modeler or modeling tool vendor.

Labels are optional for DMNShape and DMNEdge. When there is a label, the position of the label is specified by the bounds of the DMNLabel of the DMNShape or DMNEdge. Simply put, label visibility is defined by the presence of the DMNLabel element.

The bounds of the DMNLabel are optional and always relative to the containing DMNDiagram's origin point. The depiction resolution tables provided below exemplify default label positions if no bounds are provided for the DMNLabel (for DMNShape kinds (see 13.5.2) and DMNEdge kinds (see 13.5.3)).

When the DMNLabel is contained in a DMNShape, the text to display is the name of the DMNElement.

====  DMNShape Resolution

DMNShape can be used to represent a Decision, a Business Knowledge Model, an Input Data element, a Knowledge Source, a Text Annotation, a Group and a Decision Service.

===== Decision

A Decision is represented in a DRD as a rectangle, normally drawn with solid lines. If the Listed Input Data option is exercised, all the Decisions requirements for Input Data shall be listed beneath the Decisions label and separated from it by a horizontal line. The listed Input Data names shall be clearly inside the shape of the DRD element.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*DMNElement* |*DMNShape attributes* |*Depiction*
|Decision |None |image:extracted-media/media/image170.wmf[image,width=134,height=51]
|Decision and two Input Data |Shapes of Input Data have inListedInputData=true |image:extracted-media/media/image171.wmf[image,width=122,height=80]
|===

===== Business Knowledge Model

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*DMNElement* |*DMNShape attributes* |*Depiction*
|Business Knowledge Model |None |image:extracted-media/media/image172.png[image,width=117,height=41]
|===

===== Input Data Element

An Input Data element is represented in a DRD as a shape with two parallel straight sides and two semi-circular ends, normally drawn with solid lines.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*DMNElement* |*DMNShape attributes* |*Depiction*
|Input Data |None |image:extracted-media/media/image173.png[image,width=117,height=41]
|===

===== Knowledge Source

A Knowledge Source is represented as a shape with three straight sides and one wavy one, normally drawn with solid lines.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*DMNElement* |*DMNShape attributes* |*Depiction*
|Knowledge Source |None |image:extracted-media/media/image174.wmf[image,width=108,height=67]
|===

===== Artifacts

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*DMNElement* |*DMNShape Attributes* |*Depiction*
|TextAnnotation |None |image:extracted-media/media/image175.wmf[image,width=132,height=56]
|Group |None |image:extracted-media/media/image176.wmf[image,width=156,height=91]
|===

===== Decision Service

If the set of output decisions is smaller than the set of encapsulated decisions, the Decision Service shall be divided into two parts with a straight solid line.

[width="100%",cols="34%,32%,34%",options="header",]
|===
|*DMNElement* |*DMNShape attributes* |*Depiction*
|Decision Service |None or isCollapsed=false |image:extracted-media/media/image177.wmf[image,width=211,height=109]
|Decision Service |DecisionServiceDividerLine isCollapsed=false |image:extracted-media/media/image178.wmf[image,width=188,height=87]
|Decision Service |isCollapsed=true |image:extracted-media/media/image179.wmf[image,width=128,height=56]
|===

==== DMNEdge Resolution

===== Information Requirement

[width="100%",cols="36%,64%",options="header",]
|===
|*DMNElement* |*Depiction*
|Information Requirement |image:extracted-media/media/image180.wmf[image,width=115]
|===

===== Knowledge Requirement

[width="100%",cols="36%,64%",options="header",]
|===
|*DMNElement* |*Depiction*
|Knowledge Requirement |image:extracted-media/media/image181.png[image,width=115,height=10]
|===

===== Authority Requirement

[width="100%",cols="36%,64%",options="header",]
|===
|*DMNElement* |*Depiction*
|Authority Requirement |image:extracted-media/media/image182.wmf[image,width=144,height=17]
|===

===== Association

When the DMNEdge depicts an Association, its DMNElement MUST be specified.

[width="100%",cols="38%,62%",options="header",]
|===
a|
____
*DMNElement*
____

|*Depiction*
a|
____
Association where associationDirection is none.
____

|image:extracted-media/media/image183.wmf[image,width=119,height=21]
a|
____
Association where associationDirection is one.
____

|image:extracted-media/media/image184.wmf[image,width=119,height=23]
a|
____
Association where associationDirection is both.
____

|image:extracted-media/media/image185.wmf[image,width=119,height=28]
|===

This page intentionally left blank.

____
*ANNEXES*
____

All the Annexes are informative.

Annex A. discuss issues around the application of *DMN* in combination with *BPMN*. This section is intended to provide some direction to practitioners but is non-normative.

Annex B. provides a non-normative glossary to aid comprehension of the specification.

This page intentionally left blank.

[upperalpha]
. {blank}

[#_Toc87278776 .anchor]####Relation to BPMN(Informative)

[arabic]
. {blank}

[#_Toc87278777 .anchor]####Goals of BPMN and DMNThe OMG Business Process Model and Notation Standard provides a standard notation for describing business processes as orchestrations of tasks. The success of *BPMN* has provided a major motivation for *DMN,* and business decisions described using *DMN* are expected to be commonly deployed in business processes described using *BPMN*.

All statements pertaining to *BPMN* below are from the OMG document reference 11-01-03 unless otherwise stated.

*BPMN*’s goals are stated in the specification and provide easy comparisons to *DMN*:

* {blank}
* {blank}
* {blank}
[arabic]
. {blank}

Goal 1: “_The primary goal of_ *BPMN* _is to provide a notation that is readily understandable by all business users, from the business analysts that create the initial drafts of the processes, to the technical developers responsible for implementing the technology that will perform those processes, and finally, to the business people who will manage and monitor those processes. Thus,_ *BPMN* _creates a standardized bridge for the gap between the business process design and process implementation._”. *DMN* users will also be business analysts (designing decisions) and then business users (populating decision models such as decision tables). Technical developers may be responsible for mapping business terms to appropriate data technologies. Therefore, *DMN* can also be said to bridge the decision design by a business analyst, and the decision implementation, typically using some decision execution technology,Goal 2: _“... To ensure that XML languages designed for the execution of business processes, such as WSBPEL (Web Services Business Process Execution Language), can be visualized with a business-oriented notation.”_ It is not a stated goal of *DMN* to be able to visualize other XML languages (such as W3C RIF or OMG PRR); indeed, it is expected that *DMN* would provide the MDA specification layer for such languages. It does not preclude however the use of *DMN* (such as decision tables) to represent executable forms (such as production rules).Goal 3: _“The intent of_ *BPMN* _is to standardize a business process model and notation in the face of many different modeling notations and viewpoints. In doing so,_ *BPMN* _will provide a simple means of communicating process information to other business users, process implementers, customers, and suppliers.”_ Similarly, the intent of *DMN* is to standardize the decision model and notation across the many different implementations of broadly semantically similar models. In so doing, *DM N* will also facilitate the communication of decision information across business communities and tools.[#_Toc87278778 .anchor]####BPMN Tasks and DMN DecisionsMost *BPMN* diagrams contain some tasks which involve decision-making which can be modeled in *DMN*. These tasks take input data acquired or generated earlier in the process, and produce decision outputs which are used later in the process. Decision outputs may be used in two principal ways:

* {blank}
* {blank}

They may be consumed in another process task.They may influence the choice of sequence flows out of a gateway. +
In the latter case, decisions are used to determine which subprocesses or tasks are to be executed (in the process sense). As such, *DMN* complements *BPMN* as decision modeling complements process modeling (in the sense of defining orchestrations or work tasks).

____
For example, **Figure A. _1_**shows an example^1^ of a *BPMN*-defined process.
____

image:extracted-media/media/image186.wmf[image,width=650,height=336]

*Figure A. 1: Decision-making in BPMN*

Analyzing this we see:

* {blank}
* {blank}
* {blank}

A task whose title starts with “Decide...” which makes a decision on (whether to use) normal post or special shipment, and which precedes an exclusive gateway using that decision result.A task whose title starts with “Check...” which makes a decision on whether extra insurance is necessary, which precedes an inclusive gateway for which an additional process path may be executed based on the decision result.A task whose title starts with “Assign...” which implies a decision to select a carrier based on some selection criteria. The previous task is effectively collecting data for this decision. In an automated system this would probably be a subprocess embedding a decision and some other activities (such as “prepare paperwork”). +
From this example we can see that even a simple business process in *BPMN* may have several decision-making tasks.

[arabic]
. {blank}

[#_Toc87278779 .anchor]####Types of BPMN Tasks relevant to DMN**BPMN** defines^2^ different types of tasks that can be considered for decision-making roles. The relevant tasks are as shown in *Table _111_*:

~1.Shipment Process in a Hardware Retailer example, Ch5.1, BPMN 2.0 By Example, June 2010, OMG reference 10-06-02 +
2.See ch 10.2.3 in the BPMN Specification.~

image:extracted-media/media/image187.png[image,width=615,height=442]

A future version of *BPMN* may choose to clarify and extend the definitions of task to better match decision modeling requirements and *DMN* – to wit, to define a *BPMN* Decision Task as some task used to make a decision modeled with *DMN*. In the meantime, the Business Rule Task is the most natural way to express this functionality. However, as noted in clauses 5.2.2 and 6.3.6, a Decision in *DMN* can be associated with any Task, allowing for flexibility in implementation.

[arabic, start=2]
. {blank}

[#_Toc87278780 .anchor]####Process gateways and DecisionsProcess gateways can be considered of 2 types:

[arabic]
. {blank}
. {blank}

A gateway that determines a process route or routes based on existing dataA gateway that determines a process route or routes based on the outcome of one or more decisions that are determined by some previous task within the process. +
In the latter case, a Decision Task (task used to make a decision using *DMN*) may need an extended notation to clarify the relationship of the decision task to the gateway(s) that use it.

[arabic]
. {blank}

[#_Toc87278781 .anchor]####Linking BPMN and DMN Models**DMN** offers two approaches to linking business process models in *BPMN* with decision models; one normative and the other non-normative:

____
*a) Associating Decisions with Tasks and Processes*
____

As described in clause 6.3.6, in *DMN*, the process context for an instance of Decision is defined by its association with any number of usingProcesses, which are instances of Process as defined in OMG *BPMN 2*, and any number of usingTasks, which are instances of Task as defined in OMG *BPMN 2*. Each decision may therefore be associated with one or more business processes (to indicate that the decision is taken during those processes), and/or with one or more specific tasks (to indicate that the tasks involve making the decision). An implementation SHALL allow these associations to be defined for each decision.

An implementation MAY perform validation over the two (*BPMN* and *DMN*) models, to check, for example, that:

* {blank}
* {blank}

A Decision is not associated with Tasks that are part of Processes not also associated with the Decision.A Decision is not associated with Tasks that are not part of any Process associated with the Decision. +
During development it may be appropriate to associate a Decision only with a Process, but inconsistency between Task and Process associations is not allowed.

Note that this approach allows the relationships between business process models and decision models to be defined and validated, but does not of itself permit the decisions modeled in *DMN* to be executed automatically by processes modeled in *BPMN*.

____
*b) Decision Services*
____

One approach to decision automation is described non-normatively in Annex A: the encapsulation of *DMN* Decisions in a “decision service” called from a *BPMN* Task (e.g. a Service Task or Business Rule Task, as discussed in Annex A..3 above). The usingProcesses and usingTasks properties allow definition and validation of associations between *BPMN* and *DMN*; the definition of decision services then provides a detailed specification of the required interface.

[upperalpha, start=2]
. {blank}

[#_Toc87278782 .anchor]##: Glossary(Informative)

[width="100%",cols="51%,49%",options="header",]
|===
|*A* |
|Aggregation a|
____
The production of a single result from multiple *hits* on a *decision table*. DMN specifies four aggregation operators on the Collect hit policy, namely: + (sum), < (min), > (max), # (count). If no operator is specified, the results of the Collect hit policy are returned without being aggregated.
____

|Any a|
____
A *hit policy* for *single hit decision tables* with overlapping *decision rules*: under this policy any match may be used.
____

|Authority Requirement a|
____
The dependency of one element of a Decision Requirements Graph on another element which provides guidance to it or acts as a source of knowledge for it.
____

|*B* |
|Binding a|
____
In an *invocation*, the association of the parameters of the invoked expression with the input variables of the invoking expression, using a binding formula.
____

|Boxed Context a|
____
A form of *boxed expression* showing a collection of _n_ (name, value) pairs with an optional result value.
____

|Boxed Expression a|
____
A notation serving to decompose *decision logic* into small pieces which may be associated graphically with elements of a *DRD*.
____

|Boxed Function a|
____
A form of *boxed expression* showing the kind, parameters and body of a function.
____

|Boxed Invocation a|
____
A form of *boxed expression* showing the parameter bindings that provide the context for the evaluation of the body of a *business knowledge model*.
____

|Boxed List a|
____
A form of *boxed expression* showing a list of _n_ items.
____

|Boxed Literal Expression a|
____
A form of *boxed expression* showing a *literal expression*.
____

|Business Context Element a|
____
An element representing the business context of a decision: either an *organisational unit* or a *performance indicator*.
____

|Business Knowledge Model a|
____
Some *decision logic* (e.g. a *decision table*) encapsulated as a reusable function, which may be invoked by *decisions* or by other *business knowledge models*.
____

|*C* |
|Clause |In a *decision table*, a clause specifies a subject, which is defined by an input expression or an output domain, and the finite set of the sub-domains of the subject’s domain that are relevant for the piece of *decision logic* that is described by the decision table.
|Collect a|
____
A *hit policy* for *multiple hit decision tables* with overlapping *decision rules*: under this policy all matches will be returned as a list in an arbitrary order. An operator can be added to specify a function to be applied to the outputs: see Aggregation.
____

|Context a|
____
In *FEEL*, a map of key-value pairs called *context entries*.
____

|Context Entry a|
____
One key-value pair in a *context*.
____

|Crosstab Table a|
____
An *orientation* for *decision tables* in which two *input expressions* form the two dimensions of the table, and the *output entries* form a two-dimensional grid.
____

|*D* |
|Decision a|
____
The act of determining an *output value* from a number of *input values*, using *decision logic* defining how the output is determined from the inputs.
____

|Decision Logic a|
____
The logic used to make decisions, defined in DMN as the *value expressions* of *decisions* and *business knowledge models* and represented visually as *boxed expressions*.
____

|Decision Logic Level a|
____
The detailed level of modeling in DMN, consisting of the *value expressions* associated with *decisions* and *business knowledge models*.
____

|Decision Model a|
____
A formal model of an area of decision-making, expressed in DMN as *decision requirements* and *decision logic*.
____

|Decision Point a|
____
A point in a business process at which decision-making occurs, modeled in BPMN 2.0 as a business rule task and possibly implemented as a call to a *decision service*.
____

|Decision Requirements Diagram a|
____
A diagram presenting a (possibly filtered) view of a *DRG*.
____

|Decision Requirements Graph a|
____
A graph of *DRG elements* (*decisions*, *business knowledge models* and *input data*) connected by *requirements*.
____

|Decision Requirements Level a|
____
The more abstract level of modeling in DMN, consisting of a *DRG* represented in one or more *DRDs*.
____

|Decision Rule a|
____
In a *decision table*, a decision rule specifies associates a set of conclusions or results (*output entries*) with a set of conditions (*input entries*).
____

|Decision Service a|
____
A software component encapsulating a *decision model* and exposing it as a service, which might be consumed (for example) by a task in a BPMN process model.
____

|Decision Table a|
____
A tabular representation of a set of related input and output expressions, organized into *decision rules* indicating which *output entry* applies to a specific set of *input entries*.
____

|Definitions a|
____
A container for all elements of a DMN *decision model*. The interchange of DMN files will always be through one or more Definitions.
____

|DMN Element a|
____
Any element of a DMN *decision model*: a *DRG Element*,*Business Context Element*, *Expression*, *Definitions*, *Element Collection*, *Information Item* or *Item Definition*.
____

|DRD a|
____
See *Decision Requirements Diagram*.
____

|DRG a|
____
See *Decision Requirements Graph*.
____

|DRG Element a|
____
Any component of a *DRG*: a *decision*, *business knowledge model*, *input data* or *knowledge source*.
____

|*E* |
|Element Collection a|
____
Used to define named groups of *DRG elements* within a *Definitions*.
____

|Expression a|
____
A *literal expression*, *decision table, invocation*, list, *context*, function definition, or *relation* used to define part of the *decision logic* for a *decision model* in *DMN*. Returns a single value when interpreted.
____

|*F* |
|FEEL a|
____
The “Friendly Enough Expression Language” which is the default expression language for DMN.
____

|First a|
____
A *hit policy* for *single hit decision tables* with overlapping *decision rules*: under this policy the first match is used, based on the order of the *decision rules*.
____

|Formal Parameter a|
____
A named, typed value used in the invocation of a function to provide an *information item* for use in the body of the function.
____

|*H* |
|Hit a|
____
In a *decision table*, the successful matching of all *input expressions* of a *decision rule*, making the conclusion eligible for inclusion in the results.
____

|Hit Policy a|
____
Indicates how overlapping *decision rules* have to be interpreted. A *single hit* table returns the output of one rule only; a *multiple hit* table may return the output of multiple rules or an *aggregation* of the outputs.
____

|Horizontal a|
____
An orientation for *decision tables* in which *decision rules* are presented as rows; *clauses* as columns.
____

|*I* |
|Information Item a|
____
A *DMN element* used to model either a *variable* or a *parameter* at the *decision logic level* in DMN *decision models*.
____

|Information Requirement a|
____
The dependency of a *decision* on an *input data* element or another *decision* to provide a *variable* used in its *decision logic*.
____

|Input Data a|
____
Denotes information used as an input by one or more *decisions*, whose value is defined outside of the *decision model*.
____

|Input Entry a|
____
An *expression* defining a condition cell in a *decision table* (i.e. the intersection of a *decision rule* and an input *clause*).
____

|Input Expression a|
____
An *expression* defining the item to be compared with the *input entries* of an input *clause* in a *decision table*.
____

|Input Value a|
____
An *expression* defining a limited range of expected values for an input *clause* in a *decision table*.
____

|Invocation a|
____
A mechanism that permits the evaluation of one value expression another, using a number of *bindings*.
____

|Item Definition a|
____
Used to model the structure and the range of values of *input data* and the outcome of *decisions*, using a type language such as *FEEL* or XML Schema.
____

|*K* |
|Knowledge Requirement a|
____
The dependency of a *decision* or *business knowledge model* on a *business knowledge model* which must be invoked in the evaluation of its *decision logic*.
____

|Knowledge Source a|
____
An authority defined for *decisions* or *business knowledge models*, e.g. domain experts responsible for defining or maintaining them, or source documents from which business knowledge models are derived, or sets of test cases with which the decisions must be consistent.
____

|*L* |
|Literal Expression a|
____
Text that represents *decision logic* by describing how an output value is derived from its input values, e.g. in plain +
English or using the default expression language *FEEL*.
____

|*M* |
|Multiple Hit a|
____
A type of *decision table* which may return *output entries* from multiple *decision rules*.
____

|*O* |
|Organisational Unit a|
____
A *business context element* representing the unit of an organization which makes or owns a *decision*.
____

|Orientation a|
____
The style of presentation of a *decision table*: horizontal (decision rules as rows; clauses as columns), vertical (rules as columns; clauses as rows), or crosstab (rules composed from two input dimensions).
____

|Output Entry a|
____
An *expression* defining a conclusion cell in a *decision table* (i.e. the intersection of a *decision rule* and an output *clause*).
____

|Output Order a|
____
A *hit policy* for *multiple hit decision tables* with overlapping *decision rules*: under this policy all matches will be returned as a list in decreasing priority order. Output priorities are specified in an ordered list of values.
____

|Output Value a|
____
An *expression* defining a limited range of domain values for an output *clause* in a *decision table*.
____

|*P* |
|Performance Indicator a|
____
A *business context element* representing a measure of business performance impacted by a *decision*.
____

|Priority a|
____
A *hit policy* for *single hit decision tables* with overlapping *decision rules*: under this policy the match is used that has the highest output priority. Output priorities are specified in an ordered list of values.
____

|*R* |
|Relation a|
____
A form of *boxed expression* showing a vertical list of homogeneous horizontal *contexts* (with no result cells) with the names appearing just once at the top of the list, like a relational table.
____

|Requirement a|
____
The dependency of one *DRG element* on another: either an *information requirement*, *knowledge requirement* or *authority requirement*.
____

|Requirement Subgraph a|
____
The directed graph resulting from the transitive closure of the *requirements* of a *DRG element*; i.e. the sub-graph of the *DRG* representing all the decision-making required by a particular element.
____

|Rule Order a|
____
A *hit policy* for *multiple hit decision tables* with overlapping *decision rules*: under this policy all matches will be returned as a list in the order of definition of the *decision rules*.
____

|*S* |
|S-FEEL a|
____
A simple subset of *FEEL*, for *decision models* that use only simple *expressions*: in particular, *decision models* where the *decision logic* is modeled mostly or only using *decision tables*.
____

|Single Hit a|
____
A type of *decision table* which may return the *output entry* of only a single *decision rule*.
____

|*U* |
|Unique a|
____
A *hit policy* for *single hit decision tables* in which no overlap is possible and all *decision rules* are exclusive. Only a single rule can be matched.
____

|*V* |
|Variable a|
____
Represents a value that is input to a *decision*, in the description of its *decision logic*, or a value that is passed as a *parameter* to a function.
____

|Vertical a|
____
An *orientation* for *decision tables* in which decision rules are presented as columns; clauses as rows.
____

|*W* |
|Well-Formed a|
____
Used of a *DRG element* or *requirement* to indicate that it conforms to constraints on referential integrity, acyclicity etc.
____

|===
